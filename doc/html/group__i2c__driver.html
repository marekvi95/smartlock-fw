<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smartlock: I2c_driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smartlock
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">I2c_driver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__i2c__master__config.html">_i2c_master_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master user configuration.  <a href="struct__i2c__master__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__i2c__slave__config.html">_i2c_slave_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave user configuration.  <a href="struct__i2c__slave__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__i2c__master__transfer.html">_i2c_master_transfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master transfer structure.  <a href="struct__i2c__master__transfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__i2c__master__handle.html">_i2c_master_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master handle structure.  <a href="struct__i2c__master__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__i2c__slave__transfer.html">_i2c_slave_transfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave transfer structure.  <a href="struct__i2c__slave__transfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__i2c__slave__handle.html">_i2c_slave_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave handle structure.  <a href="struct__i2c__slave__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2671b092f0b079174303710fa89f02bd"><td class="memItemLeft" align="right" valign="top"><a id="ga2671b092f0b079174303710fa89f02bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga2671b092f0b079174303710fa89f02bd">I2C_WAIT_TIMEOUT</a>&#160;&#160;&#160;0U /* Define to zero means keep waiting until the flag is assert/deassert. */</td></tr>
<tr class="memdesc:ga2671b092f0b079174303710fa89f02bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Timeout times for waiting flag. <br /></td></tr>
<tr class="separator:ga2671b092f0b079174303710fa89f02bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace639c1e5e7cdcecb1cca2e52c669029"><td class="memItemLeft" align="right" valign="top"><a id="gace639c1e5e7cdcecb1cca2e52c669029"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gace639c1e5e7cdcecb1cca2e52c669029">I2C_MASTER_FACK_CONTROL</a>&#160;&#160;&#160;0U /* Default defines to zero means master will send ack automatically. */</td></tr>
<tr class="memdesc:gace639c1e5e7cdcecb1cca2e52c669029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mater Fast ack control, control if master needs to manually write ack, this is used to low the speed of transfer for SoCs with feature FSL_FEATURE_I2C_HAS_DOUBLE_BUFFERING. <br /></td></tr>
<tr class="separator:gace639c1e5e7cdcecb1cca2e52c669029"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga4bf954d998f086594eece268c780bec7"><td class="memItemLeft" align="right" valign="top"><a id="ga4bf954d998f086594eece268c780bec7"></a>
typedef enum <a class="el" href="group__i2c__driver.html#ga1625497320644ba123718bafdd2c1f39">_i2c_direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga4bf954d998f086594eece268c780bec7">i2c_direction_t</a></td></tr>
<tr class="memdesc:ga4bf954d998f086594eece268c780bec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction of master and slave transfers. <br /></td></tr>
<tr class="separator:ga4bf954d998f086594eece268c780bec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70379ff75d2f4591b8dc1ba107a2a606"><td class="memItemLeft" align="right" valign="top"><a id="ga70379ff75d2f4591b8dc1ba107a2a606"></a>
typedef enum <a class="el" href="group__i2c__driver.html#gae1e1e45d8491652a249bf48530911ac7">_i2c_slave_address_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga70379ff75d2f4591b8dc1ba107a2a606">i2c_slave_address_mode_t</a></td></tr>
<tr class="memdesc:ga70379ff75d2f4591b8dc1ba107a2a606"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addressing mode. <br /></td></tr>
<tr class="separator:ga70379ff75d2f4591b8dc1ba107a2a606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95f120f6a73af41648364538cf9a6eca"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group__i2c__driver.html#ga87e42e170b60f17f657ef3c06a918133">_i2c_slave_transfer_event</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga95f120f6a73af41648364538cf9a6eca">i2c_slave_transfer_event_t</a></td></tr>
<tr class="memdesc:ga95f120f6a73af41648364538cf9a6eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of events sent to the callback for nonblocking slave transfers.  <a href="#ga95f120f6a73af41648364538cf9a6eca">More...</a><br /></td></tr>
<tr class="separator:ga95f120f6a73af41648364538cf9a6eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad739710b6b65e12ca5ba9dc2a2a2b463"><td class="memItemLeft" align="right" valign="top"><a id="gad739710b6b65e12ca5ba9dc2a2a2b463"></a>
typedef struct <a class="el" href="struct__i2c__master__config.html">_i2c_master_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gad739710b6b65e12ca5ba9dc2a2a2b463">i2c_master_config_t</a></td></tr>
<tr class="memdesc:gad739710b6b65e12ca5ba9dc2a2a2b463"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master user configuration. <br /></td></tr>
<tr class="separator:gad739710b6b65e12ca5ba9dc2a2a2b463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa70dd0ec9815617269569190efd2de5d"><td class="memItemLeft" align="right" valign="top"><a id="gaa70dd0ec9815617269569190efd2de5d"></a>
typedef struct <a class="el" href="struct__i2c__slave__config.html">_i2c_slave_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gaa70dd0ec9815617269569190efd2de5d">i2c_slave_config_t</a></td></tr>
<tr class="memdesc:gaa70dd0ec9815617269569190efd2de5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave user configuration. <br /></td></tr>
<tr class="separator:gaa70dd0ec9815617269569190efd2de5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd51f58b8cfd309be985bce4b817fdc"><td class="memItemLeft" align="right" valign="top"><a id="ga2fd51f58b8cfd309be985bce4b817fdc"></a>
typedef struct <a class="el" href="struct__i2c__master__handle.html">_i2c_master_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a></td></tr>
<tr class="memdesc:ga2fd51f58b8cfd309be985bce4b817fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master handle typedef. <br /></td></tr>
<tr class="separator:ga2fd51f58b8cfd309be985bce4b817fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa39d30cd808d79b774361874f227204"><td class="memItemLeft" align="right" valign="top"><a id="gafa39d30cd808d79b774361874f227204"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gafa39d30cd808d79b774361874f227204">i2c_master_transfer_callback_t</a>) (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *handle, <a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> status, void *userData)</td></tr>
<tr class="memdesc:gafa39d30cd808d79b774361874f227204"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master transfer callback typedef. <br /></td></tr>
<tr class="separator:gafa39d30cd808d79b774361874f227204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga394e5278816efe62815de9d25be84752"><td class="memItemLeft" align="right" valign="top"><a id="ga394e5278816efe62815de9d25be84752"></a>
typedef struct <a class="el" href="struct__i2c__slave__handle.html">_i2c_slave_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a></td></tr>
<tr class="memdesc:ga394e5278816efe62815de9d25be84752"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave handle typedef. <br /></td></tr>
<tr class="separator:ga394e5278816efe62815de9d25be84752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e25c3c153992361c8d359a86b70d3c6"><td class="memItemLeft" align="right" valign="top"><a id="ga0e25c3c153992361c8d359a86b70d3c6"></a>
typedef struct <a class="el" href="struct__i2c__master__transfer.html">_i2c_master_transfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga0e25c3c153992361c8d359a86b70d3c6">i2c_master_transfer_t</a></td></tr>
<tr class="memdesc:ga0e25c3c153992361c8d359a86b70d3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C master transfer structure. <br /></td></tr>
<tr class="separator:ga0e25c3c153992361c8d359a86b70d3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e696cb21165bc58176475879a471cf"><td class="memItemLeft" align="right" valign="top"><a id="ga69e696cb21165bc58176475879a471cf"></a>
typedef struct <a class="el" href="struct__i2c__slave__transfer.html">_i2c_slave_transfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga69e696cb21165bc58176475879a471cf">i2c_slave_transfer_t</a></td></tr>
<tr class="memdesc:ga69e696cb21165bc58176475879a471cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave transfer structure. <br /></td></tr>
<tr class="separator:ga69e696cb21165bc58176475879a471cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2583e3d8ebf8d3de410d8b6263238c35"><td class="memItemLeft" align="right" valign="top"><a id="ga2583e3d8ebf8d3de410d8b6263238c35"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga2583e3d8ebf8d3de410d8b6263238c35">i2c_slave_transfer_callback_t</a>) (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga69e696cb21165bc58176475879a471cf">i2c_slave_transfer_t</a> *xfer, void *userData)</td></tr>
<tr class="memdesc:ga2583e3d8ebf8d3de410d8b6263238c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C slave transfer callback typedef. <br /></td></tr>
<tr class="separator:ga2583e3d8ebf8d3de410d8b6263238c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7cc91c89125c25a88e463a9e8550b284"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga7cc91c89125c25a88e463a9e8550b284">_i2c_status</a> { <br />
&#160;&#160;<a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284a49091894b590d7e479605bf113918952">kStatus_I2C_Busy</a> = MAKE_STATUS(kStatusGroup_I2C, 0), 
<a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284a628d242f7bc0e3d5949c7f73eafaa508">kStatus_I2C_Idle</a> = MAKE_STATUS(kStatusGroup_I2C, 1), 
<a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284a72fd33d0b5263a63766e62f71d16be00">kStatus_I2C_Nak</a> = MAKE_STATUS(kStatusGroup_I2C, 2), 
<a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284a139b52cc3305ec2c06d0ac94313c221f">kStatus_I2C_ArbitrationLost</a> = MAKE_STATUS(kStatusGroup_I2C, 3), 
<br />
&#160;&#160;<a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284a81ad7cc198436cabbe91ea55c5288747">kStatus_I2C_Timeout</a> = MAKE_STATUS(kStatusGroup_I2C, 4), 
<a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284adf7437bfedcc0d57338ed33f1be5c805">kStatus_I2C_Addr_Nak</a> = MAKE_STATUS(kStatusGroup_I2C, 5)
<br />
 }</td></tr>
<tr class="memdesc:ga7cc91c89125c25a88e463a9e8550b284"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C status return codes.  <a href="group__i2c__driver.html#ga7cc91c89125c25a88e463a9e8550b284">More...</a><br /></td></tr>
<tr class="separator:ga7cc91c89125c25a88e463a9e8550b284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1337bbe9d0b184d9dcee31f9ebade2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga1f1337bbe9d0b184d9dcee31f9ebade2">_i2c_flags</a> { <br />
&#160;&#160;<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a4c3c2928e17ddbfbc1c346c6b9a8dccd">kI2C_ReceiveNakFlag</a> = I2C_S_RXAK_MASK, 
<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a647d0b1d1f9514ad483bef3ea3926c3b">kI2C_IntPendingFlag</a> = I2C_S_IICIF_MASK, 
<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a249f698970909f33b1b96139c05bd969">kI2C_TransferDirectionFlag</a> = I2C_S_SRW_MASK, 
<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2aac2c3a26d38c01fba1554eddc0c6b8b5">kI2C_RangeAddressMatchFlag</a> = I2C_S_RAM_MASK, 
<br />
&#160;&#160;<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a39fab5ef04e74d00ef4c4574899ab589">kI2C_ArbitrationLostFlag</a> = I2C_S_ARBL_MASK, 
<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a37fb20742a15a63c1bc2551b997cdcff">kI2C_BusBusyFlag</a> = I2C_S_BUSY_MASK, 
<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a10cd5797b1b8f809192423486a85d5fe">kI2C_AddressMatchFlag</a> = I2C_S_IAAS_MASK, 
<a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2adb8f10365dfc2a3e849f05173fa4d83e">kI2C_TransferCompleteFlag</a> = I2C_S_TCF_MASK
<br />
 }</td></tr>
<tr class="memdesc:ga1f1337bbe9d0b184d9dcee31f9ebade2"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C peripheral flags.  <a href="group__i2c__driver.html#ga1f1337bbe9d0b184d9dcee31f9ebade2">More...</a><br /></td></tr>
<tr class="separator:ga1f1337bbe9d0b184d9dcee31f9ebade2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87c81dd985dad07dc26cb93125a94ec7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga87c81dd985dad07dc26cb93125a94ec7">_i2c_interrupt_enable</a> { <a class="el" href="group__i2c__driver.html#gga87c81dd985dad07dc26cb93125a94ec7a5526e27ef6e8317ba928849da890b3b2">kI2C_GlobalInterruptEnable</a> = I2C_C1_IICIE_MASK
 }</td></tr>
<tr class="memdesc:ga87c81dd985dad07dc26cb93125a94ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C feature interrupt source.  <a href="group__i2c__driver.html#ga87c81dd985dad07dc26cb93125a94ec7">More...</a><br /></td></tr>
<tr class="separator:ga87c81dd985dad07dc26cb93125a94ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1625497320644ba123718bafdd2c1f39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga1625497320644ba123718bafdd2c1f39">_i2c_direction</a> { <a class="el" href="group__i2c__driver.html#gga1625497320644ba123718bafdd2c1f39a93b476b469c2a4bfed5916b458ae9bb0">kI2C_Write</a> = 0x0U, 
<a class="el" href="group__i2c__driver.html#gga1625497320644ba123718bafdd2c1f39a3a7bb24dc8d1c1be8925603eeafe9b30">kI2C_Read</a> = 0x1U
 }</td></tr>
<tr class="memdesc:ga1625497320644ba123718bafdd2c1f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">The direction of master and slave transfers.  <a href="group__i2c__driver.html#ga1625497320644ba123718bafdd2c1f39">More...</a><br /></td></tr>
<tr class="separator:ga1625497320644ba123718bafdd2c1f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1e1e45d8491652a249bf48530911ac7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gae1e1e45d8491652a249bf48530911ac7">_i2c_slave_address_mode</a> { <a class="el" href="group__i2c__driver.html#ggae1e1e45d8491652a249bf48530911ac7a3e2c7f1f917939d0d7595224e3700dd4">kI2C_Address7bit</a> = 0x0U, 
<a class="el" href="group__i2c__driver.html#ggae1e1e45d8491652a249bf48530911ac7aa2c312f87691c542c466ff747d21f70a">kI2C_RangeMatch</a> = 0X2U
 }</td></tr>
<tr class="memdesc:gae1e1e45d8491652a249bf48530911ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addressing mode.  <a href="group__i2c__driver.html#gae1e1e45d8491652a249bf48530911ac7">More...</a><br /></td></tr>
<tr class="separator:gae1e1e45d8491652a249bf48530911ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87ea07668194cfb46c7c368d2cb42433"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga87ea07668194cfb46c7c368d2cb42433">_i2c_master_transfer_flags</a> { <a class="el" href="group__i2c__driver.html#gga87ea07668194cfb46c7c368d2cb42433ae80f7b768b1621e42ac965d3d23de5e2">kI2C_TransferDefaultFlag</a> = 0x0U, 
<a class="el" href="group__i2c__driver.html#gga87ea07668194cfb46c7c368d2cb42433a5cb44bf860c0482c0ca0165cf0d31d8a">kI2C_TransferNoStartFlag</a> = 0x1U, 
<a class="el" href="group__i2c__driver.html#gga87ea07668194cfb46c7c368d2cb42433aadf112471ef12f194985a093cd9b9721">kI2C_TransferRepeatedStartFlag</a> = 0x2U, 
<a class="el" href="group__i2c__driver.html#gga87ea07668194cfb46c7c368d2cb42433afb8aeea71b5b7475e3d3df86220db566">kI2C_TransferNoStopFlag</a> = 0x4U
 }</td></tr>
<tr class="memdesc:ga87ea07668194cfb46c7c368d2cb42433"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C transfer control flag.  <a href="group__i2c__driver.html#ga87ea07668194cfb46c7c368d2cb42433">More...</a><br /></td></tr>
<tr class="separator:ga87ea07668194cfb46c7c368d2cb42433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e42e170b60f17f657ef3c06a918133"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga87e42e170b60f17f657ef3c06a918133">_i2c_slave_transfer_event</a> { <br />
&#160;&#160;<a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133acb1ae174dd6798a6fd79800a9e39a3c6">kI2C_SlaveAddressMatchEvent</a> = 0x01U, 
<a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a2f85039a57379838909876a1d509b7aa">kI2C_SlaveTransmitEvent</a> = 0x02U, 
<a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133aac8593e808a8137d1b5d3a51640779de">kI2C_SlaveReceiveEvent</a> = 0x04U, 
<a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a43c045da27fa60e7a0540c743eca4e79">kI2C_SlaveTransmitAckEvent</a> = 0x08U, 
<br />
&#160;&#160;<a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a38cca3cd668e73f51b8e574835d419df">kI2C_SlaveCompletionEvent</a> = 0x20U, 
<a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a5063c09cccc4d8047aa3d33ff979657b">kI2C_SlaveGenaralcallEvent</a> = 0x40U, 
<a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a94b030ebdac378a84961893ae567bfbc">kI2C_SlaveAllEvents</a>
<br />
 }</td></tr>
<tr class="memdesc:ga87e42e170b60f17f657ef3c06a918133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of events sent to the callback for nonblocking slave transfers.  <a href="group__i2c__driver.html#ga87e42e170b60f17f657ef3c06a918133">More...</a><br /></td></tr>
<tr class="separator:ga87e42e170b60f17f657ef3c06a918133"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Driver version</h2></td></tr>
<tr class="memitem:ga60fdaec284298758a650ce1122aef231"><td class="memItemLeft" align="right" valign="top"><a id="ga60fdaec284298758a650ce1122aef231"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga60fdaec284298758a650ce1122aef231">FSL_I2C_DRIVER_VERSION</a>&#160;&#160;&#160;(<a class="el" href="group__ftfx__utilities.html#ga812138aa3315b0c6953c1a26130bcc37">MAKE_VERSION</a>(2, 0, 8))</td></tr>
<tr class="memdesc:ga60fdaec284298758a650ce1122aef231"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C driver version 2.0.8. <br /></td></tr>
<tr class="separator:ga60fdaec284298758a650ce1122aef231"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and deinitialization</h2></td></tr>
<tr class="memitem:ga29f967b3ae8487a36ba2a58deb01ccae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga29f967b3ae8487a36ba2a58deb01ccae">I2C_MasterInit</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, const <a class="el" href="group__i2c__driver.html#gad739710b6b65e12ca5ba9dc2a2a2b463">i2c_master_config_t</a> *masterConfig, uint32_t srcClock_Hz)</td></tr>
<tr class="memdesc:ga29f967b3ae8487a36ba2a58deb01ccae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the I2C peripheral. Call this API to ungate the I2C clock and configure the I2C with master configuration.  <a href="#ga29f967b3ae8487a36ba2a58deb01ccae">More...</a><br /></td></tr>
<tr class="separator:ga29f967b3ae8487a36ba2a58deb01ccae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2397a88554ea896f212dd262f9bc731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gaf2397a88554ea896f212dd262f9bc731">I2C_SlaveInit</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, const <a class="el" href="group__i2c__driver.html#gaa70dd0ec9815617269569190efd2de5d">i2c_slave_config_t</a> *slaveConfig, uint32_t srcClock_Hz)</td></tr>
<tr class="memdesc:gaf2397a88554ea896f212dd262f9bc731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the I2C peripheral. Call this API to ungate the I2C clock and initialize the I2C with the slave configuration.  <a href="#gaf2397a88554ea896f212dd262f9bc731">More...</a><br /></td></tr>
<tr class="separator:gaf2397a88554ea896f212dd262f9bc731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcf7122f0a38d4d9da0f052fcb167957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gadcf7122f0a38d4d9da0f052fcb167957">I2C_MasterDeinit</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base)</td></tr>
<tr class="memdesc:gadcf7122f0a38d4d9da0f052fcb167957"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the I2C master peripheral. Call this API to gate the I2C clock. The I2C master module can't work unless the I2C_MasterInit is called.  <a href="#gadcf7122f0a38d4d9da0f052fcb167957">More...</a><br /></td></tr>
<tr class="separator:gadcf7122f0a38d4d9da0f052fcb167957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb50014db29dd75ea2001fb7bc837e77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gadb50014db29dd75ea2001fb7bc837e77">I2C_SlaveDeinit</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base)</td></tr>
<tr class="memdesc:gadb50014db29dd75ea2001fb7bc837e77"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the I2C slave peripheral. Calling this API gates the I2C clock. The I2C slave module can't work unless the I2C_SlaveInit is called to enable the clock.  <a href="#gadb50014db29dd75ea2001fb7bc837e77">More...</a><br /></td></tr>
<tr class="separator:gadb50014db29dd75ea2001fb7bc837e77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07cc6bd20f700249c335893427bf462a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga07cc6bd20f700249c335893427bf462a">I2C_GetInstance</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base)</td></tr>
<tr class="memdesc:ga07cc6bd20f700249c335893427bf462a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get instance number for I2C module.  <a href="#ga07cc6bd20f700249c335893427bf462a">More...</a><br /></td></tr>
<tr class="separator:ga07cc6bd20f700249c335893427bf462a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad69f2d63ea756dda60749ff6b09f587d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gad69f2d63ea756dda60749ff6b09f587d">I2C_MasterGetDefaultConfig</a> (<a class="el" href="group__i2c__driver.html#gad739710b6b65e12ca5ba9dc2a2a2b463">i2c_master_config_t</a> *masterConfig)</td></tr>
<tr class="memdesc:gad69f2d63ea756dda60749ff6b09f587d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the I2C master configuration structure to default values.  <a href="#gad69f2d63ea756dda60749ff6b09f587d">More...</a><br /></td></tr>
<tr class="separator:gad69f2d63ea756dda60749ff6b09f587d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7115f80e28b62bbbd3be1a2a918529ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga7115f80e28b62bbbd3be1a2a918529ba">I2C_SlaveGetDefaultConfig</a> (<a class="el" href="group__i2c__driver.html#gaa70dd0ec9815617269569190efd2de5d">i2c_slave_config_t</a> *slaveConfig)</td></tr>
<tr class="memdesc:ga7115f80e28b62bbbd3be1a2a918529ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the I2C slave configuration structure to default values.  <a href="#ga7115f80e28b62bbbd3be1a2a918529ba">More...</a><br /></td></tr>
<tr class="separator:ga7115f80e28b62bbbd3be1a2a918529ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Status</h2></td></tr>
<tr class="memitem:ga721e41295dedc83b424e80e53065e625"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga721e41295dedc83b424e80e53065e625">I2C_MasterGetStatusFlags</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base)</td></tr>
<tr class="memdesc:ga721e41295dedc83b424e80e53065e625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the I2C status flags.  <a href="#ga721e41295dedc83b424e80e53065e625">More...</a><br /></td></tr>
<tr class="separator:ga721e41295dedc83b424e80e53065e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interrupts</h2></td></tr>
<tr class="memitem:ga577e094cc4d39b88ec5bbe49bc199c77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga577e094cc4d39b88ec5bbe49bc199c77">I2C_EnableInterrupts</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:ga577e094cc4d39b88ec5bbe49bc199c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables I2C interrupt requests.  <a href="#ga577e094cc4d39b88ec5bbe49bc199c77">More...</a><br /></td></tr>
<tr class="separator:ga577e094cc4d39b88ec5bbe49bc199c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9839c1fd49a0f62f42b0adfa74f62853"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga9839c1fd49a0f62f42b0adfa74f62853">I2C_DisableInterrupts</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:ga9839c1fd49a0f62f42b0adfa74f62853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables I2C interrupt requests.  <a href="#ga9839c1fd49a0f62f42b0adfa74f62853">More...</a><br /></td></tr>
<tr class="separator:ga9839c1fd49a0f62f42b0adfa74f62853"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bus Operations</h2></td></tr>
<tr class="memitem:gafeab1d5249a8b39c8d9e1a54a85c23f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gafeab1d5249a8b39c8d9e1a54a85c23f0">I2C_MasterSetBaudRate</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)</td></tr>
<tr class="memdesc:gafeab1d5249a8b39c8d9e1a54a85c23f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the I2C master transfer baud rate.  <a href="#gafeab1d5249a8b39c8d9e1a54a85c23f0">More...</a><br /></td></tr>
<tr class="separator:gafeab1d5249a8b39c8d9e1a54a85c23f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7664234966e4162e952b6d57efcaa8a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga7664234966e4162e952b6d57efcaa8a6">I2C_MasterStart</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, uint8_t address, <a class="el" href="group__i2c__driver.html#ga4bf954d998f086594eece268c780bec7">i2c_direction_t</a> direction)</td></tr>
<tr class="memdesc:ga7664234966e4162e952b6d57efcaa8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a START on the I2C bus.  <a href="#ga7664234966e4162e952b6d57efcaa8a6">More...</a><br /></td></tr>
<tr class="separator:ga7664234966e4162e952b6d57efcaa8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46a8cc094fc18c6cadea8de71448723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gaf46a8cc094fc18c6cadea8de71448723">I2C_MasterStop</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base)</td></tr>
<tr class="memdesc:gaf46a8cc094fc18c6cadea8de71448723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a STOP signal on the I2C bus.  <a href="#gaf46a8cc094fc18c6cadea8de71448723">More...</a><br /></td></tr>
<tr class="separator:gaf46a8cc094fc18c6cadea8de71448723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42ff265d25e713326c7d152adf350147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga42ff265d25e713326c7d152adf350147">I2C_MasterRepeatedStart</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, uint8_t address, <a class="el" href="group__i2c__driver.html#ga4bf954d998f086594eece268c780bec7">i2c_direction_t</a> direction)</td></tr>
<tr class="memdesc:ga42ff265d25e713326c7d152adf350147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a REPEATED START on the I2C bus.  <a href="#ga42ff265d25e713326c7d152adf350147">More...</a><br /></td></tr>
<tr class="separator:ga42ff265d25e713326c7d152adf350147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4e1a954243aa852cb4d358e90091efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gac4e1a954243aa852cb4d358e90091efd">I2C_MasterWriteBlocking</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, const uint8_t *txBuff, size_t txSize, uint32_t flags)</td></tr>
<tr class="memdesc:gac4e1a954243aa852cb4d358e90091efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a polling send transaction on the I2C bus.  <a href="#gac4e1a954243aa852cb4d358e90091efd">More...</a><br /></td></tr>
<tr class="separator:gac4e1a954243aa852cb4d358e90091efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf77526f32a16109abf265dbb022a26ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gaf77526f32a16109abf265dbb022a26ba">I2C_MasterReadBlocking</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, uint8_t *rxBuff, size_t rxSize, uint32_t flags)</td></tr>
<tr class="memdesc:gaf77526f32a16109abf265dbb022a26ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a polling receive transaction on the I2C bus.  <a href="#gaf77526f32a16109abf265dbb022a26ba">More...</a><br /></td></tr>
<tr class="separator:gaf77526f32a16109abf265dbb022a26ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga280404c6b1ede542f2c1c20bd382869c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga280404c6b1ede542f2c1c20bd382869c">I2C_SlaveWriteBlocking</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, const uint8_t *txBuff, size_t txSize)</td></tr>
<tr class="memdesc:ga280404c6b1ede542f2c1c20bd382869c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a polling send transaction on the I2C bus.  <a href="#ga280404c6b1ede542f2c1c20bd382869c">More...</a><br /></td></tr>
<tr class="separator:ga280404c6b1ede542f2c1c20bd382869c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89baaf8bc82b19c837032665e89a1707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga89baaf8bc82b19c837032665e89a1707">I2C_SlaveReadBlocking</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, uint8_t *rxBuff, size_t rxSize)</td></tr>
<tr class="memdesc:ga89baaf8bc82b19c837032665e89a1707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a polling receive transaction on the I2C bus.  <a href="#ga89baaf8bc82b19c837032665e89a1707">More...</a><br /></td></tr>
<tr class="separator:ga89baaf8bc82b19c837032665e89a1707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35cae3a5b4aa50ce8db28e3eb703a027"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga35cae3a5b4aa50ce8db28e3eb703a027">I2C_MasterTransferBlocking</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga0e25c3c153992361c8d359a86b70d3c6">i2c_master_transfer_t</a> *xfer)</td></tr>
<tr class="memdesc:ga35cae3a5b4aa50ce8db28e3eb703a027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a master polling transfer on the I2C bus.  <a href="#ga35cae3a5b4aa50ce8db28e3eb703a027">More...</a><br /></td></tr>
<tr class="separator:ga35cae3a5b4aa50ce8db28e3eb703a027"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Transactional</h2></td></tr>
<tr class="memitem:ga31e3de02b57801c6896e6045c4a31268"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga31e3de02b57801c6896e6045c4a31268">I2C_MasterTransferCreateHandle</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *handle, <a class="el" href="group__i2c__driver.html#gafa39d30cd808d79b774361874f227204">i2c_master_transfer_callback_t</a> callback, void *userData)</td></tr>
<tr class="memdesc:ga31e3de02b57801c6896e6045c4a31268"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the I2C handle which is used in transactional functions.  <a href="#ga31e3de02b57801c6896e6045c4a31268">More...</a><br /></td></tr>
<tr class="separator:ga31e3de02b57801c6896e6045c4a31268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f76a04b6f6873c52ad176d58901fe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gac7f76a04b6f6873c52ad176d58901fe9">I2C_MasterTransferNonBlocking</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *handle, <a class="el" href="group__i2c__driver.html#ga0e25c3c153992361c8d359a86b70d3c6">i2c_master_transfer_t</a> *xfer)</td></tr>
<tr class="memdesc:gac7f76a04b6f6873c52ad176d58901fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a master interrupt non-blocking transfer on the I2C bus.  <a href="#gac7f76a04b6f6873c52ad176d58901fe9">More...</a><br /></td></tr>
<tr class="separator:gac7f76a04b6f6873c52ad176d58901fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d720842e68161d2d52d56d119f20665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga7d720842e68161d2d52d56d119f20665">I2C_MasterTransferGetCount</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *handle, size_t *count)</td></tr>
<tr class="memdesc:ga7d720842e68161d2d52d56d119f20665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the master transfer status during a interrupt non-blocking transfer.  <a href="#ga7d720842e68161d2d52d56d119f20665">More...</a><br /></td></tr>
<tr class="separator:ga7d720842e68161d2d52d56d119f20665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb386e53b2bc64e29b2915bdfac36800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gabb386e53b2bc64e29b2915bdfac36800">I2C_MasterTransferAbort</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *handle)</td></tr>
<tr class="memdesc:gabb386e53b2bc64e29b2915bdfac36800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts an interrupt non-blocking transfer early.  <a href="#gabb386e53b2bc64e29b2915bdfac36800">More...</a><br /></td></tr>
<tr class="separator:gabb386e53b2bc64e29b2915bdfac36800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad091cd1857d2bd8ce64583739b3a35d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gad091cd1857d2bd8ce64583739b3a35d5">I2C_MasterTransferHandleIRQ</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, void *i2cHandle)</td></tr>
<tr class="memdesc:gad091cd1857d2bd8ce64583739b3a35d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Master interrupt handler.  <a href="#gad091cd1857d2bd8ce64583739b3a35d5">More...</a><br /></td></tr>
<tr class="separator:gad091cd1857d2bd8ce64583739b3a35d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9b90f575d92ff8ad3cc350a5c8ad1b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gac9b90f575d92ff8ad3cc350a5c8ad1b9">I2C_SlaveTransferCreateHandle</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *handle, <a class="el" href="group__i2c__driver.html#ga2583e3d8ebf8d3de410d8b6263238c35">i2c_slave_transfer_callback_t</a> callback, void *userData)</td></tr>
<tr class="memdesc:gac9b90f575d92ff8ad3cc350a5c8ad1b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the I2C handle which is used in transactional functions.  <a href="#gac9b90f575d92ff8ad3cc350a5c8ad1b9">More...</a><br /></td></tr>
<tr class="separator:gac9b90f575d92ff8ad3cc350a5c8ad1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa387d81ea08a9d4b39cfeb3dfec505f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gaa387d81ea08a9d4b39cfeb3dfec505f7">I2C_SlaveTransferNonBlocking</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *handle, uint32_t eventMask)</td></tr>
<tr class="memdesc:gaa387d81ea08a9d4b39cfeb3dfec505f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts accepting slave transfers.  <a href="#gaa387d81ea08a9d4b39cfeb3dfec505f7">More...</a><br /></td></tr>
<tr class="separator:gaa387d81ea08a9d4b39cfeb3dfec505f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ae9f5e6e854d14d33ba3029128bd6f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga5ae9f5e6e854d14d33ba3029128bd6f0">I2C_SlaveTransferAbort</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *handle)</td></tr>
<tr class="memdesc:ga5ae9f5e6e854d14d33ba3029128bd6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the slave transfer.  <a href="#ga5ae9f5e6e854d14d33ba3029128bd6f0">More...</a><br /></td></tr>
<tr class="separator:ga5ae9f5e6e854d14d33ba3029128bd6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf38a498bd3527ea0b7cc947ae71e17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#gabf38a498bd3527ea0b7cc947ae71e17e">I2C_SlaveTransferGetCount</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, <a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *handle, size_t *count)</td></tr>
<tr class="memdesc:gabf38a498bd3527ea0b7cc947ae71e17e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the slave transfer remaining bytes during a interrupt non-blocking transfer.  <a href="#gabf38a498bd3527ea0b7cc947ae71e17e">More...</a><br /></td></tr>
<tr class="separator:gabf38a498bd3527ea0b7cc947ae71e17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097c0b20503381de44cccba311dcf236"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__i2c__driver.html#ga097c0b20503381de44cccba311dcf236">I2C_SlaveTransferHandleIRQ</a> (<a class="el" href="struct_i2_c___type.html">I2C_Type</a> *base, void *i2cHandle)</td></tr>
<tr class="memdesc:ga097c0b20503381de44cccba311dcf236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slave interrupt handler.  <a href="#ga097c0b20503381de44cccba311dcf236">More...</a><br /></td></tr>
<tr class="separator:ga097c0b20503381de44cccba311dcf236"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga95f120f6a73af41648364538cf9a6eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95f120f6a73af41648364538cf9a6eca">&#9670;&nbsp;</a></span>i2c_slave_transfer_event_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group__i2c__driver.html#ga87e42e170b60f17f657ef3c06a918133">_i2c_slave_transfer_event</a>  <a class="el" href="group__i2c__driver.html#ga95f120f6a73af41648364538cf9a6eca">i2c_slave_transfer_event_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of events sent to the callback for nonblocking slave transfers. </p>
<p>These event enumerations are used for two related purposes. First, a bit mask created by OR'ing together events is passed to <a class="el" href="group__i2c__driver.html#gaa387d81ea08a9d4b39cfeb3dfec505f7" title="Starts accepting slave transfers.">I2C_SlaveTransferNonBlocking()</a> to specify which events to enable. Then, when the slave callback is invoked, it is passed the current event through its <em>transfer</em> parameter.</p>
<dl class="section note"><dt>Note</dt><dd>These enumerations are meant to be OR'd together to form a bit mask of events. </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga1625497320644ba123718bafdd2c1f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1625497320644ba123718bafdd2c1f39">&#9670;&nbsp;</a></span>_i2c_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c__driver.html#ga1625497320644ba123718bafdd2c1f39">_i2c_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The direction of master and slave transfers. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1625497320644ba123718bafdd2c1f39a93b476b469c2a4bfed5916b458ae9bb0"></a>kI2C_Write&#160;</td><td class="fielddoc"><p>Master transmits to the slave. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1625497320644ba123718bafdd2c1f39a3a7bb24dc8d1c1be8925603eeafe9b30"></a>kI2C_Read&#160;</td><td class="fielddoc"><p>Master receives from the slave. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1f1337bbe9d0b184d9dcee31f9ebade2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1337bbe9d0b184d9dcee31f9ebade2">&#9670;&nbsp;</a></span>_i2c_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c__driver.html#ga1f1337bbe9d0b184d9dcee31f9ebade2">_i2c_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C peripheral flags. </p>
<p>The following status register flags can be cleared:</p><ul>
<li><a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a39fab5ef04e74d00ef4c4574899ab589">kI2C_ArbitrationLostFlag</a></li>
<li><a class="el" href="group__i2c__driver.html#gga1f1337bbe9d0b184d9dcee31f9ebade2a647d0b1d1f9514ad483bef3ea3926c3b">kI2C_IntPendingFlag</a></li>
<li>#kI2C_StartDetectFlag</li>
<li>#kI2C_StopDetectFlag</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>These enumerations are meant to be OR'd together to form a bit mask. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2a4c3c2928e17ddbfbc1c346c6b9a8dccd"></a>kI2C_ReceiveNakFlag&#160;</td><td class="fielddoc"><p>I2C receive NAK flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2a647d0b1d1f9514ad483bef3ea3926c3b"></a>kI2C_IntPendingFlag&#160;</td><td class="fielddoc"><p>I2C interrupt pending flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2a249f698970909f33b1b96139c05bd969"></a>kI2C_TransferDirectionFlag&#160;</td><td class="fielddoc"><p>I2C transfer direction flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2aac2c3a26d38c01fba1554eddc0c6b8b5"></a>kI2C_RangeAddressMatchFlag&#160;</td><td class="fielddoc"><p>I2C range address match flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2a39fab5ef04e74d00ef4c4574899ab589"></a>kI2C_ArbitrationLostFlag&#160;</td><td class="fielddoc"><p>I2C arbitration lost flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2a37fb20742a15a63c1bc2551b997cdcff"></a>kI2C_BusBusyFlag&#160;</td><td class="fielddoc"><p>I2C bus busy flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2a10cd5797b1b8f809192423486a85d5fe"></a>kI2C_AddressMatchFlag&#160;</td><td class="fielddoc"><p>I2C address match flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1f1337bbe9d0b184d9dcee31f9ebade2adb8f10365dfc2a3e849f05173fa4d83e"></a>kI2C_TransferCompleteFlag&#160;</td><td class="fielddoc"><p>I2C transfer complete flag. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga87c81dd985dad07dc26cb93125a94ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87c81dd985dad07dc26cb93125a94ec7">&#9670;&nbsp;</a></span>_i2c_interrupt_enable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c__driver.html#ga87c81dd985dad07dc26cb93125a94ec7">_i2c_interrupt_enable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C feature interrupt source. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga87c81dd985dad07dc26cb93125a94ec7a5526e27ef6e8317ba928849da890b3b2"></a>kI2C_GlobalInterruptEnable&#160;</td><td class="fielddoc"><p>I2C global interrupt. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga87ea07668194cfb46c7c368d2cb42433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87ea07668194cfb46c7c368d2cb42433">&#9670;&nbsp;</a></span>_i2c_master_transfer_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c__driver.html#ga87ea07668194cfb46c7c368d2cb42433">_i2c_master_transfer_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C transfer control flag. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga87ea07668194cfb46c7c368d2cb42433ae80f7b768b1621e42ac965d3d23de5e2"></a>kI2C_TransferDefaultFlag&#160;</td><td class="fielddoc"><p>A transfer starts with a start signal, stops with a stop signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ea07668194cfb46c7c368d2cb42433a5cb44bf860c0482c0ca0165cf0d31d8a"></a>kI2C_TransferNoStartFlag&#160;</td><td class="fielddoc"><p>A transfer starts without a start signal, only support write only or write+read with no start flag, do not support read only with no start flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ea07668194cfb46c7c368d2cb42433aadf112471ef12f194985a093cd9b9721"></a>kI2C_TransferRepeatedStartFlag&#160;</td><td class="fielddoc"><p>A transfer starts with a repeated start signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87ea07668194cfb46c7c368d2cb42433afb8aeea71b5b7475e3d3df86220db566"></a>kI2C_TransferNoStopFlag&#160;</td><td class="fielddoc"><p>A transfer ends without a stop signal. </p>
</td></tr>
</table>

</div>
</div>
<a id="gae1e1e45d8491652a249bf48530911ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1e1e45d8491652a249bf48530911ac7">&#9670;&nbsp;</a></span>_i2c_slave_address_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c__driver.html#gae1e1e45d8491652a249bf48530911ac7">_i2c_slave_address_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Addressing mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae1e1e45d8491652a249bf48530911ac7a3e2c7f1f917939d0d7595224e3700dd4"></a>kI2C_Address7bit&#160;</td><td class="fielddoc"><p>7-bit addressing mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae1e1e45d8491652a249bf48530911ac7aa2c312f87691c542c466ff747d21f70a"></a>kI2C_RangeMatch&#160;</td><td class="fielddoc"><p>Range address match addressing mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga87e42e170b60f17f657ef3c06a918133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e42e170b60f17f657ef3c06a918133">&#9670;&nbsp;</a></span>_i2c_slave_transfer_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c__driver.html#ga87e42e170b60f17f657ef3c06a918133">_i2c_slave_transfer_event</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set of events sent to the callback for nonblocking slave transfers. </p>
<p>These event enumerations are used for two related purposes. First, a bit mask created by OR'ing together events is passed to <a class="el" href="group__i2c__driver.html#gaa387d81ea08a9d4b39cfeb3dfec505f7" title="Starts accepting slave transfers.">I2C_SlaveTransferNonBlocking()</a> to specify which events to enable. Then, when the slave callback is invoked, it is passed the current event through its <em>transfer</em> parameter.</p>
<dl class="section note"><dt>Note</dt><dd>These enumerations are meant to be OR'd together to form a bit mask of events. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga87e42e170b60f17f657ef3c06a918133acb1ae174dd6798a6fd79800a9e39a3c6"></a>kI2C_SlaveAddressMatchEvent&#160;</td><td class="fielddoc"><p>Received the slave address after a start or repeated start. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87e42e170b60f17f657ef3c06a918133a2f85039a57379838909876a1d509b7aa"></a>kI2C_SlaveTransmitEvent&#160;</td><td class="fielddoc"><p>A callback is requested to provide data to transmit (slave-transmitter role). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87e42e170b60f17f657ef3c06a918133aac8593e808a8137d1b5d3a51640779de"></a>kI2C_SlaveReceiveEvent&#160;</td><td class="fielddoc"><p>A callback is requested to provide a buffer in which to place received data (slave-receiver role). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87e42e170b60f17f657ef3c06a918133a43c045da27fa60e7a0540c743eca4e79"></a>kI2C_SlaveTransmitAckEvent&#160;</td><td class="fielddoc"><p>A callback needs to either transmit an ACK or NACK. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87e42e170b60f17f657ef3c06a918133a38cca3cd668e73f51b8e574835d419df"></a>kI2C_SlaveCompletionEvent&#160;</td><td class="fielddoc"><p>A stop was detected or finished transfer, completing the transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87e42e170b60f17f657ef3c06a918133a5063c09cccc4d8047aa3d33ff979657b"></a>kI2C_SlaveGenaralcallEvent&#160;</td><td class="fielddoc"><p>Received the general call address after a start or repeated start. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga87e42e170b60f17f657ef3c06a918133a94b030ebdac378a84961893ae567bfbc"></a>kI2C_SlaveAllEvents&#160;</td><td class="fielddoc"><p>A bit mask of all available events. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga7cc91c89125c25a88e463a9e8550b284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cc91c89125c25a88e463a9e8550b284">&#9670;&nbsp;</a></span>_i2c_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__i2c__driver.html#ga7cc91c89125c25a88e463a9e8550b284">_i2c_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I2C status return codes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7cc91c89125c25a88e463a9e8550b284a49091894b590d7e479605bf113918952"></a>kStatus_I2C_Busy&#160;</td><td class="fielddoc"><p>I2C is busy with current transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7cc91c89125c25a88e463a9e8550b284a628d242f7bc0e3d5949c7f73eafaa508"></a>kStatus_I2C_Idle&#160;</td><td class="fielddoc"><p>Bus is Idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7cc91c89125c25a88e463a9e8550b284a72fd33d0b5263a63766e62f71d16be00"></a>kStatus_I2C_Nak&#160;</td><td class="fielddoc"><p>NAK received during transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7cc91c89125c25a88e463a9e8550b284a139b52cc3305ec2c06d0ac94313c221f"></a>kStatus_I2C_ArbitrationLost&#160;</td><td class="fielddoc"><p>Arbitration lost during transfer. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7cc91c89125c25a88e463a9e8550b284a81ad7cc198436cabbe91ea55c5288747"></a>kStatus_I2C_Timeout&#160;</td><td class="fielddoc"><p>Timeout poling status flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7cc91c89125c25a88e463a9e8550b284adf7437bfedcc0d57338ed33f1be5c805"></a>kStatus_I2C_Addr_Nak&#160;</td><td class="fielddoc"><p>NAK received during the address probe. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9839c1fd49a0f62f42b0adfa74f62853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9839c1fd49a0f62f42b0adfa74f62853">&#9670;&nbsp;</a></span>I2C_DisableInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_DisableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables I2C interrupt requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer </td></tr>
    <tr><td class="paramname">mask</td><td>interrupt source The parameter can be combination of the following source if defined: <ul>
<li>kI2C_GlobalInterruptEnable </li>
<li>kI2C_StopDetectInterruptEnable/kI2C_StartDetectInterruptEnable </li>
<li>kI2C_SdaTimeoutInterruptEnable</li>
</ul>
brief Disables I2C interrupt requests.</td></tr>
  </table>
  </dd>
</dl>
<p>param base I2C base pointer param mask interrupt source The parameter can be combination of the following source if defined: arg kI2C_GlobalInterruptEnable arg kI2C_StopDetectInterruptEnable/kI2C_StartDetectInterruptEnable arg kI2C_SdaTimeoutInterruptEnable </p>

</div>
</div>
<a id="ga577e094cc4d39b88ec5bbe49bc199c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga577e094cc4d39b88ec5bbe49bc199c77">&#9670;&nbsp;</a></span>I2C_EnableInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_EnableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables I2C interrupt requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer </td></tr>
    <tr><td class="paramname">mask</td><td>interrupt source The parameter can be combination of the following source if defined: <ul>
<li>kI2C_GlobalInterruptEnable </li>
<li>kI2C_StopDetectInterruptEnable/kI2C_StartDetectInterruptEnable </li>
<li>kI2C_SdaTimeoutInterruptEnable</li>
</ul>
brief Enables I2C interrupt requests.</td></tr>
  </table>
  </dd>
</dl>
<p>param base I2C base pointer param mask interrupt source The parameter can be combination of the following source if defined: arg kI2C_GlobalInterruptEnable arg kI2C_StopDetectInterruptEnable/kI2C_StartDetectInterruptEnable arg kI2C_SdaTimeoutInterruptEnable </p>

</div>
</div>
<a id="ga07cc6bd20f700249c335893427bf462a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07cc6bd20f700249c335893427bf462a">&#9670;&nbsp;</a></span>I2C_GetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_GetInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get instance number for I2C module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C peripheral base address.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Get instance number for I2C module.</p>
<p>param base I2C peripheral base address. </p>

</div>
</div>
<a id="gadcf7122f0a38d4d9da0f052fcb167957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf7122f0a38d4d9da0f052fcb167957">&#9670;&nbsp;</a></span>I2C_MasterDeinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MasterDeinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the I2C master peripheral. Call this API to gate the I2C clock. The I2C master module can't work unless the I2C_MasterInit is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer</td></tr>
  </table>
  </dd>
</dl>
<p>brief De-initializes the I2C master peripheral. Call this API to gate the I2C clock. The I2C master module can't work unless the I2C_MasterInit is called. param base I2C base pointer </p>

</div>
</div>
<a id="gad69f2d63ea756dda60749ff6b09f587d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad69f2d63ea756dda60749ff6b09f587d">&#9670;&nbsp;</a></span>I2C_MasterGetDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MasterGetDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#gad739710b6b65e12ca5ba9dc2a2a2b463">i2c_master_config_t</a> *&#160;</td>
          <td class="paramname"><em>masterConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the I2C master configuration structure to default values. </p>
<p>The purpose of this API is to get the configuration structure initialized for use in the I2C_MasterConfigure(). Use the initialized structure unchanged in the I2C_MasterConfigure() or modify the structure before calling the I2C_MasterConfigure(). This is an example. </p><div class="fragment"><div class="line"><a class="code" href="struct__i2c__master__config.html">i2c_master_config_t</a> config;</div><div class="line"><a class="code" href="group__i2c__driver.html#gad69f2d63ea756dda60749ff6b09f587d">I2C_MasterGetDefaultConfig</a>(&amp;config);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">masterConfig</td><td>A pointer to the master configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sets the I2C master configuration structure to default values.</p>
<p>The purpose of this API is to get the configuration structure initialized for use in the I2C_MasterConfigure(). Use the initialized structure unchanged in the I2C_MasterConfigure() or modify the structure before calling the I2C_MasterConfigure(). This is an example. code i2c_master_config_t config; I2C_MasterGetDefaultConfig(&amp;config); endcode param masterConfig A pointer to the master configuration structure. </p>

</div>
</div>
<a id="ga721e41295dedc83b424e80e53065e625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga721e41295dedc83b424e80e53065e625">&#9670;&nbsp;</a></span>I2C_MasterGetStatusFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t I2C_MasterGetStatusFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the I2C status flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status flag, use status flag to AND <a class="el" href="group__i2c__driver.html#ga1f1337bbe9d0b184d9dcee31f9ebade2" title="I2C peripheral flags.">_i2c_flags</a> to get the related status.</dd></dl>
<p>brief Gets the I2C status flags.</p>
<p>param base I2C base pointer return status flag, use status flag to AND <a class="el" href="group__i2c__driver.html#ga1f1337bbe9d0b184d9dcee31f9ebade2" title="I2C peripheral flags.">_i2c_flags</a> to get the related status. </p>

</div>
</div>
<a id="ga29f967b3ae8487a36ba2a58deb01ccae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29f967b3ae8487a36ba2a58deb01ccae">&#9670;&nbsp;</a></span>I2C_MasterInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MasterInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__i2c__driver.html#gad739710b6b65e12ca5ba9dc2a2a2b463">i2c_master_config_t</a> *&#160;</td>
          <td class="paramname"><em>masterConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcClock_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the I2C peripheral. Call this API to ungate the I2C clock and configure the I2C with master configuration. </p>
<dl class="section note"><dt>Note</dt><dd>This API should be called at the beginning of the application. Otherwise, any operation to the I2C module can cause a hard fault because the clock is not enabled. The configuration structure can be custom filled or it can be set with default values by using the <a class="el" href="group__i2c__driver.html#gad69f2d63ea756dda60749ff6b09f587d" title="Sets the I2C master configuration structure to default values.">I2C_MasterGetDefaultConfig()</a>. After calling this API, the master is ready to transfer. This is an example. <div class="fragment"><div class="line"><a class="code" href="struct__i2c__master__config.html">i2c_master_config_t</a> config = {</div><div class="line">.<a class="code" href="struct__i2c__master__config.html#ab8b96ba3ced8b280ac1f366f6e76a9e7">enableMaster</a> = <span class="keyword">true</span>,</div><div class="line">.enableStopHold = <span class="keyword">false</span>,</div><div class="line">.highDrive = <span class="keyword">false</span>,</div><div class="line">.baudRate_Bps = 100000,</div><div class="line">.glitchFilterWidth = 0</div><div class="line">};</div><div class="line"><a class="code" href="group__i2c__driver.html#ga29f967b3ae8487a36ba2a58deb01ccae">I2C_MasterInit</a>(<a class="code" href="group___i2_c___peripheral___access___layer.html#ga86abb2e8858d177c04e60c41e9242045">I2C0</a>, &amp;config, 12000000U);</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer </td></tr>
    <tr><td class="paramname">masterConfig</td><td>A pointer to the master configuration structure </td></tr>
    <tr><td class="paramname">srcClock_Hz</td><td>I2C peripheral clock frequency in Hz</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes the I2C peripheral. Call this API to ungate the I2C clock and configure the I2C with master configuration.</p>
<p>note This API should be called at the beginning of the application. Otherwise, any operation to the I2C module can cause a hard fault because the clock is not enabled. The configuration structure can be custom filled or it can be set with default values by using the <a class="el" href="group__i2c__driver.html#gad69f2d63ea756dda60749ff6b09f587d" title="Sets the I2C master configuration structure to default values.">I2C_MasterGetDefaultConfig()</a>. After calling this API, the master is ready to transfer. This is an example. code i2c_master_config_t config = { .enableMaster = true, .enableStopHold = false, .highDrive = false, .baudRate_Bps = 100000, .glitchFilterWidth = 0 }; I2C_MasterInit(I2C0, &amp;config, 12000000U); endcode</p>
<p>param base I2C base pointer param masterConfig A pointer to the master configuration structure param srcClock_Hz I2C peripheral clock frequency in Hz </p>

</div>
</div>
<a id="gaf77526f32a16109abf265dbb022a26ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf77526f32a16109abf265dbb022a26ba">&#9670;&nbsp;</a></span>I2C_MasterReadBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterReadBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a polling receive transaction on the I2C bus. </p>
<dl class="section note"><dt>Note</dt><dd>The I2C_MasterReadBlocking function stops the bus before reading the final byte. Without stopping the bus prior for the final read, the bus issues another read, resulting in garbage data being read into the data register.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C peripheral base pointer. </td></tr>
    <tr><td class="paramname">rxBuff</td><td>The pointer to the data to store the received data. </td></tr>
    <tr><td class="paramname">rxSize</td><td>The length in bytes of the data to be received. </td></tr>
    <tr><td class="paramname">flags</td><td>Transfer control flag to decide whether need to send a stop, use kI2C_TransferDefaultFlag to issue a stop and kI2C_TransferNoStop to not send a stop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully complete the data transmission. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Timeout</td><td>Send stop signal failed, timeout.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Performs a polling receive transaction on the I2C bus.</p>
<p>note The I2C_MasterReadBlocking function stops the bus before reading the final byte. Without stopping the bus prior for the final read, the bus issues another read, resulting in garbage data being read into the data register.</p>
<p>param base I2C peripheral base pointer. param rxBuff The pointer to the data to store the received data. param rxSize The length in bytes of the data to be received. param flags Transfer control flag to decide whether need to send a stop, use kI2C_TransferDefaultFlag to issue a stop and kI2C_TransferNoStop to not send a stop. retval kStatus_Success Successfully complete the data transmission. retval kStatus_I2C_Timeout Send stop signal failed, timeout. </p>

</div>
</div>
<a id="ga42ff265d25e713326c7d152adf350147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42ff265d25e713326c7d152adf350147">&#9670;&nbsp;</a></span>I2C_MasterRepeatedStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterRepeatedStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga4bf954d998f086594eece268c780bec7">i2c_direction_t</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a REPEATED START on the I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C peripheral base pointer </td></tr>
    <tr><td class="paramname">address</td><td>7-bit slave device address. </td></tr>
    <tr><td class="paramname">direction</td><td>Master transfer directions(transmit/receive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully send the start signal. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Busy</td><td>Current bus is busy but not occupied by current I2C master.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sends a REPEATED START on the I2C bus.</p>
<p>param base I2C peripheral base pointer param address 7-bit slave device address. param direction Master transfer directions(transmit/receive). retval kStatus_Success Successfully send the start signal. retval kStatus_I2C_Busy Current bus is busy but not occupied by current I2C master. </p>

</div>
</div>
<a id="gafeab1d5249a8b39c8d9e1a54a85c23f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafeab1d5249a8b39c8d9e1a54a85c23f0">&#9670;&nbsp;</a></span>I2C_MasterSetBaudRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MasterSetBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudRate_Bps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcClock_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the I2C master transfer baud rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer </td></tr>
    <tr><td class="paramname">baudRate_Bps</td><td>the baud rate value in bps </td></tr>
    <tr><td class="paramname">srcClock_Hz</td><td>Source clock</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sets the I2C master transfer baud rate.</p>
<p>param base I2C base pointer param baudRate_Bps the baud rate value in bps param srcClock_Hz Source clock </p>

</div>
</div>
<a id="ga7664234966e4162e952b6d57efcaa8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7664234966e4162e952b6d57efcaa8a6">&#9670;&nbsp;</a></span>I2C_MasterStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga4bf954d998f086594eece268c780bec7">i2c_direction_t</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a START on the I2C bus. </p>
<p>This function is used to initiate a new master mode transfer by sending the START signal. The slave address is sent following the I2C START signal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C peripheral base pointer </td></tr>
    <tr><td class="paramname">address</td><td>7-bit slave device address. </td></tr>
    <tr><td class="paramname">direction</td><td>Master transfer directions(transmit/receive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully send the start signal. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Busy</td><td>Current bus is busy.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sends a START on the I2C bus.</p>
<p>This function is used to initiate a new master mode transfer by sending the START signal. The slave address is sent following the I2C START signal.</p>
<p>param base I2C peripheral base pointer param address 7-bit slave device address. param direction Master transfer directions(transmit/receive). retval kStatus_Success Successfully send the start signal. retval kStatus_I2C_Busy Current bus is busy. </p>

</div>
</div>
<a id="gaf46a8cc094fc18c6cadea8de71448723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf46a8cc094fc18c6cadea8de71448723">&#9670;&nbsp;</a></span>I2C_MasterStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterStop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a STOP signal on the I2C bus. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully send the stop signal. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Timeout</td><td>Send stop signal failed, timeout.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sends a STOP signal on the I2C bus.</p>
<p>retval kStatus_Success Successfully send the stop signal. retval kStatus_I2C_Timeout Send stop signal failed, timeout. </p>

</div>
</div>
<a id="gabb386e53b2bc64e29b2915bdfac36800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb386e53b2bc64e29b2915bdfac36800">&#9670;&nbsp;</a></span>I2C_MasterTransferAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterTransferAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts an interrupt non-blocking transfer early. </p>
<dl class="section note"><dt>Note</dt><dd>This API can be called at any time when an interrupt non-blocking transfer initiates to abort the transfer early.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to i2c_master_handle_t structure which stores the transfer state </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_I2C_Timeout</td><td>Timeout during polling flag. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Successfully abort the transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts an interrupt non-blocking transfer early.</p>
<p>note This API can be called at any time when an interrupt non-blocking transfer initiates to abort the transfer early.</p>
<p>param base I2C base pointer. param handle pointer to i2c_master_handle_t structure which stores the transfer state retval kStatus_I2C_Timeout Timeout during polling flag. retval kStatus_Success Successfully abort the transfer. </p>

</div>
</div>
<a id="ga35cae3a5b4aa50ce8db28e3eb703a027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35cae3a5b4aa50ce8db28e3eb703a027">&#9670;&nbsp;</a></span>I2C_MasterTransferBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterTransferBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga0e25c3c153992361c8d359a86b70d3c6">i2c_master_transfer_t</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a master polling transfer on the I2C bus. </p>
<dl class="section note"><dt>Note</dt><dd>The API does not return until the transfer succeeds or fails due to arbitration lost or receiving a NAK.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C peripheral base address. </td></tr>
    <tr><td class="paramname">xfer</td><td>Pointer to the transfer structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully complete the data transmission. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Busy</td><td>Previous transmission still not finished. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Timeout</td><td>Transfer error, wait signal timeout. </td></tr>
    <tr><td class="paramname">kStatus_I2C_ArbitrationLost</td><td>Transfer error, arbitration lost. </td></tr>
    <tr><td class="paramname">kStataus_I2C_Nak</td><td>Transfer error, receive NAK during transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Performs a master polling transfer on the I2C bus.</p>
<p>note The API does not return until the transfer succeeds or fails due to arbitration lost or receiving a NAK.</p>
<p>param base I2C peripheral base address. param xfer Pointer to the transfer structure. retval kStatus_Success Successfully complete the data transmission. retval kStatus_I2C_Busy Previous transmission still not finished. retval kStatus_I2C_Timeout Transfer error, wait signal timeout. retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost. retval kStataus_I2C_Nak Transfer error, receive NAK during transfer. </p>

</div>
</div>
<a id="ga31e3de02b57801c6896e6045c4a31268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31e3de02b57801c6896e6045c4a31268">&#9670;&nbsp;</a></span>I2C_MasterTransferCreateHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MasterTransferCreateHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#gafa39d30cd808d79b774361874f227204">i2c_master_transfer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the I2C handle which is used in transactional functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to i2c_master_handle_t structure to store the transfer state. </td></tr>
    <tr><td class="paramname">callback</td><td>pointer to user callback function. </td></tr>
    <tr><td class="paramname">userData</td><td>user parameter passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes the I2C handle which is used in transactional functions.</p>
<p>param base I2C base pointer. param handle pointer to i2c_master_handle_t structure to store the transfer state. param callback pointer to user callback function. param userData user parameter passed to the callback function. </p>

</div>
</div>
<a id="ga7d720842e68161d2d52d56d119f20665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d720842e68161d2d52d56d119f20665">&#9670;&nbsp;</a></span>I2C_MasterTransferGetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterTransferGetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the master transfer status during a interrupt non-blocking transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to i2c_master_handle_t structure which stores the transfer state. </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes transferred so far by the non-blocking transaction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>count is Invalid. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Successfully return the count.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the master transfer status during a interrupt non-blocking transfer.</p>
<p>param base I2C base pointer. param handle pointer to i2c_master_handle_t structure which stores the transfer state. param count Number of bytes transferred so far by the non-blocking transaction. retval kStatus_InvalidArgument count is Invalid. retval kStatus_Success Successfully return the count. </p>

</div>
</div>
<a id="gad091cd1857d2bd8ce64583739b3a35d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad091cd1857d2bd8ce64583739b3a35d5">&#9670;&nbsp;</a></span>I2C_MasterTransferHandleIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_MasterTransferHandleIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i2cHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Master interrupt handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">i2cHandle</td><td>pointer to i2c_master_handle_t structure.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Master interrupt handler.</p>
<p>param base I2C base pointer. param i2cHandle pointer to i2c_master_handle_t structure. </p>

</div>
</div>
<a id="gac7f76a04b6f6873c52ad176d58901fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f76a04b6f6873c52ad176d58901fe9">&#9670;&nbsp;</a></span>I2C_MasterTransferNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterTransferNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga2fd51f58b8cfd309be985bce4b817fdc">i2c_master_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga0e25c3c153992361c8d359a86b70d3c6">i2c_master_transfer_t</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a master interrupt non-blocking transfer on the I2C bus. </p>
<dl class="section note"><dt>Note</dt><dd>Calling the API returns immediately after transfer initiates. The user needs to call I2C_MasterGetTransferCount to poll the transfer status to check whether the transfer is finished. If the return status is not kStatus_I2C_Busy, the transfer is finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to i2c_master_handle_t structure which stores the transfer state. </td></tr>
    <tr><td class="paramname">xfer</td><td>pointer to i2c_master_transfer_t structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully start the data transmission. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Busy</td><td>Previous transmission still not finished. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Timeout</td><td>Transfer error, wait signal timeout.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Performs a master interrupt non-blocking transfer on the I2C bus.</p>
<p>note Calling the API returns immediately after transfer initiates. The user needs to call I2C_MasterGetTransferCount to poll the transfer status to check whether the transfer is finished. If the return status is not kStatus_I2C_Busy, the transfer is finished.</p>
<p>param base I2C base pointer. param handle pointer to i2c_master_handle_t structure which stores the transfer state. param xfer pointer to i2c_master_transfer_t structure. retval kStatus_Success Successfully start the data transmission. retval kStatus_I2C_Busy Previous transmission still not finished. retval kStatus_I2C_Timeout Transfer error, wait signal timeout. </p>

</div>
</div>
<a id="gac4e1a954243aa852cb4d358e90091efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4e1a954243aa852cb4d358e90091efd">&#9670;&nbsp;</a></span>I2C_MasterWriteBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_MasterWriteBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>txSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a polling send transaction on the I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The I2C peripheral base pointer. </td></tr>
    <tr><td class="paramname">txBuff</td><td>The pointer to the data to be transferred. </td></tr>
    <tr><td class="paramname">txSize</td><td>The length in bytes of the data to be transferred. </td></tr>
    <tr><td class="paramname">flags</td><td>Transfer control flag to decide whether need to send a stop, use kI2C_TransferDefaultFlag to issue a stop and kI2C_TransferNoStop to not send a stop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully complete the data transmission. </td></tr>
    <tr><td class="paramname">kStatus_I2C_ArbitrationLost</td><td>Transfer error, arbitration lost. </td></tr>
    <tr><td class="paramname">kStataus_I2C_Nak</td><td>Transfer error, receive NAK during transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Performs a polling send transaction on the I2C bus.</p>
<p>param base The I2C peripheral base pointer. param txBuff The pointer to the data to be transferred. param txSize The length in bytes of the data to be transferred. param flags Transfer control flag to decide whether need to send a stop, use kI2C_TransferDefaultFlag to issue a stop and kI2C_TransferNoStop to not send a stop. retval kStatus_Success Successfully complete the data transmission. retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost. retval kStataus_I2C_Nak Transfer error, receive NAK during transfer. </p>

</div>
</div>
<a id="gadb50014db29dd75ea2001fb7bc837e77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb50014db29dd75ea2001fb7bc837e77">&#9670;&nbsp;</a></span>I2C_SlaveDeinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SlaveDeinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the I2C slave peripheral. Calling this API gates the I2C clock. The I2C slave module can't work unless the I2C_SlaveInit is called to enable the clock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer</td></tr>
  </table>
  </dd>
</dl>
<p>brief De-initializes the I2C slave peripheral. Calling this API gates the I2C clock. The I2C slave module can't work unless the I2C_SlaveInit is called to enable the clock. param base I2C base pointer </p>

</div>
</div>
<a id="ga7115f80e28b62bbbd3be1a2a918529ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7115f80e28b62bbbd3be1a2a918529ba">&#9670;&nbsp;</a></span>I2C_SlaveGetDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SlaveGetDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#gaa70dd0ec9815617269569190efd2de5d">i2c_slave_config_t</a> *&#160;</td>
          <td class="paramname"><em>slaveConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the I2C slave configuration structure to default values. </p>
<p>The purpose of this API is to get the configuration structure initialized for use in the I2C_SlaveConfigure(). Modify fields of the structure before calling the I2C_SlaveConfigure(). This is an example. </p><div class="fragment"><div class="line"><a class="code" href="struct__i2c__slave__config.html">i2c_slave_config_t</a> config;</div><div class="line"><a class="code" href="group__i2c__driver.html#ga7115f80e28b62bbbd3be1a2a918529ba">I2C_SlaveGetDefaultConfig</a>(&amp;config);</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slaveConfig</td><td>A pointer to the slave configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sets the I2C slave configuration structure to default values.</p>
<p>The purpose of this API is to get the configuration structure initialized for use in the I2C_SlaveConfigure(). Modify fields of the structure before calling the I2C_SlaveConfigure(). This is an example. code i2c_slave_config_t config; I2C_SlaveGetDefaultConfig(&amp;config); endcode param slaveConfig A pointer to the slave configuration structure. </p>

</div>
</div>
<a id="gaf2397a88554ea896f212dd262f9bc731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2397a88554ea896f212dd262f9bc731">&#9670;&nbsp;</a></span>I2C_SlaveInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SlaveInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__i2c__driver.html#gaa70dd0ec9815617269569190efd2de5d">i2c_slave_config_t</a> *&#160;</td>
          <td class="paramname"><em>slaveConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcClock_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the I2C peripheral. Call this API to ungate the I2C clock and initialize the I2C with the slave configuration. </p>
<dl class="section note"><dt>Note</dt><dd>This API should be called at the beginning of the application. Otherwise, any operation to the I2C module can cause a hard fault because the clock is not enabled. The configuration structure can partly be set with default values by <a class="el" href="group__i2c__driver.html#ga7115f80e28b62bbbd3be1a2a918529ba" title="Sets the I2C slave configuration structure to default values.">I2C_SlaveGetDefaultConfig()</a> or it can be custom filled by the user. This is an example. <div class="fragment"><div class="line"><a class="code" href="struct__i2c__slave__config.html">i2c_slave_config_t</a> config = {</div><div class="line">.<a class="code" href="struct__i2c__slave__config.html#a9189d8f6438ba99548837da162213c46">enableSlave</a> = <span class="keyword">true</span>,</div><div class="line">.enableGeneralCall = <span class="keyword">false</span>,</div><div class="line">.addressingMode = <a class="code" href="group__i2c__driver.html#ggae1e1e45d8491652a249bf48530911ac7a3e2c7f1f917939d0d7595224e3700dd4">kI2C_Address7bit</a>,</div><div class="line">.slaveAddress = 0x1DU,</div><div class="line">.enableWakeUp = <span class="keyword">false</span>,</div><div class="line">.enablehighDrive = <span class="keyword">false</span>,</div><div class="line">.enableBaudRateCtl = <span class="keyword">false</span>,</div><div class="line">.sclStopHoldTime_ns = 4000</div><div class="line">};</div><div class="line"><a class="code" href="group__i2c__driver.html#gaf2397a88554ea896f212dd262f9bc731">I2C_SlaveInit</a>(<a class="code" href="group___i2_c___peripheral___access___layer.html#ga86abb2e8858d177c04e60c41e9242045">I2C0</a>, &amp;config, 12000000U);</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer </td></tr>
    <tr><td class="paramname">slaveConfig</td><td>A pointer to the slave configuration structure </td></tr>
    <tr><td class="paramname">srcClock_Hz</td><td>I2C peripheral clock frequency in Hz</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes the I2C peripheral. Call this API to ungate the I2C clock and initialize the I2C with the slave configuration.</p>
<p>note This API should be called at the beginning of the application. Otherwise, any operation to the I2C module can cause a hard fault because the clock is not enabled. The configuration structure can partly be set with default values by <a class="el" href="group__i2c__driver.html#ga7115f80e28b62bbbd3be1a2a918529ba" title="Sets the I2C slave configuration structure to default values.">I2C_SlaveGetDefaultConfig()</a> or it can be custom filled by the user. This is an example. code i2c_slave_config_t config = { .enableSlave = true, .enableGeneralCall = false, .addressingMode = kI2C_Address7bit, .slaveAddress = 0x1DU, .enableWakeUp = false, .enablehighDrive = false, .enableBaudRateCtl = false, .sclStopHoldTime_ns = 4000 }; I2C_SlaveInit(I2C0, &amp;config, 12000000U); endcode</p>
<p>param base I2C base pointer param slaveConfig A pointer to the slave configuration structure param srcClock_Hz I2C peripheral clock frequency in Hz </p>

</div>
</div>
<a id="ga89baaf8bc82b19c837032665e89a1707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89baaf8bc82b19c837032665e89a1707">&#9670;&nbsp;</a></span>I2C_SlaveReadBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_SlaveReadBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rxBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a polling receive transaction on the I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C peripheral base pointer. </td></tr>
    <tr><td class="paramname">rxBuff</td><td>The pointer to the data to store the received data. </td></tr>
    <tr><td class="paramname">rxSize</td><td>The length in bytes of the data to be received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully complete data receive. </td></tr>
    <tr><td class="paramname">kStatus_I2C_Timeout</td><td>Wait status flag timeout.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Performs a polling receive transaction on the I2C bus.</p>
<p>param base I2C peripheral base pointer. param rxBuff The pointer to the data to store the received data. param rxSize The length in bytes of the data to be received. retval kStatus_Success Successfully complete data receive. retval kStatus_I2C_Timeout Wait status flag timeout. </p>

</div>
</div>
<a id="ga5ae9f5e6e854d14d33ba3029128bd6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ae9f5e6e854d14d33ba3029128bd6f0">&#9670;&nbsp;</a></span>I2C_SlaveTransferAbort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SlaveTransferAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the slave transfer. </p>
<dl class="section note"><dt>Note</dt><dd>This API can be called at any time to stop slave for handling the bus events.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to i2c_slave_handle_t structure which stores the transfer state.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts the slave transfer.</p>
<p>note This API can be called at any time to stop slave for handling the bus events.</p>
<p>param base I2C base pointer. param handle pointer to i2c_slave_handle_t structure which stores the transfer state. </p>

</div>
</div>
<a id="gac9b90f575d92ff8ad3cc350a5c8ad1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9b90f575d92ff8ad3cc350a5c8ad1b9">&#9670;&nbsp;</a></span>I2C_SlaveTransferCreateHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SlaveTransferCreateHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga2583e3d8ebf8d3de410d8b6263238c35">i2c_slave_transfer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the I2C handle which is used in transactional functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to i2c_slave_handle_t structure to store the transfer state. </td></tr>
    <tr><td class="paramname">callback</td><td>pointer to user callback function. </td></tr>
    <tr><td class="paramname">userData</td><td>user parameter passed to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes the I2C handle which is used in transactional functions.</p>
<p>param base I2C base pointer. param handle pointer to i2c_slave_handle_t structure to store the transfer state. param callback pointer to user callback function. param userData user parameter passed to the callback function. </p>

</div>
</div>
<a id="gabf38a498bd3527ea0b7cc947ae71e17e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf38a498bd3527ea0b7cc947ae71e17e">&#9670;&nbsp;</a></span>I2C_SlaveTransferGetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_SlaveTransferGetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the slave transfer remaining bytes during a interrupt non-blocking transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">handle</td><td>pointer to i2c_slave_handle_t structure. </td></tr>
    <tr><td class="paramname">count</td><td>Number of bytes transferred so far by the non-blocking transaction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>count is Invalid. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Successfully return the count.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the slave transfer remaining bytes during a interrupt non-blocking transfer.</p>
<p>param base I2C base pointer. param handle pointer to i2c_slave_handle_t structure. param count Number of bytes transferred so far by the non-blocking transaction. retval kStatus_InvalidArgument count is Invalid. retval kStatus_Success Successfully return the count. </p>

</div>
</div>
<a id="ga097c0b20503381de44cccba311dcf236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga097c0b20503381de44cccba311dcf236">&#9670;&nbsp;</a></span>I2C_SlaveTransferHandleIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C_SlaveTransferHandleIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i2cHandle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slave interrupt handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>I2C base pointer. </td></tr>
    <tr><td class="paramname">i2cHandle</td><td>pointer to i2c_slave_handle_t structure which stores the transfer state</td></tr>
  </table>
  </dd>
</dl>
<p>brief Slave interrupt handler.</p>
<p>param base I2C base pointer. param i2cHandle pointer to i2c_slave_handle_t structure which stores the transfer state </p>

</div>
</div>
<a id="gaa387d81ea08a9d4b39cfeb3dfec505f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa387d81ea08a9d4b39cfeb3dfec505f7">&#9670;&nbsp;</a></span>I2C_SlaveTransferNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_SlaveTransferNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752">i2c_slave_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts accepting slave transfers. </p>
<p>Call this API after calling the <a class="el" href="group__i2c__driver.html#gaf2397a88554ea896f212dd262f9bc731" title="Initializes the I2C peripheral. Call this API to ungate the I2C clock and initialize the I2C with the...">I2C_SlaveInit()</a> and <a class="el" href="group__i2c__driver.html#gac9b90f575d92ff8ad3cc350a5c8ad1b9" title="Initializes the I2C handle which is used in transactional functions.">I2C_SlaveTransferCreateHandle()</a> to start processing transactions driven by an I2C master. The slave monitors the I2C bus and passes events to the callback that was passed into the call to <a class="el" href="group__i2c__driver.html#gac9b90f575d92ff8ad3cc350a5c8ad1b9" title="Initializes the I2C handle which is used in transactional functions.">I2C_SlaveTransferCreateHandle()</a>. The callback is always invoked from the interrupt context.</p>
<p>The set of events received by the callback is customizable. To do so, set the <em>eventMask</em> parameter to the OR'd combination of <a class="el" href="group__i2c__driver.html#ga95f120f6a73af41648364538cf9a6eca" title="Set of events sent to the callback for nonblocking slave transfers.">i2c_slave_transfer_event_t</a> enumerators for the events you wish to receive. The <a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a2f85039a57379838909876a1d509b7aa">kI2C_SlaveTransmitEvent</a> and #kLPI2C_SlaveReceiveEvent events are always enabled and do not need to be included in the mask. Alternatively, pass 0 to get a default set of only the transmit and receive events that are always enabled. In addition, the <a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a94b030ebdac378a84961893ae567bfbc">kI2C_SlaveAllEvents</a> constant is provided as a convenient way to enable all events.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The I2C peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>Pointer to <a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752" title="I2C slave handle typedef.">i2c_slave_handle_t</a> structure which stores the transfer state. </td></tr>
    <tr><td class="paramname">eventMask</td><td>Bit mask formed by OR'ing together <a class="el" href="group__i2c__driver.html#ga95f120f6a73af41648364538cf9a6eca" title="Set of events sent to the callback for nonblocking slave transfers.">i2c_slave_transfer_event_t</a> enumerators to specify which events to send to the callback. Other accepted values are 0 to get a default set of only the transmit and receive events, and <a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a94b030ebdac378a84961893ae567bfbc">kI2C_SlaveAllEvents</a> to enable all events.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">#kStatus_Success</td><td>Slave transfers were successfully started. </td></tr>
    <tr><td class="paramname"><a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284a49091894b590d7e479605bf113918952">kStatus_I2C_Busy</a></td><td>Slave transfers have already been started on this handle.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Starts accepting slave transfers.</p>
<p>Call this API after calling the <a class="el" href="group__i2c__driver.html#gaf2397a88554ea896f212dd262f9bc731" title="Initializes the I2C peripheral. Call this API to ungate the I2C clock and initialize the I2C with the...">I2C_SlaveInit()</a> and <a class="el" href="group__i2c__driver.html#gac9b90f575d92ff8ad3cc350a5c8ad1b9" title="Initializes the I2C handle which is used in transactional functions.">I2C_SlaveTransferCreateHandle()</a> to start processing transactions driven by an I2C master. The slave monitors the I2C bus and passes events to the callback that was passed into the call to <a class="el" href="group__i2c__driver.html#gac9b90f575d92ff8ad3cc350a5c8ad1b9" title="Initializes the I2C handle which is used in transactional functions.">I2C_SlaveTransferCreateHandle()</a>. The callback is always invoked from the interrupt context.</p>
<p>The set of events received by the callback is customizable. To do so, set the a eventMask parameter to the OR'd combination of <a class="el" href="group__i2c__driver.html#ga95f120f6a73af41648364538cf9a6eca" title="Set of events sent to the callback for nonblocking slave transfers.">i2c_slave_transfer_event_t</a> enumerators for the events you wish to receive. The <a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a2f85039a57379838909876a1d509b7aa">kI2C_SlaveTransmitEvent</a> and #kLPI2C_SlaveReceiveEvent events are always enabled and do not need to be included in the mask. Alternatively, pass 0 to get a default set of only the transmit and receive events that are always enabled. In addition, the <a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a94b030ebdac378a84961893ae567bfbc">kI2C_SlaveAllEvents</a> constant is provided as a convenient way to enable all events.</p>
<p>param base The I2C peripheral base address. param handle Pointer to <a class="el" href="group__i2c__driver.html#ga394e5278816efe62815de9d25be84752" title="I2C slave handle typedef.">i2c_slave_handle_t</a> structure which stores the transfer state. param eventMask Bit mask formed by OR'ing together <a class="el" href="group__i2c__driver.html#ga95f120f6a73af41648364538cf9a6eca" title="Set of events sent to the callback for nonblocking slave transfers.">i2c_slave_transfer_event_t</a> enumerators to specify which events to send to the callback. Other accepted values are 0 to get a default set of only the transmit and receive events, and <a class="el" href="group__i2c__driver.html#gga87e42e170b60f17f657ef3c06a918133a94b030ebdac378a84961893ae567bfbc">kI2C_SlaveAllEvents</a> to enable all events.</p>
<p>retval #kStatus_Success Slave transfers were successfully started. retval <a class="el" href="group__i2c__driver.html#gga7cc91c89125c25a88e463a9e8550b284a49091894b590d7e479605bf113918952">kStatus_I2C_Busy</a> Slave transfers have already been started on this handle. </p>

</div>
</div>
<a id="ga280404c6b1ede542f2c1c20bd382869c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga280404c6b1ede542f2c1c20bd382869c">&#9670;&nbsp;</a></span>I2C_SlaveWriteBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> I2C_SlaveWriteBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_i2_c___type.html">I2C_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>txBuff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>txSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a polling send transaction on the I2C bus. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The I2C peripheral base pointer. </td></tr>
    <tr><td class="paramname">txBuff</td><td>The pointer to the data to be transferred. </td></tr>
    <tr><td class="paramname">txSize</td><td>The length in bytes of the data to be transferred. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully complete the data transmission. </td></tr>
    <tr><td class="paramname">kStatus_I2C_ArbitrationLost</td><td>Transfer error, arbitration lost. </td></tr>
    <tr><td class="paramname">kStataus_I2C_Nak</td><td>Transfer error, receive NAK during transfer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Performs a polling send transaction on the I2C bus.</p>
<p>param base The I2C peripheral base pointer. param txBuff The pointer to the data to be transferred. param txSize The length in bytes of the data to be transferred. retval kStatus_Success Successfully complete the data transmission. retval kStatus_I2C_ArbitrationLost Transfer error, arbitration lost. retval kStataus_I2C_Nak Transfer error, receive NAK during transfer. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
