\hypertarget{group__lpuart__driver}{}\section{Lpuart\+\_\+driver}
\label{group__lpuart__driver}\index{Lpuart\_driver@{Lpuart\_driver}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct__lpuart__config}{\+\_\+lpuart\+\_\+config}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT configuration structure. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__lpuart__transfer}{\+\_\+lpuart\+\_\+transfer}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT transfer structure. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__lpuart__handle}{\+\_\+lpuart\+\_\+handle}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT handle structure. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__lpuart__driver_gab5b7fa64ce57a2f68327e745f4a3e0b2}\label{group__lpuart__driver_gab5b7fa64ce57a2f68327e745f4a3e0b2}} 
typedef enum \mbox{\hyperlink{group__lpuart__driver_ga22a746cfd0fffff30eaf27f8795b2059}{\+\_\+lpuart\+\_\+parity\+\_\+mode}} \mbox{\hyperlink{group__lpuart__driver_gab5b7fa64ce57a2f68327e745f4a3e0b2}{lpuart\+\_\+parity\+\_\+mode\+\_\+t}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT parity mode. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__lpuart__driver_gad36b5360ffc95732471dab9bd8f74c3b}\label{group__lpuart__driver_gad36b5360ffc95732471dab9bd8f74c3b}} 
typedef enum \mbox{\hyperlink{group__lpuart__driver_ga565561e02414c90014f13391a1dd7dd5}{\+\_\+lpuart\+\_\+data\+\_\+bits}} \mbox{\hyperlink{group__lpuart__driver_gad36b5360ffc95732471dab9bd8f74c3b}{lpuart\+\_\+data\+\_\+bits\+\_\+t}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT data bits count. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__lpuart__driver_ga5c25153c13c99b8c63d8e78cdfeea30f}\label{group__lpuart__driver_ga5c25153c13c99b8c63d8e78cdfeea30f}} 
typedef enum \mbox{\hyperlink{group__lpuart__driver_gad19fe7bcda436707337f6d529d5da155}{\+\_\+lpuart\+\_\+stop\+\_\+bit\+\_\+count}} \mbox{\hyperlink{group__lpuart__driver_ga5c25153c13c99b8c63d8e78cdfeea30f}{lpuart\+\_\+stop\+\_\+bit\+\_\+count\+\_\+t}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT stop bit count. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__lpuart__driver_gad2f95b94d8a055a75e2099e11df4aece}\label{group__lpuart__driver_gad2f95b94d8a055a75e2099e11df4aece}} 
typedef enum \mbox{\hyperlink{group__lpuart__driver_ga5f767cb7f8458682f742f2e7d4bda63d}{\+\_\+lpuart\+\_\+idle\+\_\+type\+\_\+select}} \mbox{\hyperlink{group__lpuart__driver_gad2f95b94d8a055a75e2099e11df4aece}{lpuart\+\_\+idle\+\_\+type\+\_\+select\+\_\+t}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT idle flag type defines when the receiver starts counting. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__lpuart__driver_ga48780347b56ffcf164d92df6957c8ab4}\label{group__lpuart__driver_ga48780347b56ffcf164d92df6957c8ab4}} 
typedef enum \mbox{\hyperlink{group__lpuart__driver_ga13c97cefe85629e606de5281d4eef25b}{\+\_\+lpuart\+\_\+idle\+\_\+config}} \mbox{\hyperlink{group__lpuart__driver_ga48780347b56ffcf164d92df6957c8ab4}{lpuart\+\_\+idle\+\_\+config\+\_\+t}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT idle detected configuration. This structure defines the number of idle characters that must be received before the I\+D\+LE flag is set. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__lpuart__driver_ga35757fcc752984cb90dafc2e815c3d05}\label{group__lpuart__driver_ga35757fcc752984cb90dafc2e815c3d05}} 
typedef struct \mbox{\hyperlink{struct__lpuart__config}{\+\_\+lpuart\+\_\+config}} \mbox{\hyperlink{group__lpuart__driver_ga35757fcc752984cb90dafc2e815c3d05}{lpuart\+\_\+config\+\_\+t}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT configuration structure. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}\label{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}} 
typedef struct \mbox{\hyperlink{struct__lpuart__transfer}{\+\_\+lpuart\+\_\+transfer}} \mbox{\hyperlink{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}{lpuart\+\_\+transfer\+\_\+t}}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT transfer structure. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__lpuart__driver_gaeae5fcbb252991c5f0cdc72dc8deae25}\label{group__lpuart__driver_gaeae5fcbb252991c5f0cdc72dc8deae25}} 
typedef struct \mbox{\hyperlink{struct__lpuart__handle}{\+\_\+lpuart\+\_\+handle}} {\bfseries lpuart\+\_\+handle\+\_\+t}
\item 
\mbox{\Hypertarget{group__lpuart__driver_ga558e0c23c05831e446708a3935f36332}\label{group__lpuart__driver_ga558e0c23c05831e446708a3935f36332}} 
typedef void($\ast$ \mbox{\hyperlink{group__lpuart__driver_ga558e0c23c05831e446708a3935f36332}{lpuart\+\_\+transfer\+\_\+callback\+\_\+t}}) (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} status, void $\ast$user\+Data)
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT transfer callback function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \{ \newline
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dabddb317db7dfffa95856604bfac2a17f}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Busy}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 0), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da98dfeab0a23c81f6b7f2c18acff8cc30}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Busy}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 1), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da079c6d0957d121ce7cd95cf97487dfbb}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Idle}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 2), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da02b8fe84bbfd8c52856b5d48865f7088}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Idle}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 3), 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dabbee969cb0f7b4c49b44b10c4eb583cc}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Watermark\+Too\+Large}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 4), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daca81b4d6e2e792c6d841b95ec25daad9}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Watermark\+Too\+Large}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 5), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da07d5a5092ded158fe53ea4df940f8bdb}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 6), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daf069a1997c3d25588d834ccb33dd35f4}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 7), 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da45a7ed684f4c31aec8999b3da68d3b5e}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Ring\+Buffer\+Overrun}}, 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daf8ada3eacff87751ec865b4fc584bac1}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 9), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da6ccebae2eb859fde044f15f1dd18cba1}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 10), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da1528dc2aacb3a792a1ecbfbbc7941bc9}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 11), 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dad42bcd27cb6e04725768c6b98d4cbe0d}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 12), 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daaa020183f56b7d7f63e22fd5fd8d3df2}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support}}, 
\mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da29540bf056281514eb42c8885f7e2e10}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Detected}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+L\+P\+U\+A\+RT, 14)
 \}
\begin{DoxyCompactList}\small\item\em Error codes for the L\+P\+U\+A\+RT driver. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__lpuart__driver_ga22a746cfd0fffff30eaf27f8795b2059}{\+\_\+lpuart\+\_\+parity\+\_\+mode}} \{ \mbox{\hyperlink{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Disabled}} = 0x0U, 
\mbox{\hyperlink{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059ac92adb3fdf11240ca5dee6c6543b6ff7}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Even}} = 0x2U, 
\mbox{\hyperlink{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059adab63856e98e0715f4ab289ac0da3575}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Odd}} = 0x3U
 \}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT parity mode. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__lpuart__driver_ga565561e02414c90014f13391a1dd7dd5}{\+\_\+lpuart\+\_\+data\+\_\+bits}} \{ \mbox{\hyperlink{group__lpuart__driver_gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Eight\+Data\+Bits}} = 0x0U
 \}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT data bits count. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__lpuart__driver_gad19fe7bcda436707337f6d529d5da155}{\+\_\+lpuart\+\_\+stop\+\_\+bit\+\_\+count}} \{ \mbox{\hyperlink{group__lpuart__driver_ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901}{k\+L\+P\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit}} = 0U, 
\mbox{\hyperlink{group__lpuart__driver_ggad19fe7bcda436707337f6d529d5da155a6e049e0faaf89ed2dfe493ad8f6c93d4}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Two\+Stop\+Bit}} = 1U
 \}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT stop bit count. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__lpuart__driver_ga5f767cb7f8458682f742f2e7d4bda63d}{\+\_\+lpuart\+\_\+idle\+\_\+type\+\_\+select}} \{ \mbox{\hyperlink{group__lpuart__driver_gga5f767cb7f8458682f742f2e7d4bda63da0644f6b95813c520dede56ee3a944267}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit}} = 0U, 
\mbox{\hyperlink{group__lpuart__driver_gga5f767cb7f8458682f742f2e7d4bda63da69545f21a3401c126bf295b5cf94225b}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Stop\+Bit}} = 1U
 \}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT idle flag type defines when the receiver starts counting. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__lpuart__driver_ga13c97cefe85629e606de5281d4eef25b}{\+\_\+lpuart\+\_\+idle\+\_\+config}} \{ \newline
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba955e0bb4d3e75e577eef544b440c24be}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character1}} = 0U, 
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba270caa8e77b08697404771af82abd131}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character2}} = 1U, 
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bacab443d3d053070635ea1f859b73f34c}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character4}} = 2U, 
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25baf125ff40887939add6dd0f42d4485bf3}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character8}} = 3U, 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bace45d3af9a0c590f053df7bb00e6582a}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character16}} = 4U, 
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba1daee04c54b7e37ca5e7331a3e1e7374}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character32}} = 5U, 
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bac497a53ed2755d26961f3b72fbd180ed}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character64}} = 6U, 
\mbox{\hyperlink{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba4e080722efa87475f1710f5524e50c67}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character128}} = 7U
 \}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT idle detected configuration. This structure defines the number of idle characters that must be received before the I\+D\+LE flag is set. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}} \{ \newline
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a43750aac20f72535350c1ab4a1862a3a}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+B\+A\+U\+D\+\_\+\+R\+X\+E\+D\+G\+I\+E\+\_\+\+M\+A\+SK $>$$>$ 8), 
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+T\+I\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0b7f783393a61cce88eab28307e9fe14}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+T\+C\+I\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+R\+I\+E\+\_\+\+M\+A\+SK), 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603af3f83c56032b14e50a682857dd7c152d}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+I\+L\+I\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a8a29c714eaa6acab06a87314f4f29636}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+O\+R\+I\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603ad1a35bc7e89f170a5b82cb4801b73b5e}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+N\+E\+I\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a1b43ca06e0af6b0fcf4b55612363a64d}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+F\+E\+I\+E\+\_\+\+M\+A\+SK), 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a13c12b816605deaabcbc3e6a6db82466}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Interrupt\+Enable}} = (L\+P\+U\+A\+R\+T\+\_\+\+C\+T\+R\+L\+\_\+\+P\+E\+I\+E\+\_\+\+M\+A\+SK)
 \}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT interrupt configuration structure, default settings all disabled. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__lpuart__driver_ga24bb7ca3f894fe5ff55b9f38bec16c89}{\+\_\+lpuart\+\_\+flags}} \{ \newline
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag}}, 
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ae0539c4cf39d4d1e7839a4896fad2a85}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag}}, 
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a9bc679bcc20b81768f84b04e499c5a2f}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag}}, 
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89acf1a40aca38878bc395f9f0b10d8225e}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Flag}} = (L\+P\+U\+A\+R\+T\+\_\+\+S\+T\+A\+T\+\_\+\+I\+D\+L\+E\+\_\+\+M\+A\+SK), 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a994f5f484509133c632215a8b701f8d1}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Flag}} = (L\+P\+U\+A\+R\+T\+\_\+\+S\+T\+A\+T\+\_\+\+O\+R\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a2198232cb9d239f937ab221bbf03259f}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Flag}} = (L\+P\+U\+A\+R\+T\+\_\+\+S\+T\+A\+T\+\_\+\+N\+F\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ad1d40f89cb6aab9c12113586fda7f510}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Flag}}, 
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a2f8d4c03df61bc4678b2ccf1c69eedeb}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Flag}} = (L\+P\+U\+A\+R\+T\+\_\+\+S\+T\+A\+T\+\_\+\+P\+F\+\_\+\+M\+A\+SK), 
\newline
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ae89f181d8dbbf5254d6fe843e4cac6d6}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Flag}}, 
\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a1f14711a74db1cc141b5c2627ee4c799}{k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag}}
 \}
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT status flags. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Driver version}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__lpuart__driver_ga0870fb824ece32739bd35f819f8c408e}\label{group__lpuart__driver_ga0870fb824ece32739bd35f819f8c408e}} 
\#define \mbox{\hyperlink{group__lpuart__driver_ga0870fb824ece32739bd35f819f8c408e}{F\+S\+L\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+V\+E\+R\+S\+I\+ON}}~(\mbox{\hyperlink{group__ftfx__utilities_ga812138aa3315b0c6953c1a26130bcc37}{M\+A\+K\+E\+\_\+\+V\+E\+R\+S\+I\+ON}}(2, 2, 8))
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT driver version 2.\+2.\+8. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Initialization and deinitialization}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_ga26ce3e5d63d8dd5d317a83f22af9682c}{L\+P\+U\+A\+R\+T\+\_\+\+Init}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, const \mbox{\hyperlink{group__lpuart__driver_ga35757fcc752984cb90dafc2e815c3d05}{lpuart\+\_\+config\+\_\+t}} $\ast$config, uint32\+\_\+t src\+Clock\+\_\+\+Hz)
\begin{DoxyCompactList}\small\item\em Initializes an L\+P\+U\+A\+RT instance with the user configuration structure and the peripheral clock. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_ga303ff3b77767bafa449d96f1e8c921e0}{L\+P\+U\+A\+R\+T\+\_\+\+Deinit}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Deinitializes a L\+P\+U\+A\+RT instance. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_ga95dfe3c3886692f1fe32023d59708440}{L\+P\+U\+A\+R\+T\+\_\+\+Get\+Default\+Config}} (\mbox{\hyperlink{group__lpuart__driver_ga35757fcc752984cb90dafc2e815c3d05}{lpuart\+\_\+config\+\_\+t}} $\ast$config)
\begin{DoxyCompactList}\small\item\em Gets the default configuration structure. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_gaf03d9292f8b4cb6e9748cb0bc1db7577}{L\+P\+U\+A\+R\+T\+\_\+\+Set\+Baud\+Rate}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t baud\+Rate\+\_\+\+Bps, uint32\+\_\+t src\+Clock\+\_\+\+Hz)
\begin{DoxyCompactList}\small\item\em Sets the L\+P\+U\+A\+RT instance baudrate. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Status}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \mbox{\hyperlink{group__lpuart__driver_gab83db963591b116f90daf3e24118cb09}{L\+P\+U\+A\+R\+T\+\_\+\+Get\+Status\+Flags}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Gets L\+P\+U\+A\+RT status flags. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_gac6bcdb29d31a2addb8d80d98855ba147}{L\+P\+U\+A\+R\+T\+\_\+\+Clear\+Status\+Flags}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t mask)
\begin{DoxyCompactList}\small\item\em Clears status flags with a provided mask. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Interrupts}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__lpuart__driver_gab5998ebb0dc457f0864c84c16f83d745}{L\+P\+U\+A\+R\+T\+\_\+\+Enable\+Interrupts}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t mask)
\begin{DoxyCompactList}\small\item\em Enables L\+P\+U\+A\+RT interrupts according to a provided mask. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_ga2540406e4a338199acddaa828829cad8}{L\+P\+U\+A\+R\+T\+\_\+\+Disable\+Interrupts}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t mask)
\begin{DoxyCompactList}\small\item\em Disables L\+P\+U\+A\+RT interrupts according to a provided mask. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{group__lpuart__driver_ga172b524bae8bacc6dc95d9daf82c97b5}{L\+P\+U\+A\+R\+T\+\_\+\+Get\+Enabled\+Interrupts}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Gets enabled L\+P\+U\+A\+RT interrupts. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Bus Operations}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \mbox{\hyperlink{group__lpuart__driver_gaaf4c8ce1f1730cdbf094931033d9b52c}{L\+P\+U\+A\+R\+T\+\_\+\+Get\+Instance}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Get the L\+P\+U\+A\+RT instance from peripheral base address. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_gac5377aeebf4327f4ef9de295d8695cd9}{L\+P\+U\+A\+R\+T\+\_\+\+Write\+Blocking}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, const uint8\+\_\+t $\ast$data, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em Writes to the transmitter register using a blocking method. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_gae76aba14dbfe94124082785e2c0ecd9d}{L\+P\+U\+A\+R\+T\+\_\+\+Read\+Blocking}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint8\+\_\+t $\ast$data, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em Reads the receiver data register using a blocking method. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Transactional}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__lpuart__driver_ga10eae12610523a624c1016882f8dba5f}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Create\+Handle}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__lpuart__driver_ga558e0c23c05831e446708a3935f36332}{lpuart\+\_\+transfer\+\_\+callback\+\_\+t}} callback, void $\ast$user\+Data)
\begin{DoxyCompactList}\small\item\em Initializes the L\+P\+U\+A\+RT handle. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_gafba986c473e5935131e63cb882cf26ff}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Send\+Non\+Blocking}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}{lpuart\+\_\+transfer\+\_\+t}} $\ast$xfer)
\begin{DoxyCompactList}\small\item\em Transmits a buffer of data using the interrupt method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_ga5257b77491042af5913a8d91c66318e1}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Start\+Ring\+Buffer}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle, uint8\+\_\+t $\ast$ring\+Buffer, size\+\_\+t ring\+Buffer\+Size)
\begin{DoxyCompactList}\small\item\em Sets up the RX ring buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_gad6a230a664808592aab153ea20e3d60b}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Stop\+Ring\+Buffer}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Aborts the background transfer and uninstalls the ring buffer. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{group__lpuart__driver_ga550523d301acfa413919c2f979228bcc}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Get\+Rx\+Ring\+Buffer\+Length}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Get the length of received data in RX ring buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_ga6dfe9efe9656e126c70ee79fa03f2be3}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Send}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Aborts the interrupt-\/driven data transmit. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_gad80d2469dce0de9361e731e4cefde9fd}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Get\+Send\+Count}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle, uint32\+\_\+t $\ast$count)
\begin{DoxyCompactList}\small\item\em Gets the number of bytes that have been written to the L\+P\+U\+A\+RT transmitter register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_ga8bdb584704ce7955004751e32627f918}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}{lpuart\+\_\+transfer\+\_\+t}} $\ast$xfer, size\+\_\+t $\ast$received\+Bytes)
\begin{DoxyCompactList}\small\item\em Receives a buffer of data using the interrupt method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_ga4950fa0f3835992251c109f655a3ca7d}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Receive}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Aborts the interrupt-\/driven data receiving. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__lpuart__driver_gabfcdc658c463e9e7523cc60c5e8f9672}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Get\+Receive\+Count}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle, uint32\+\_\+t $\ast$count)
\begin{DoxyCompactList}\small\item\em Gets the number of bytes that have been received. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_gac81ce3c490d7185ab7e2d97963ae077e}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Handle\+I\+RQ}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT I\+RQ handle function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__lpuart__driver_ga21345340b5d8f90df6bb64acab0f870f}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Handle\+Error\+I\+RQ}} (\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em L\+P\+U\+A\+RT Error I\+RQ handle function. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{group__lpuart__driver_ga157d5577a5b2f5986037d0d09c7dc77d}\label{group__lpuart__driver_ga157d5577a5b2f5986037d0d09c7dc77d}} 
\subsubsection{\texorpdfstring{anonymous enum}{anonymous enum}}
{\footnotesize\ttfamily anonymous enum}



Error codes for the L\+P\+U\+A\+RT driver. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_TxBusy@{kStatus\_LPUART\_TxBusy}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_TxBusy@{kStatus\_LPUART\_TxBusy}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dabddb317db7dfffa95856604bfac2a17f}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dabddb317db7dfffa95856604bfac2a17f}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Busy&TX busy \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_RxBusy@{kStatus\_LPUART\_RxBusy}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_RxBusy@{kStatus\_LPUART\_RxBusy}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da98dfeab0a23c81f6b7f2c18acff8cc30}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da98dfeab0a23c81f6b7f2c18acff8cc30}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Busy&RX busy \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_TxIdle@{kStatus\_LPUART\_TxIdle}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_TxIdle@{kStatus\_LPUART\_TxIdle}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da079c6d0957d121ce7cd95cf97487dfbb}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da079c6d0957d121ce7cd95cf97487dfbb}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Idle&L\+P\+U\+A\+RT transmitter is idle. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_RxIdle@{kStatus\_LPUART\_RxIdle}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_RxIdle@{kStatus\_LPUART\_RxIdle}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da02b8fe84bbfd8c52856b5d48865f7088}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da02b8fe84bbfd8c52856b5d48865f7088}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Idle&L\+P\+U\+A\+RT receiver is idle. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_TxWatermarkTooLarge@{kStatus\_LPUART\_TxWatermarkTooLarge}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_TxWatermarkTooLarge@{kStatus\_LPUART\_TxWatermarkTooLarge}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dabbee969cb0f7b4c49b44b10c4eb583cc}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dabbee969cb0f7b4c49b44b10c4eb583cc}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Watermark\+Too\+Large&TX F\+I\+FO watermark too large \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_RxWatermarkTooLarge@{kStatus\_LPUART\_RxWatermarkTooLarge}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_RxWatermarkTooLarge@{kStatus\_LPUART\_RxWatermarkTooLarge}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daca81b4d6e2e792c6d841b95ec25daad9}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daca81b4d6e2e792c6d841b95ec25daad9}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Watermark\+Too\+Large&RX F\+I\+FO watermark too large \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_FlagCannotClearManually@{kStatus\_LPUART\_FlagCannotClearManually}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_FlagCannotClearManually@{kStatus\_LPUART\_FlagCannotClearManually}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da07d5a5092ded158fe53ea4df940f8bdb}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da07d5a5092ded158fe53ea4df940f8bdb}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually&Some flag can\textquotesingle{}t manually clear \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_Error@{kStatus\_LPUART\_Error}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_Error@{kStatus\_LPUART\_Error}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daf069a1997c3d25588d834ccb33dd35f4}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daf069a1997c3d25588d834ccb33dd35f4}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Error&Error happens on L\+P\+U\+A\+RT. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_RxRingBufferOverrun@{kStatus\_LPUART\_RxRingBufferOverrun}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_RxRingBufferOverrun@{kStatus\_LPUART\_RxRingBufferOverrun}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da45a7ed684f4c31aec8999b3da68d3b5e}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da45a7ed684f4c31aec8999b3da68d3b5e}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Ring\+Buffer\+Overrun&L\+P\+U\+A\+RT RX software ring buffer overrun. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_RxHardwareOverrun@{kStatus\_LPUART\_RxHardwareOverrun}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_RxHardwareOverrun@{kStatus\_LPUART\_RxHardwareOverrun}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daf8ada3eacff87751ec865b4fc584bac1}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daf8ada3eacff87751ec865b4fc584bac1}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun&L\+P\+U\+A\+RT RX receiver overrun. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_NoiseError@{kStatus\_LPUART\_NoiseError}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_NoiseError@{kStatus\_LPUART\_NoiseError}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da6ccebae2eb859fde044f15f1dd18cba1}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da6ccebae2eb859fde044f15f1dd18cba1}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error&L\+P\+U\+A\+RT noise error. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_FramingError@{kStatus\_LPUART\_FramingError}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_FramingError@{kStatus\_LPUART\_FramingError}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da1528dc2aacb3a792a1ecbfbbc7941bc9}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da1528dc2aacb3a792a1ecbfbbc7941bc9}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error&L\+P\+U\+A\+RT framing error. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_ParityError@{kStatus\_LPUART\_ParityError}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_ParityError@{kStatus\_LPUART\_ParityError}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dad42bcd27cb6e04725768c6b98d4cbe0d}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77dad42bcd27cb6e04725768c6b98d4cbe0d}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error&L\+P\+U\+A\+RT parity error. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_BaudrateNotSupport@{kStatus\_LPUART\_BaudrateNotSupport}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_BaudrateNotSupport@{kStatus\_LPUART\_BaudrateNotSupport}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daaa020183f56b7d7f63e22fd5fd8d3df2}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77daaa020183f56b7d7f63e22fd5fd8d3df2}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support&Baudrate is not support in current clock source \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_LPUART\_IdleLineDetected@{kStatus\_LPUART\_IdleLineDetected}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kStatus\_LPUART\_IdleLineDetected@{kStatus\_LPUART\_IdleLineDetected}}}\mbox{\Hypertarget{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da29540bf056281514eb42c8885f7e2e10}\label{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da29540bf056281514eb42c8885f7e2e10}} 
k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Detected&I\+D\+LE flag. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__lpuart__driver_ga565561e02414c90014f13391a1dd7dd5}\label{group__lpuart__driver_ga565561e02414c90014f13391a1dd7dd5}} 
\index{Lpuart\_driver@{Lpuart\_driver}!\_lpuart\_data\_bits@{\_lpuart\_data\_bits}}
\index{\_lpuart\_data\_bits@{\_lpuart\_data\_bits}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{\_lpuart\_data\_bits}{\_lpuart\_data\_bits}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lpuart__driver_ga565561e02414c90014f13391a1dd7dd5}{\+\_\+lpuart\+\_\+data\+\_\+bits}}}



L\+P\+U\+A\+RT data bits count. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_EightDataBits@{kLPUART\_EightDataBits}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_EightDataBits@{kLPUART\_EightDataBits}}}\mbox{\Hypertarget{group__lpuart__driver_gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899}\label{group__lpuart__driver_gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Eight\+Data\+Bits&Eight data bit \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__lpuart__driver_ga24bb7ca3f894fe5ff55b9f38bec16c89}\label{group__lpuart__driver_ga24bb7ca3f894fe5ff55b9f38bec16c89}} 
\index{Lpuart\_driver@{Lpuart\_driver}!\_lpuart\_flags@{\_lpuart\_flags}}
\index{\_lpuart\_flags@{\_lpuart\_flags}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{\_lpuart\_flags}{\_lpuart\_flags}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lpuart__driver_ga24bb7ca3f894fe5ff55b9f38bec16c89}{\+\_\+lpuart\+\_\+flags}}}



L\+P\+U\+A\+RT status flags. 

This provides constants for the L\+P\+U\+A\+RT status flags for use in the L\+P\+U\+A\+RT functions. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_TxDataRegEmptyFlag@{kLPUART\_TxDataRegEmptyFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_TxDataRegEmptyFlag@{kLPUART\_TxDataRegEmptyFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag&Transmit data register empty flag, sets when transmit buffer is empty \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_TransmissionCompleteFlag@{kLPUART\_TransmissionCompleteFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_TransmissionCompleteFlag@{kLPUART\_TransmissionCompleteFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ae0539c4cf39d4d1e7839a4896fad2a85}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ae0539c4cf39d4d1e7839a4896fad2a85}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag&Transmission complete flag, sets when transmission activity complete \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_RxDataRegFullFlag@{kLPUART\_RxDataRegFullFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_RxDataRegFullFlag@{kLPUART\_RxDataRegFullFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a9bc679bcc20b81768f84b04e499c5a2f}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a9bc679bcc20b81768f84b04e499c5a2f}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag&Receive data register full flag, sets when the receive data buffer is full \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleLineFlag@{kLPUART\_IdleLineFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleLineFlag@{kLPUART\_IdleLineFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89acf1a40aca38878bc395f9f0b10d8225e}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89acf1a40aca38878bc395f9f0b10d8225e}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Flag&Idle line detect flag, sets when idle line detected \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_RxOverrunFlag@{kLPUART\_RxOverrunFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_RxOverrunFlag@{kLPUART\_RxOverrunFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a994f5f484509133c632215a8b701f8d1}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a994f5f484509133c632215a8b701f8d1}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Flag&Receive Overrun, sets when new data is received before data is read from receive register \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_NoiseErrorFlag@{kLPUART\_NoiseErrorFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_NoiseErrorFlag@{kLPUART\_NoiseErrorFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a2198232cb9d239f937ab221bbf03259f}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a2198232cb9d239f937ab221bbf03259f}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Flag&Receive takes 3 samples of each received bit. If any of these samples differ, noise flag sets \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_FramingErrorFlag@{kLPUART\_FramingErrorFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_FramingErrorFlag@{kLPUART\_FramingErrorFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ad1d40f89cb6aab9c12113586fda7f510}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ad1d40f89cb6aab9c12113586fda7f510}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Flag&Frame error flag, sets if logic 0 was detected where stop bit expected \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_ParityErrorFlag@{kLPUART\_ParityErrorFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_ParityErrorFlag@{kLPUART\_ParityErrorFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a2f8d4c03df61bc4678b2ccf1c69eedeb}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a2f8d4c03df61bc4678b2ccf1c69eedeb}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Flag&If parity enabled, sets upon parity error detection \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_RxActiveEdgeFlag@{kLPUART\_RxActiveEdgeFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_RxActiveEdgeFlag@{kLPUART\_RxActiveEdgeFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ae89f181d8dbbf5254d6fe843e4cac6d6}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89ae89f181d8dbbf5254d6fe843e4cac6d6}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Flag&Receive pin active edge interrupt flag, sets when active edge detected \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_RxActiveFlag@{kLPUART\_RxActiveFlag}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_RxActiveFlag@{kLPUART\_RxActiveFlag}}}\mbox{\Hypertarget{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a1f14711a74db1cc141b5c2627ee4c799}\label{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89a1f14711a74db1cc141b5c2627ee4c799}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag&Receiver Active Flag (R\+AF), sets at beginning of valid start bit \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__lpuart__driver_ga13c97cefe85629e606de5281d4eef25b}\label{group__lpuart__driver_ga13c97cefe85629e606de5281d4eef25b}} 
\index{Lpuart\_driver@{Lpuart\_driver}!\_lpuart\_idle\_config@{\_lpuart\_idle\_config}}
\index{\_lpuart\_idle\_config@{\_lpuart\_idle\_config}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{\_lpuart\_idle\_config}{\_lpuart\_idle\_config}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lpuart__driver_ga13c97cefe85629e606de5281d4eef25b}{\+\_\+lpuart\+\_\+idle\+\_\+config}}}



L\+P\+U\+A\+RT idle detected configuration. This structure defines the number of idle characters that must be received before the I\+D\+LE flag is set. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter1@{kLPUART\_IdleCharacter1}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter1@{kLPUART\_IdleCharacter1}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba955e0bb4d3e75e577eef544b440c24be}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba955e0bb4d3e75e577eef544b440c24be}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character1&the number of idle characters. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter2@{kLPUART\_IdleCharacter2}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter2@{kLPUART\_IdleCharacter2}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba270caa8e77b08697404771af82abd131}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba270caa8e77b08697404771af82abd131}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character2&the number of idle characters. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter4@{kLPUART\_IdleCharacter4}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter4@{kLPUART\_IdleCharacter4}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bacab443d3d053070635ea1f859b73f34c}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bacab443d3d053070635ea1f859b73f34c}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character4&the number of idle characters. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter8@{kLPUART\_IdleCharacter8}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter8@{kLPUART\_IdleCharacter8}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25baf125ff40887939add6dd0f42d4485bf3}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25baf125ff40887939add6dd0f42d4485bf3}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character8&the number of idle characters. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter16@{kLPUART\_IdleCharacter16}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter16@{kLPUART\_IdleCharacter16}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bace45d3af9a0c590f053df7bb00e6582a}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bace45d3af9a0c590f053df7bb00e6582a}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character16&the number of idle characters. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter32@{kLPUART\_IdleCharacter32}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter32@{kLPUART\_IdleCharacter32}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba1daee04c54b7e37ca5e7331a3e1e7374}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba1daee04c54b7e37ca5e7331a3e1e7374}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character32&the number of idle characters. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter64@{kLPUART\_IdleCharacter64}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter64@{kLPUART\_IdleCharacter64}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bac497a53ed2755d26961f3b72fbd180ed}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25bac497a53ed2755d26961f3b72fbd180ed}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character64&the number of idle characters. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleCharacter128@{kLPUART\_IdleCharacter128}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleCharacter128@{kLPUART\_IdleCharacter128}}}\mbox{\Hypertarget{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba4e080722efa87475f1710f5524e50c67}\label{group__lpuart__driver_gga13c97cefe85629e606de5281d4eef25ba4e080722efa87475f1710f5524e50c67}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character128&the number of idle characters. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__lpuart__driver_ga5f767cb7f8458682f742f2e7d4bda63d}\label{group__lpuart__driver_ga5f767cb7f8458682f742f2e7d4bda63d}} 
\index{Lpuart\_driver@{Lpuart\_driver}!\_lpuart\_idle\_type\_select@{\_lpuart\_idle\_type\_select}}
\index{\_lpuart\_idle\_type\_select@{\_lpuart\_idle\_type\_select}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{\_lpuart\_idle\_type\_select}{\_lpuart\_idle\_type\_select}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lpuart__driver_ga5f767cb7f8458682f742f2e7d4bda63d}{\+\_\+lpuart\+\_\+idle\+\_\+type\+\_\+select}}}



L\+P\+U\+A\+RT idle flag type defines when the receiver starts counting. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleTypeStartBit@{kLPUART\_IdleTypeStartBit}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleTypeStartBit@{kLPUART\_IdleTypeStartBit}}}\mbox{\Hypertarget{group__lpuart__driver_gga5f767cb7f8458682f742f2e7d4bda63da0644f6b95813c520dede56ee3a944267}\label{group__lpuart__driver_gga5f767cb7f8458682f742f2e7d4bda63da0644f6b95813c520dede56ee3a944267}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit&Start counting after a valid start bit. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleTypeStopBit@{kLPUART\_IdleTypeStopBit}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleTypeStopBit@{kLPUART\_IdleTypeStopBit}}}\mbox{\Hypertarget{group__lpuart__driver_gga5f767cb7f8458682f742f2e7d4bda63da69545f21a3401c126bf295b5cf94225b}\label{group__lpuart__driver_gga5f767cb7f8458682f742f2e7d4bda63da69545f21a3401c126bf295b5cf94225b}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Stop\+Bit&Start counting after a stop bit. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}\label{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}} 
\index{Lpuart\_driver@{Lpuart\_driver}!\_lpuart\_interrupt\_enable@{\_lpuart\_interrupt\_enable}}
\index{\_lpuart\_interrupt\_enable@{\_lpuart\_interrupt\_enable}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{\_lpuart\_interrupt\_enable}{\_lpuart\_interrupt\_enable}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}}}



L\+P\+U\+A\+RT interrupt configuration structure, default settings all disabled. 

This structure contains the settings for all L\+P\+U\+A\+RT interrupt configurations. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_RxActiveEdgeInterruptEnable@{kLPUART\_RxActiveEdgeInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_RxActiveEdgeInterruptEnable@{kLPUART\_RxActiveEdgeInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a43750aac20f72535350c1ab4a1862a3a}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a43750aac20f72535350c1ab4a1862a3a}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Interrupt\+Enable&Receive Active Edge. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_TxDataRegEmptyInterruptEnable@{kLPUART\_TxDataRegEmptyInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_TxDataRegEmptyInterruptEnable@{kLPUART\_TxDataRegEmptyInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable&Transmit data register empty. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_TransmissionCompleteInterruptEnable@{kLPUART\_TransmissionCompleteInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_TransmissionCompleteInterruptEnable@{kLPUART\_TransmissionCompleteInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0b7f783393a61cce88eab28307e9fe14}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0b7f783393a61cce88eab28307e9fe14}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Interrupt\+Enable&Transmission complete. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_RxDataRegFullInterruptEnable@{kLPUART\_RxDataRegFullInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_RxDataRegFullInterruptEnable@{kLPUART\_RxDataRegFullInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable&Receiver data register full. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_IdleLineInterruptEnable@{kLPUART\_IdleLineInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_IdleLineInterruptEnable@{kLPUART\_IdleLineInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603af3f83c56032b14e50a682857dd7c152d}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603af3f83c56032b14e50a682857dd7c152d}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Interrupt\+Enable&Idle line. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_RxOverrunInterruptEnable@{kLPUART\_RxOverrunInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_RxOverrunInterruptEnable@{kLPUART\_RxOverrunInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a8a29c714eaa6acab06a87314f4f29636}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a8a29c714eaa6acab06a87314f4f29636}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Interrupt\+Enable&Receiver Overrun. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_NoiseErrorInterruptEnable@{kLPUART\_NoiseErrorInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_NoiseErrorInterruptEnable@{kLPUART\_NoiseErrorInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603ad1a35bc7e89f170a5b82cb4801b73b5e}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603ad1a35bc7e89f170a5b82cb4801b73b5e}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Interrupt\+Enable&Noise error flag. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_FramingErrorInterruptEnable@{kLPUART\_FramingErrorInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_FramingErrorInterruptEnable@{kLPUART\_FramingErrorInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a1b43ca06e0af6b0fcf4b55612363a64d}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a1b43ca06e0af6b0fcf4b55612363a64d}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Interrupt\+Enable&Framing error flag. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_ParityErrorInterruptEnable@{kLPUART\_ParityErrorInterruptEnable}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_ParityErrorInterruptEnable@{kLPUART\_ParityErrorInterruptEnable}}}\mbox{\Hypertarget{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a13c12b816605deaabcbc3e6a6db82466}\label{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a13c12b816605deaabcbc3e6a6db82466}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Interrupt\+Enable&Parity error flag. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__lpuart__driver_ga22a746cfd0fffff30eaf27f8795b2059}\label{group__lpuart__driver_ga22a746cfd0fffff30eaf27f8795b2059}} 
\index{Lpuart\_driver@{Lpuart\_driver}!\_lpuart\_parity\_mode@{\_lpuart\_parity\_mode}}
\index{\_lpuart\_parity\_mode@{\_lpuart\_parity\_mode}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{\_lpuart\_parity\_mode}{\_lpuart\_parity\_mode}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lpuart__driver_ga22a746cfd0fffff30eaf27f8795b2059}{\+\_\+lpuart\+\_\+parity\+\_\+mode}}}



L\+P\+U\+A\+RT parity mode. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_ParityDisabled@{kLPUART\_ParityDisabled}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_ParityDisabled@{kLPUART\_ParityDisabled}}}\mbox{\Hypertarget{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a}\label{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Disabled&Parity disabled \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_ParityEven@{kLPUART\_ParityEven}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_ParityEven@{kLPUART\_ParityEven}}}\mbox{\Hypertarget{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059ac92adb3fdf11240ca5dee6c6543b6ff7}\label{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059ac92adb3fdf11240ca5dee6c6543b6ff7}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Even&Parity enabled, type even, bit setting\+: P\+E$\vert$\+PT = 10 \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_ParityOdd@{kLPUART\_ParityOdd}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_ParityOdd@{kLPUART\_ParityOdd}}}\mbox{\Hypertarget{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059adab63856e98e0715f4ab289ac0da3575}\label{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059adab63856e98e0715f4ab289ac0da3575}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Odd&Parity enabled, type odd, bit setting\+: P\+E$\vert$\+PT = 11 \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__lpuart__driver_gad19fe7bcda436707337f6d529d5da155}\label{group__lpuart__driver_gad19fe7bcda436707337f6d529d5da155}} 
\index{Lpuart\_driver@{Lpuart\_driver}!\_lpuart\_stop\_bit\_count@{\_lpuart\_stop\_bit\_count}}
\index{\_lpuart\_stop\_bit\_count@{\_lpuart\_stop\_bit\_count}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{\_lpuart\_stop\_bit\_count}{\_lpuart\_stop\_bit\_count}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lpuart__driver_gad19fe7bcda436707337f6d529d5da155}{\+\_\+lpuart\+\_\+stop\+\_\+bit\+\_\+count}}}



L\+P\+U\+A\+RT stop bit count. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_OneStopBit@{kLPUART\_OneStopBit}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_OneStopBit@{kLPUART\_OneStopBit}}}\mbox{\Hypertarget{group__lpuart__driver_ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901}\label{group__lpuart__driver_ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit&One stop bit \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLPUART\_TwoStopBit@{kLPUART\_TwoStopBit}!Lpuart\_driver@{Lpuart\_driver}}\index{Lpuart\_driver@{Lpuart\_driver}!kLPUART\_TwoStopBit@{kLPUART\_TwoStopBit}}}\mbox{\Hypertarget{group__lpuart__driver_ggad19fe7bcda436707337f6d529d5da155a6e049e0faaf89ed2dfe493ad8f6c93d4}\label{group__lpuart__driver_ggad19fe7bcda436707337f6d529d5da155a6e049e0faaf89ed2dfe493ad8f6c93d4}} 
k\+L\+P\+U\+A\+R\+T\+\_\+\+Two\+Stop\+Bit&Two stop bits \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__lpuart__driver_gac6bcdb29d31a2addb8d80d98855ba147}\label{group__lpuart__driver_gac6bcdb29d31a2addb8d80d98855ba147}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_ClearStatusFlags@{LPUART\_ClearStatusFlags}}
\index{LPUART\_ClearStatusFlags@{LPUART\_ClearStatusFlags}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_ClearStatusFlags()}{LPUART\_ClearStatusFlags()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Clear\+Status\+Flags (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{mask }\end{DoxyParamCaption})}



Clears status flags with a provided mask. 

This function clears L\+P\+U\+A\+RT status flags with a provided mask. Automatically cleared flags can\textquotesingle{}t be cleared by this function. Flags that can only cleared or set by hardware are\+: k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Fifo\+Empty\+Flag,k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Fifo\+Empty\+Flag Note\+: This A\+PI should be called when the Tx/\+Rx is idle, otherwise it takes no effects.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em mask} & the status flags to be cleared. The user can use the enumerators in the \+\_\+lpuart\+\_\+status\+\_\+flag\+\_\+t to do the OR operation and get the mask. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 succeed, others failed. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually} & The flag can\textquotesingle{}t be cleared by this function but it is cleared automatically by hardware. \\
\hline
{\em k\+Status\+\_\+\+Success} & Status in the mask are cleared.\\
\hline
\end{DoxyRetVals}
brief Clears status flags with a provided mask.

This function clears L\+P\+U\+A\+RT status flags with a provided mask. Automatically cleared flags can\textquotesingle{}t be cleared by this function. Flags that can only cleared or set by hardware are\+: k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Fifo\+Empty\+Flag,k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Fifo\+Empty\+Flag Note\+: This A\+PI should be called when the Tx/\+Rx is idle, otherwise it takes no effects.

param base L\+P\+U\+A\+RT peripheral base address. param mask the status flags to be cleared. The user can use the enumerators in the \+\_\+lpuart\+\_\+status\+\_\+flag\+\_\+t to do the OR operation and get the mask. return 0 succeed, others failed. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually The flag can\textquotesingle{}t be cleared by this function but it is cleared automatically by hardware. retval k\+Status\+\_\+\+Success Status in the mask are cleared. \mbox{\Hypertarget{group__lpuart__driver_ga303ff3b77767bafa449d96f1e8c921e0}\label{group__lpuart__driver_ga303ff3b77767bafa449d96f1e8c921e0}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_Deinit@{LPUART\_Deinit}}
\index{LPUART\_Deinit@{LPUART\_Deinit}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_Deinit()}{LPUART\_Deinit()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Deinit (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Deinitializes a L\+P\+U\+A\+RT instance. 

This function waits for transmit to complete, disables TX and RX, and disables the L\+P\+U\+A\+RT clock.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address.\\
\hline
\end{DoxyParams}
brief Deinitializes a L\+P\+U\+A\+RT instance.

This function waits for transmit to complete, disables TX and RX, and disables the L\+P\+U\+A\+RT clock.

param base L\+P\+U\+A\+RT peripheral base address. \mbox{\Hypertarget{group__lpuart__driver_ga2540406e4a338199acddaa828829cad8}\label{group__lpuart__driver_ga2540406e4a338199acddaa828829cad8}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_DisableInterrupts@{LPUART\_DisableInterrupts}}
\index{LPUART\_DisableInterrupts@{LPUART\_DisableInterrupts}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_DisableInterrupts()}{LPUART\_DisableInterrupts()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Disable\+Interrupts (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{mask }\end{DoxyParamCaption})}



Disables L\+P\+U\+A\+RT interrupts according to a provided mask. 

This function disables the L\+P\+U\+A\+RT interrupts according to a provided mask. The mask is a logical OR of enumeration members. See \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}}. This example shows how to disable the TX empty interrupt and RX full interrupt\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__lpuart__driver_ga2540406e4a338199acddaa828829cad8}{LPUART\_DisableInterrupts}}(\mbox{\hyperlink{group___l_p_u_a_r_t___peripheral___access___layer_ga73eb37d103f4e4f2d18ec3d3f5208ab9}{LPUART1}},\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c}{kLPUART\_TxDataRegEmptyInterruptEnable}} | \mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22}{kLPUART\_RxDataRegFullInterruptEnable}});}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em mask} & The interrupts to disable. Logical OR of \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}}.\\
\hline
\end{DoxyParams}
brief Disables L\+P\+U\+A\+RT interrupts according to a provided mask.

This function disables the L\+P\+U\+A\+RT interrupts according to a provided mask. The mask is a logical OR of enumeration members. See ref \+\_\+lpuart\+\_\+interrupt\+\_\+enable. This example shows how to disable the TX empty interrupt and RX full interrupt\+: code L\+P\+U\+A\+R\+T\+\_\+\+Disable\+Interrupts(L\+P\+U\+A\+R\+T1,k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable $\vert$ k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable); endcode

param base L\+P\+U\+A\+RT peripheral base address. param mask The interrupts to disable. Logical OR of ref \+\_\+lpuart\+\_\+interrupt\+\_\+enable. \mbox{\Hypertarget{group__lpuart__driver_gab5998ebb0dc457f0864c84c16f83d745}\label{group__lpuart__driver_gab5998ebb0dc457f0864c84c16f83d745}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_EnableInterrupts@{LPUART\_EnableInterrupts}}
\index{LPUART\_EnableInterrupts@{LPUART\_EnableInterrupts}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_EnableInterrupts()}{LPUART\_EnableInterrupts()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Enable\+Interrupts (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{mask }\end{DoxyParamCaption})}



Enables L\+P\+U\+A\+RT interrupts according to a provided mask. 

This function enables the L\+P\+U\+A\+RT interrupts according to a provided mask. The mask is a logical OR of enumeration members. See the \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}}. This examples shows how to enable TX empty interrupt and RX full interrupt\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__lpuart__driver_gab5998ebb0dc457f0864c84c16f83d745}{LPUART\_EnableInterrupts}}(\mbox{\hyperlink{group___l_p_u_a_r_t___peripheral___access___layer_ga73eb37d103f4e4f2d18ec3d3f5208ab9}{LPUART1}},\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c}{kLPUART\_TxDataRegEmptyInterruptEnable}} | \mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a5b4a0893c98bf79d0dad88aeb7714d22}{kLPUART\_RxDataRegFullInterruptEnable}});}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em mask} & The interrupts to enable. Logical OR of \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}.\\
\hline
\end{DoxyParams}
brief Enables L\+P\+U\+A\+RT interrupts according to a provided mask.

This function enables the L\+P\+U\+A\+RT interrupts according to a provided mask. The mask is a logical OR of enumeration members. See the ref \+\_\+lpuart\+\_\+interrupt\+\_\+enable. This examples shows how to enable TX empty interrupt and RX full interrupt\+: code L\+P\+U\+A\+R\+T\+\_\+\+Enable\+Interrupts(L\+P\+U\+A\+R\+T1,k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable $\vert$ k\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable); endcode

param base L\+P\+U\+A\+RT peripheral base address. param mask The interrupts to enable. Logical OR of ref \+\_\+uart\+\_\+interrupt\+\_\+enable. \mbox{\Hypertarget{group__lpuart__driver_ga95dfe3c3886692f1fe32023d59708440}\label{group__lpuart__driver_ga95dfe3c3886692f1fe32023d59708440}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_GetDefaultConfig@{LPUART\_GetDefaultConfig}}
\index{LPUART\_GetDefaultConfig@{LPUART\_GetDefaultConfig}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_GetDefaultConfig()}{LPUART\_GetDefaultConfig()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Get\+Default\+Config (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__lpuart__driver_ga35757fcc752984cb90dafc2e815c3d05}{lpuart\+\_\+config\+\_\+t}} $\ast$}]{config }\end{DoxyParamCaption})}



Gets the default configuration structure. 

This function initializes the L\+P\+U\+A\+RT configuration structure to a default value. The default values are\+: lpuart\+Config-\/$>$baud\+Rate\+\_\+\+Bps = 115200U; lpuart\+Config-\/$>$parity\+Mode = k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Disabled; lpuart\+Config-\/$>$data\+Bits\+Count = k\+L\+P\+U\+A\+R\+T\+\_\+\+Eight\+Data\+Bits; lpuart\+Config-\/$>$is\+Msb = false; lpuart\+Config-\/$>$stop\+Bit\+Count = k\+L\+P\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit; lpuart\+Config-\/$>$tx\+Fifo\+Watermark = 0; lpuart\+Config-\/$>$rx\+Fifo\+Watermark = 1; lpuart\+Config-\/$>$rx\+Idle\+Type = k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit; lpuart\+Config-\/$>$rx\+Idle\+Config = k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character1; lpuart\+Config-\/$>$enable\+Tx = false; lpuart\+Config-\/$>$enable\+Rx = false;


\begin{DoxyParams}{Parameters}
{\em config} & Pointer to a configuration structure.\\
\hline
\end{DoxyParams}
brief Gets the default configuration structure.

This function initializes the L\+P\+U\+A\+RT configuration structure to a default value. The default values are\+: lpuart\+Config-\/$>$baud\+Rate\+\_\+\+Bps = 115200U; lpuart\+Config-\/$>$parity\+Mode = k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Disabled; lpuart\+Config-\/$>$data\+Bits\+Count = k\+L\+P\+U\+A\+R\+T\+\_\+\+Eight\+Data\+Bits; lpuart\+Config-\/$>$is\+Msb = false; lpuart\+Config-\/$>$stop\+Bit\+Count = k\+L\+P\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit; lpuart\+Config-\/$>$tx\+Fifo\+Watermark = 0; lpuart\+Config-\/$>$rx\+Fifo\+Watermark = 1; lpuart\+Config-\/$>$rx\+Idle\+Type = k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit; lpuart\+Config-\/$>$rx\+Idle\+Config = k\+L\+P\+U\+A\+R\+T\+\_\+\+Idle\+Character1; lpuart\+Config-\/$>$enable\+Tx = false; lpuart\+Config-\/$>$enable\+Rx = false;

param config Pointer to a configuration structure. \mbox{\Hypertarget{group__lpuart__driver_ga172b524bae8bacc6dc95d9daf82c97b5}\label{group__lpuart__driver_ga172b524bae8bacc6dc95d9daf82c97b5}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_GetEnabledInterrupts@{LPUART\_GetEnabledInterrupts}}
\index{LPUART\_GetEnabledInterrupts@{LPUART\_GetEnabledInterrupts}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_GetEnabledInterrupts()}{LPUART\_GetEnabledInterrupts()}}
{\footnotesize\ttfamily uint32\+\_\+t L\+P\+U\+A\+R\+T\+\_\+\+Get\+Enabled\+Interrupts (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Gets enabled L\+P\+U\+A\+RT interrupts. 

This function gets the enabled L\+P\+U\+A\+RT interrupts. The enabled interrupts are returned as the logical OR value of the enumerators \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}}. To check a specific interrupt enable status, compare the return value with enumerators in \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}}. For example, to check whether the TX empty interrupt is enabled\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{uint32\_t enabledInterrupts = \mbox{\hyperlink{group__lpuart__driver_ga172b524bae8bacc6dc95d9daf82c97b5}{LPUART\_GetEnabledInterrupts}}(\mbox{\hyperlink{group___l_p_u_a_r_t___peripheral___access___layer_ga73eb37d103f4e4f2d18ec3d3f5208ab9}{LPUART1}});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (\mbox{\hyperlink{group__lpuart__driver_gga199a157d391291a9d003bf23954f9603a0e8bf389f65e5f86a3063dc55b8aae1c}{kLPUART\_TxDataRegEmptyInterruptEnable}} \& enabledInterrupts)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
L\+P\+U\+A\+RT interrupt flags which are logical OR of the enumerators in \mbox{\hyperlink{group__lpuart__driver_ga199a157d391291a9d003bf23954f9603}{\+\_\+lpuart\+\_\+interrupt\+\_\+enable}}.
\end{DoxyReturn}
brief Gets enabled L\+P\+U\+A\+RT interrupts.

This function gets the enabled L\+P\+U\+A\+RT interrupts. The enabled interrupts are returned as the logical OR value of the enumerators ref \+\_\+lpuart\+\_\+interrupt\+\_\+enable. To check a specific interrupt enable status, compare the return value with enumerators in ref \+\_\+lpuart\+\_\+interrupt\+\_\+enable. For example, to check whether the TX empty interrupt is enabled\+: code uint32\+\_\+t enabled\+Interrupts = L\+P\+U\+A\+R\+T\+\_\+\+Get\+Enabled\+Interrupts(\+L\+P\+U\+A\+R\+T1);

if (k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable \& enabled\+Interrupts) \{ ... \} endcode

param base L\+P\+U\+A\+RT peripheral base address. return L\+P\+U\+A\+RT interrupt flags which are logical OR of the enumerators in ref \+\_\+lpuart\+\_\+interrupt\+\_\+enable. \mbox{\Hypertarget{group__lpuart__driver_gaaf4c8ce1f1730cdbf094931033d9b52c}\label{group__lpuart__driver_gaaf4c8ce1f1730cdbf094931033d9b52c}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_GetInstance@{LPUART\_GetInstance}}
\index{LPUART\_GetInstance@{LPUART\_GetInstance}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_GetInstance()}{LPUART\_GetInstance()}}
{\footnotesize\ttfamily uint32\+\_\+t L\+P\+U\+A\+R\+T\+\_\+\+Get\+Instance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Get the L\+P\+U\+A\+RT instance from peripheral base address. 


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
L\+P\+U\+A\+RT instance.
\end{DoxyReturn}
brief Get the L\+P\+U\+A\+RT instance from peripheral base address.

param base L\+P\+U\+A\+RT peripheral base address. return L\+P\+U\+A\+RT instance. \mbox{\Hypertarget{group__lpuart__driver_gab83db963591b116f90daf3e24118cb09}\label{group__lpuart__driver_gab83db963591b116f90daf3e24118cb09}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_GetStatusFlags@{LPUART\_GetStatusFlags}}
\index{LPUART\_GetStatusFlags@{LPUART\_GetStatusFlags}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_GetStatusFlags()}{LPUART\_GetStatusFlags()}}
{\footnotesize\ttfamily uint32\+\_\+t L\+P\+U\+A\+R\+T\+\_\+\+Get\+Status\+Flags (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Gets L\+P\+U\+A\+RT status flags. 

This function gets all L\+P\+U\+A\+RT status flags. The flags are returned as the logical OR value of the enumerators \mbox{\hyperlink{group__lpuart__driver_ga24bb7ca3f894fe5ff55b9f38bec16c89}{\+\_\+lpuart\+\_\+flags}}. To check for a specific status, compare the return value with enumerators in the \mbox{\hyperlink{group__lpuart__driver_ga24bb7ca3f894fe5ff55b9f38bec16c89}{\+\_\+lpuart\+\_\+flags}}. For example, to check whether the TX is empty\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} (\mbox{\hyperlink{group__lpuart__driver_gga24bb7ca3f894fe5ff55b9f38bec16c89aa765f8ddac00348328f64ad4222d057a}{kLPUART\_TxDataRegEmptyFlag}} \& \mbox{\hyperlink{group__lpuart__driver_gab83db963591b116f90daf3e24118cb09}{LPUART\_GetStatusFlags}}(\mbox{\hyperlink{group___l_p_u_a_r_t___peripheral___access___layer_ga73eb37d103f4e4f2d18ec3d3f5208ab9}{LPUART1}}))}
\DoxyCodeLine{\{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
L\+P\+U\+A\+RT status flags which are O\+Red by the enumerators in the \+\_\+lpuart\+\_\+flags.
\end{DoxyReturn}
brief Gets L\+P\+U\+A\+RT status flags.

This function gets all L\+P\+U\+A\+RT status flags. The flags are returned as the logical OR value of the enumerators ref \+\_\+lpuart\+\_\+flags. To check for a specific status, compare the return value with enumerators in the ref \+\_\+lpuart\+\_\+flags. For example, to check whether the TX is empty\+: code if (k\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag \& L\+P\+U\+A\+R\+T\+\_\+\+Get\+Status\+Flags(\+L\+P\+U\+A\+R\+T1)) \{ ... \} endcode

param base L\+P\+U\+A\+RT peripheral base address. return L\+P\+U\+A\+RT status flags which are O\+Red by the enumerators in the \+\_\+lpuart\+\_\+flags. \mbox{\Hypertarget{group__lpuart__driver_ga26ce3e5d63d8dd5d317a83f22af9682c}\label{group__lpuart__driver_ga26ce3e5d63d8dd5d317a83f22af9682c}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_Init@{LPUART\_Init}}
\index{LPUART\_Init@{LPUART\_Init}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_Init()}{LPUART\_Init()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{const \mbox{\hyperlink{group__lpuart__driver_ga35757fcc752984cb90dafc2e815c3d05}{lpuart\+\_\+config\+\_\+t}} $\ast$}]{config,  }\item[{uint32\+\_\+t}]{src\+Clock\+\_\+\+Hz }\end{DoxyParamCaption})}



Initializes an L\+P\+U\+A\+RT instance with the user configuration structure and the peripheral clock. 

This function configures the L\+P\+U\+A\+RT module with user-\/defined settings. Call the \mbox{\hyperlink{group__lpuart__driver_ga95dfe3c3886692f1fe32023d59708440}{L\+P\+U\+A\+R\+T\+\_\+\+Get\+Default\+Config()}} function to configure the configuration structure and get the default configuration. The example below shows how to use this A\+PI to configure the L\+P\+U\+A\+RT. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{struct__lpuart__config}{lpuart\_config\_t}} lpuartConfig;}
\DoxyCodeLine{lpuartConfig.\mbox{\hyperlink{struct__lpuart__config_aa5df547b4cb95d3c959373cf6fa672b5}{baudRate\_Bps}} = 115200U;}
\DoxyCodeLine{lpuartConfig.\mbox{\hyperlink{struct__lpuart__config_a12a3b03bf71728c9d45a5c5c59bdcf94}{parityMode}} = \mbox{\hyperlink{group__lpuart__driver_gga22a746cfd0fffff30eaf27f8795b2059a0e5bdb8fc4e1010930d05e1490a75b1a}{kLPUART\_ParityDisabled}};}
\DoxyCodeLine{lpuartConfig.\mbox{\hyperlink{struct__lpuart__config_a510ee8598e5be024a8b74881f3d3ba3d}{dataBitsCount}} = \mbox{\hyperlink{group__lpuart__driver_gga565561e02414c90014f13391a1dd7dd5aaa10fe51f0b83d5c0a2e060dab983899}{kLPUART\_EightDataBits}};}
\DoxyCodeLine{lpuartConfig.\mbox{\hyperlink{struct__lpuart__config_af9f7a36013824eebc7fc6c7d646f42ce}{isMsb}} = \textcolor{keyword}{false};}
\DoxyCodeLine{lpuartConfig.stopBitCount = \mbox{\hyperlink{group__lpuart__driver_ggad19fe7bcda436707337f6d529d5da155a4304f0ee73a5fabfadfc05ca1fbd3901}{kLPUART\_OneStopBit}};}
\DoxyCodeLine{lpuartConfig.txFifoWatermark = 0;}
\DoxyCodeLine{lpuartConfig.rxFifoWatermark = 1;}
\DoxyCodeLine{\mbox{\hyperlink{group__lpuart__driver_ga26ce3e5d63d8dd5d317a83f22af9682c}{LPUART\_Init}}(\mbox{\hyperlink{group___l_p_u_a_r_t___peripheral___access___layer_ga73eb37d103f4e4f2d18ec3d3f5208ab9}{LPUART1}}, \&lpuartConfig, 20000000U);}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em config} & Pointer to a user-\/defined configuration structure. \\
\hline
{\em src\+Clock\+\_\+\+Hz} & L\+P\+U\+A\+RT clock source frequency in HZ. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support} & Baudrate is not support in current clock source. \\
\hline
{\em k\+Status\+\_\+\+Success} & L\+P\+U\+A\+RT initialize succeed\\
\hline
\end{DoxyRetVals}
brief Initializes an L\+P\+U\+A\+RT instance with the user configuration structure and the peripheral clock.

This function configures the L\+P\+U\+A\+RT module with user-\/defined settings. Call the \mbox{\hyperlink{group__lpuart__driver_ga95dfe3c3886692f1fe32023d59708440}{L\+P\+U\+A\+R\+T\+\_\+\+Get\+Default\+Config()}} function to configure the configuration structure and get the default configuration. The example below shows how to use this A\+PI to configure the L\+P\+U\+A\+RT. code lpuart\+\_\+config\+\_\+t lpuart\+Config; lpuart\+Config.\+baud\+Rate\+\_\+\+Bps = 115200U; lpuart\+Config.\+parity\+Mode = k\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Disabled; lpuart\+Config.\+data\+Bits\+Count = k\+L\+P\+U\+A\+R\+T\+\_\+\+Eight\+Data\+Bits; lpuart\+Config.\+is\+Msb = false; lpuart\+Config.\+stop\+Bit\+Count = k\+L\+P\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit; lpuart\+Config.\+tx\+Fifo\+Watermark = 0; lpuart\+Config.\+rx\+Fifo\+Watermark = 1; L\+P\+U\+A\+R\+T\+\_\+\+Init(\+L\+P\+U\+A\+R\+T1, \&lpuart\+Config, 20000000\+U); endcode

param base L\+P\+U\+A\+RT peripheral base address. param config Pointer to a user-\/defined configuration structure. param src\+Clock\+\_\+\+Hz L\+P\+U\+A\+RT clock source frequency in HZ. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support Baudrate is not support in current clock source. retval k\+Status\+\_\+\+Success L\+P\+U\+A\+RT initialize succeed \mbox{\Hypertarget{group__lpuart__driver_gae76aba14dbfe94124082785e2c0ecd9d}\label{group__lpuart__driver_gae76aba14dbfe94124082785e2c0ecd9d}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_ReadBlocking@{LPUART\_ReadBlocking}}
\index{LPUART\_ReadBlocking@{LPUART\_ReadBlocking}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_ReadBlocking()}{LPUART\_ReadBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Read\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Reads the receiver data register using a blocking method. 

This function polls the receiver register, waits for the receiver register full or receiver F\+I\+FO has data, and reads data from the TX register.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em data} & Start address of the buffer to store the received data. \\
\hline
{\em length} & Size of the buffer. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun} & Receiver overrun happened while receiving data. \\
\hline
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error} & Noise error happened while receiving data. \\
\hline
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error} & Framing error happened while receiving data. \\
\hline
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error} & Parity error happened while receiving data. \\
\hline
{\em k\+Status\+\_\+\+Success} & Successfully received all data.\\
\hline
\end{DoxyRetVals}
brief Reads the receiver data register using a blocking method.

This function polls the receiver register, waits for the receiver register full or receiver F\+I\+FO has data, and reads data from the TX register.

param base L\+P\+U\+A\+RT peripheral base address. param data Start address of the buffer to store the received data. param length Size of the buffer. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun Receiver overrun happened while receiving data. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Noise\+Error Noise error happened while receiving data. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Framing\+Error Framing error happened while receiving data. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Parity\+Error Parity error happened while receiving data. retval k\+Status\+\_\+\+Success Successfully received all data. \mbox{\Hypertarget{group__lpuart__driver_gaf03d9292f8b4cb6e9748cb0bc1db7577}\label{group__lpuart__driver_gaf03d9292f8b4cb6e9748cb0bc1db7577}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_SetBaudRate@{LPUART\_SetBaudRate}}
\index{LPUART\_SetBaudRate@{LPUART\_SetBaudRate}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_SetBaudRate()}{LPUART\_SetBaudRate()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Set\+Baud\+Rate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{baud\+Rate\+\_\+\+Bps,  }\item[{uint32\+\_\+t}]{src\+Clock\+\_\+\+Hz }\end{DoxyParamCaption})}



Sets the L\+P\+U\+A\+RT instance baudrate. 

This function configures the L\+P\+U\+A\+RT module baudrate. This function is used to update the L\+P\+U\+A\+RT module baudrate after the L\+P\+U\+A\+RT module is initialized by the L\+P\+U\+A\+R\+T\+\_\+\+Init. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__lpuart__driver_gaf03d9292f8b4cb6e9748cb0bc1db7577}{LPUART\_SetBaudRate}}(\mbox{\hyperlink{group___l_p_u_a_r_t___peripheral___access___layer_ga73eb37d103f4e4f2d18ec3d3f5208ab9}{LPUART1}}, 115200U, 20000000U);}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em baud\+Rate\+\_\+\+Bps} & L\+P\+U\+A\+RT baudrate to be set. \\
\hline
{\em src\+Clock\+\_\+\+Hz} & L\+P\+U\+A\+RT clock source frequency in HZ. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support} & Baudrate is not supported in the current clock source. \\
\hline
{\em k\+Status\+\_\+\+Success} & Set baudrate succeeded.\\
\hline
\end{DoxyRetVals}
brief Sets the L\+P\+U\+A\+RT instance baudrate.

This function configures the L\+P\+U\+A\+RT module baudrate. This function is used to update the L\+P\+U\+A\+RT module baudrate after the L\+P\+U\+A\+RT module is initialized by the L\+P\+U\+A\+R\+T\+\_\+\+Init. code L\+P\+U\+A\+R\+T\+\_\+\+Set\+Baud\+Rate(\+L\+P\+U\+A\+R\+T1, 115200\+U, 20000000\+U); endcode

param base L\+P\+U\+A\+RT peripheral base address. param baud\+Rate\+\_\+\+Bps L\+P\+U\+A\+RT baudrate to be set. param src\+Clock\+\_\+\+Hz L\+P\+U\+A\+RT clock source frequency in HZ. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support Baudrate is not supported in the current clock source. retval k\+Status\+\_\+\+Success Set baudrate succeeded. \mbox{\Hypertarget{group__lpuart__driver_ga4950fa0f3835992251c109f655a3ca7d}\label{group__lpuart__driver_ga4950fa0f3835992251c109f655a3ca7d}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferAbortReceive@{LPUART\_TransferAbortReceive}}
\index{LPUART\_TransferAbortReceive@{LPUART\_TransferAbortReceive}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferAbortReceive()}{LPUART\_TransferAbortReceive()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Receive (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Aborts the interrupt-\/driven data receiving. 

This function aborts the interrupt-\/driven data receiving. The user can get the remain\+Bytes to find out how many bytes not received yet.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief Aborts the interrupt-\/driven data receiving.

This function aborts the interrupt-\/driven data receiving. The user can get the remain\+Bytes to find out how many bytes not received yet.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. \mbox{\Hypertarget{group__lpuart__driver_ga6dfe9efe9656e126c70ee79fa03f2be3}\label{group__lpuart__driver_ga6dfe9efe9656e126c70ee79fa03f2be3}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferAbortSend@{LPUART\_TransferAbortSend}}
\index{LPUART\_TransferAbortSend@{LPUART\_TransferAbortSend}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferAbortSend()}{LPUART\_TransferAbortSend()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Send (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Aborts the interrupt-\/driven data transmit. 

This function aborts the interrupt driven data sending. The user can get the remain\+Btyes to find out how many bytes are not sent out.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief Aborts the interrupt-\/driven data transmit.

This function aborts the interrupt driven data sending. The user can get the remain\+Btyes to find out how many bytes are not sent out.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. \mbox{\Hypertarget{group__lpuart__driver_ga10eae12610523a624c1016882f8dba5f}\label{group__lpuart__driver_ga10eae12610523a624c1016882f8dba5f}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferCreateHandle@{LPUART\_TransferCreateHandle}}
\index{LPUART\_TransferCreateHandle@{LPUART\_TransferCreateHandle}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferCreateHandle()}{LPUART\_TransferCreateHandle()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Create\+Handle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{\mbox{\hyperlink{group__lpuart__driver_ga558e0c23c05831e446708a3935f36332}{lpuart\+\_\+transfer\+\_\+callback\+\_\+t}}}]{callback,  }\item[{void $\ast$}]{user\+Data }\end{DoxyParamCaption})}



Initializes the L\+P\+U\+A\+RT handle. 

This function initializes the L\+P\+U\+A\+RT handle, which can be used for other L\+P\+U\+A\+RT transactional A\+P\+Is. Usually, for a specified L\+P\+U\+A\+RT instance, call this A\+PI once to get the initialized handle.

The L\+P\+U\+A\+RT driver supports the \char`\"{}background\char`\"{} receiving, which means that user can set up an RX ring buffer optionally. Data received is stored into the ring buffer even when the user doesn\textquotesingle{}t call the \mbox{\hyperlink{group__lpuart__driver_ga8bdb584704ce7955004751e32627f918}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking()}} A\+PI. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly. The ring buffer is disabled if passing N\+U\+LL as {\ttfamily ring\+Buffer}.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer. \\
\hline
{\em callback} & Callback function. \\
\hline
{\em user\+Data} & User data.\\
\hline
\end{DoxyParams}
brief Initializes the L\+P\+U\+A\+RT handle.

This function initializes the L\+P\+U\+A\+RT handle, which can be used for other L\+P\+U\+A\+RT transactional A\+P\+Is. Usually, for a specified L\+P\+U\+A\+RT instance, call this A\+PI once to get the initialized handle.

The L\+P\+U\+A\+RT driver supports the \char`\"{}background\char`\"{} receiving, which means that user can set up an RX ring buffer optionally. Data received is stored into the ring buffer even when the user doesn\textquotesingle{}t call the \mbox{\hyperlink{group__lpuart__driver_ga8bdb584704ce7955004751e32627f918}{L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking()}} A\+PI. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly. The ring buffer is disabled if passing N\+U\+LL as p ring\+Buffer.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. param callback Callback function. param user\+Data User data. \mbox{\Hypertarget{group__lpuart__driver_gabfcdc658c463e9e7523cc60c5e8f9672}\label{group__lpuart__driver_gabfcdc658c463e9e7523cc60c5e8f9672}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferGetReceiveCount@{LPUART\_TransferGetReceiveCount}}
\index{LPUART\_TransferGetReceiveCount@{LPUART\_TransferGetReceiveCount}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferGetReceiveCount()}{LPUART\_TransferGetReceiveCount()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Get\+Receive\+Count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{uint32\+\_\+t $\ast$}]{count }\end{DoxyParamCaption})}



Gets the number of bytes that have been received. 

This function gets the number of bytes that have been received.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer. \\
\hline
{\em count} & Receive bytes count. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+No\+Transfer\+In\+Progress} & No receive in progress. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & Parameter is invalid. \\
\hline
{\em k\+Status\+\_\+\+Success} & Get successfully through the parameter {\ttfamily count};\\
\hline
\end{DoxyRetVals}
brief Gets the number of bytes that have been received.

This function gets the number of bytes that have been received.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. param count Receive bytes count. retval k\+Status\+\_\+\+No\+Transfer\+In\+Progress No receive in progress. retval k\+Status\+\_\+\+Invalid\+Argument Parameter is invalid. retval k\+Status\+\_\+\+Success Get successfully through the parameter {\ttfamily count}; \mbox{\Hypertarget{group__lpuart__driver_ga550523d301acfa413919c2f979228bcc}\label{group__lpuart__driver_ga550523d301acfa413919c2f979228bcc}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferGetRxRingBufferLength@{LPUART\_TransferGetRxRingBufferLength}}
\index{LPUART\_TransferGetRxRingBufferLength@{LPUART\_TransferGetRxRingBufferLength}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferGetRxRingBufferLength()}{LPUART\_TransferGetRxRingBufferLength()}}
{\footnotesize\ttfamily size\+\_\+t L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Get\+Rx\+Ring\+Buffer\+Length (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Get the length of received data in RX ring buffer. 


\begin{DoxyParams}{Parameters}
{\em handle} & L\+P\+U\+A\+RT handle pointer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Length of received data in RX ring buffer.
\end{DoxyReturn}
brief Get the length of received data in RX ring buffer.

user\+Data handle L\+P\+U\+A\+RT handle pointer. return Length of received data in RX ring buffer. \mbox{\Hypertarget{group__lpuart__driver_gad80d2469dce0de9361e731e4cefde9fd}\label{group__lpuart__driver_gad80d2469dce0de9361e731e4cefde9fd}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferGetSendCount@{LPUART\_TransferGetSendCount}}
\index{LPUART\_TransferGetSendCount@{LPUART\_TransferGetSendCount}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferGetSendCount()}{LPUART\_TransferGetSendCount()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Get\+Send\+Count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{uint32\+\_\+t $\ast$}]{count }\end{DoxyParamCaption})}



Gets the number of bytes that have been written to the L\+P\+U\+A\+RT transmitter register. 

This function gets the number of bytes that have been written to L\+P\+U\+A\+RT TX register by an interrupt method.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer. \\
\hline
{\em count} & Send bytes count. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+No\+Transfer\+In\+Progress} & No send in progress. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & Parameter is invalid. \\
\hline
{\em k\+Status\+\_\+\+Success} & Get successfully through the parameter {\ttfamily count};\\
\hline
\end{DoxyRetVals}
brief Gets the number of bytes that have been written to the L\+P\+U\+A\+RT transmitter register.

This function gets the number of bytes that have been written to L\+P\+U\+A\+RT TX register by an interrupt method.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. param count Send bytes count. retval k\+Status\+\_\+\+No\+Transfer\+In\+Progress No send in progress. retval k\+Status\+\_\+\+Invalid\+Argument Parameter is invalid. retval k\+Status\+\_\+\+Success Get successfully through the parameter {\ttfamily count}; \mbox{\Hypertarget{group__lpuart__driver_ga21345340b5d8f90df6bb64acab0f870f}\label{group__lpuart__driver_ga21345340b5d8f90df6bb64acab0f870f}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferHandleErrorIRQ@{LPUART\_TransferHandleErrorIRQ}}
\index{LPUART\_TransferHandleErrorIRQ@{LPUART\_TransferHandleErrorIRQ}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferHandleErrorIRQ()}{LPUART\_TransferHandleErrorIRQ()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Handle\+Error\+I\+RQ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



L\+P\+U\+A\+RT Error I\+RQ handle function. 

This function handles the L\+P\+U\+A\+RT error I\+RQ request.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief L\+P\+U\+A\+RT Error I\+RQ handle function.

This function handles the L\+P\+U\+A\+RT error I\+RQ request.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. \mbox{\Hypertarget{group__lpuart__driver_gac81ce3c490d7185ab7e2d97963ae077e}\label{group__lpuart__driver_gac81ce3c490d7185ab7e2d97963ae077e}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferHandleIRQ@{LPUART\_TransferHandleIRQ}}
\index{LPUART\_TransferHandleIRQ@{LPUART\_TransferHandleIRQ}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferHandleIRQ()}{LPUART\_TransferHandleIRQ()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Handle\+I\+RQ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



L\+P\+U\+A\+RT I\+RQ handle function. 

This function handles the L\+P\+U\+A\+RT transmit and receive I\+RQ request.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief L\+P\+U\+A\+RT I\+RQ handle function.

This function handles the L\+P\+U\+A\+RT transmit and receive I\+RQ request.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. \mbox{\Hypertarget{group__lpuart__driver_ga8bdb584704ce7955004751e32627f918}\label{group__lpuart__driver_ga8bdb584704ce7955004751e32627f918}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferReceiveNonBlocking@{LPUART\_TransferReceiveNonBlocking}}
\index{LPUART\_TransferReceiveNonBlocking@{LPUART\_TransferReceiveNonBlocking}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferReceiveNonBlocking()}{LPUART\_TransferReceiveNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{\mbox{\hyperlink{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}{lpuart\+\_\+transfer\+\_\+t}} $\ast$}]{xfer,  }\item[{size\+\_\+t $\ast$}]{received\+Bytes }\end{DoxyParamCaption})}



Receives a buffer of data using the interrupt method. 

This function receives data using an interrupt method. This is a non-\/blocking function which returns without waiting to ensure that all data are received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter {\ttfamily received\+Bytes} shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough for read, the receive request is saved by the L\+P\+U\+A\+RT driver. When the new data arrives, the receive request is serviced first. When all data is received, the L\+P\+U\+A\+RT driver notifies the upper layer through a callback function and passes a status parameter \mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Idle}}. For example, the upper layer needs 10 bytes but there are only 5 bytes in ring buffer. The 5 bytes are copied to xfer-\/$>$data, which returns with the parameter {\ttfamily received\+Bytes} set to 5. For the remaining 5 bytes, the newly arrived data is saved from xfer-\/$>$data\mbox{[}5\mbox{]}. When 5 bytes are received, the L\+P\+U\+A\+RT driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to xfer-\/$>$data. When all data is received, the upper layer is notified.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer. \\
\hline
{\em xfer} & L\+P\+U\+A\+RT transfer structure, see \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}}. \\
\hline
{\em received\+Bytes} & Bytes received from the ring buffer directly. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+Success} & Successfully queue the transfer into the transmit queue. \\
\hline
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Busy} & Previous receive request is not finished. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & Invalid argument.\\
\hline
\end{DoxyRetVals}
brief Receives a buffer of data using the interrupt method.

This function receives data using an interrupt method. This is a non-\/blocking function which returns without waiting to ensure that all data are received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter p received\+Bytes shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough for read, the receive request is saved by the L\+P\+U\+A\+RT driver. When the new data arrives, the receive request is serviced first. When all data is received, the L\+P\+U\+A\+RT driver notifies the upper layer through a callback function and passes a status parameter ref k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Idle. For example, the upper layer needs 10 bytes but there are only 5 bytes in ring buffer. The 5 bytes are copied to xfer-\/$>$data, which returns with the parameter p received\+Bytes set to 5. For the remaining 5 bytes, the newly arrived data is saved from xfer-\/$>$data\mbox{[}5\mbox{]}. When 5 bytes are received, the L\+P\+U\+A\+RT driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to xfer-\/$>$data. When all data is received, the upper layer is notified.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. param xfer L\+P\+U\+A\+RT transfer structure, see \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}}. param received\+Bytes Bytes received from the ring buffer directly. retval k\+Status\+\_\+\+Success Successfully queue the transfer into the transmit queue. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Rx\+Busy Previous receive request is not finished. retval k\+Status\+\_\+\+Invalid\+Argument Invalid argument. \mbox{\Hypertarget{group__lpuart__driver_gafba986c473e5935131e63cb882cf26ff}\label{group__lpuart__driver_gafba986c473e5935131e63cb882cf26ff}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferSendNonBlocking@{LPUART\_TransferSendNonBlocking}}
\index{LPUART\_TransferSendNonBlocking@{LPUART\_TransferSendNonBlocking}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferSendNonBlocking()}{LPUART\_TransferSendNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Send\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{\mbox{\hyperlink{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}{lpuart\+\_\+transfer\+\_\+t}} $\ast$}]{xfer }\end{DoxyParamCaption})}



Transmits a buffer of data using the interrupt method. 

This function send data using an interrupt method. This is a non-\/blocking function, which returns directly without waiting for all data written to the transmitter register. When all data is written to the TX register in the I\+SR, the L\+P\+U\+A\+RT driver calls the callback function and passes the \mbox{\hyperlink{group__lpuart__driver_gga157d5577a5b2f5986037d0d09c7dc77da079c6d0957d121ce7cd95cf97487dfbb}{k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Idle}} as status parameter.

\begin{DoxyNote}{Note}
The k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Idle is passed to the upper layer when all data are written to the TX register. However, there is no check to ensure that all the data sent out. Before disabling the TX, check the k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag to ensure that the transmit is finished.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer. \\
\hline
{\em xfer} & L\+P\+U\+A\+RT transfer structure, see \mbox{\hyperlink{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}{lpuart\+\_\+transfer\+\_\+t}}. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+Success} & Successfully start the data transmission. \\
\hline
{\em k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Busy} & Previous transmission still not finished, data not all written to the TX register. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & Invalid argument.\\
\hline
\end{DoxyRetVals}
brief Transmits a buffer of data using the interrupt method.

This function send data using an interrupt method. This is a non-\/blocking function, which returns directly without waiting for all data written to the transmitter register. When all data is written to the TX register in the I\+SR, the L\+P\+U\+A\+RT driver calls the callback function and passes the ref k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Idle as status parameter.

note The k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Idle is passed to the upper layer when all data are written to the TX register. However, there is no check to ensure that all the data sent out. Before disabling the TX, check the k\+L\+P\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag to ensure that the transmit is finished.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. param xfer L\+P\+U\+A\+RT transfer structure, see \mbox{\hyperlink{group__lpuart__driver_ga1d4707ebc5d49dd655eedb7e5acd27fd}{lpuart\+\_\+transfer\+\_\+t}}. retval k\+Status\+\_\+\+Success Successfully start the data transmission. retval k\+Status\+\_\+\+L\+P\+U\+A\+R\+T\+\_\+\+Tx\+Busy Previous transmission still not finished, data not all written to the TX register. retval k\+Status\+\_\+\+Invalid\+Argument Invalid argument. \mbox{\Hypertarget{group__lpuart__driver_ga5257b77491042af5913a8d91c66318e1}\label{group__lpuart__driver_ga5257b77491042af5913a8d91c66318e1}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferStartRingBuffer@{LPUART\_TransferStartRingBuffer}}
\index{LPUART\_TransferStartRingBuffer@{LPUART\_TransferStartRingBuffer}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferStartRingBuffer()}{LPUART\_TransferStartRingBuffer()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Start\+Ring\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{uint8\+\_\+t $\ast$}]{ring\+Buffer,  }\item[{size\+\_\+t}]{ring\+Buffer\+Size }\end{DoxyParamCaption})}



Sets up the RX ring buffer. 

This function sets up the RX ring buffer to a specific U\+A\+RT handle.

When the RX ring buffer is used, data received is stored into the ring buffer even when the user doesn\textquotesingle{}t call the \mbox{\hyperlink{group__uart__driver_gaf804acde5d73ce0a5bf54b06195e1218}{U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking()}} A\+PI. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly.

\begin{DoxyNote}{Note}
When using RX ring buffer, one byte is reserved for internal use. In other words, if {\ttfamily ring\+Buffer\+Size} is 32, then only 31 bytes are used for saving data.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer. \\
\hline
{\em ring\+Buffer} & Start address of ring buffer for background receiving. Pass N\+U\+LL to disable the ring buffer. \\
\hline
{\em ring\+Buffer\+Size} & size of the ring buffer.\\
\hline
\end{DoxyParams}
brief Sets up the RX ring buffer.

This function sets up the RX ring buffer to a specific U\+A\+RT handle.

When the RX ring buffer is used, data received is stored into the ring buffer even when the user doesn\textquotesingle{}t call the \mbox{\hyperlink{group__uart__driver_gaf804acde5d73ce0a5bf54b06195e1218}{U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking()}} A\+PI. If there is already data received in the ring buffer, the user can get the received data from the ring buffer directly.

note When using RX ring buffer, one byte is reserved for internal use. In other words, if p ring\+Buffer\+Size is 32, then only 31 bytes are used for saving data.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. param ring\+Buffer Start address of ring buffer for background receiving. Pass N\+U\+LL to disable the ring buffer. param ring\+Buffer\+Size size of the ring buffer. \mbox{\Hypertarget{group__lpuart__driver_gad6a230a664808592aab153ea20e3d60b}\label{group__lpuart__driver_gad6a230a664808592aab153ea20e3d60b}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_TransferStopRingBuffer@{LPUART\_TransferStopRingBuffer}}
\index{LPUART\_TransferStopRingBuffer@{LPUART\_TransferStopRingBuffer}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_TransferStopRingBuffer()}{LPUART\_TransferStopRingBuffer()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Transfer\+Stop\+Ring\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__lpuart__handle}{lpuart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Aborts the background transfer and uninstalls the ring buffer. 

This function aborts the background transfer and uninstalls the ring buffer.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em handle} & L\+P\+U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief Aborts the background transfer and uninstalls the ring buffer.

This function aborts the background transfer and uninstalls the ring buffer.

param base L\+P\+U\+A\+RT peripheral base address. param handle L\+P\+U\+A\+RT handle pointer. \mbox{\Hypertarget{group__lpuart__driver_gac5377aeebf4327f4ef9de295d8695cd9}\label{group__lpuart__driver_gac5377aeebf4327f4ef9de295d8695cd9}} 
\index{Lpuart\_driver@{Lpuart\_driver}!LPUART\_WriteBlocking@{LPUART\_WriteBlocking}}
\index{LPUART\_WriteBlocking@{LPUART\_WriteBlocking}!Lpuart\_driver@{Lpuart\_driver}}
\subsubsection{\texorpdfstring{LPUART\_WriteBlocking()}{LPUART\_WriteBlocking()}}
{\footnotesize\ttfamily void L\+P\+U\+A\+R\+T\+\_\+\+Write\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_l_p_u_a_r_t___type}{L\+P\+U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{const uint8\+\_\+t $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Writes to the transmitter register using a blocking method. 

This function polls the transmitter register, first waits for the register to be empty or TX F\+I\+FO to have room, and writes data to the transmitter buffer, then waits for the dat to be sent out to the bus.


\begin{DoxyParams}{Parameters}
{\em base} & L\+P\+U\+A\+RT peripheral base address. \\
\hline
{\em data} & Start address of the data to write. \\
\hline
{\em length} & Size of the data to write.\\
\hline
\end{DoxyParams}
brief Writes to the transmitter register using a blocking method.

This function polls the transmitter register, first waits for the register to be empty or TX F\+I\+FO to have room, and writes data to the transmitter buffer, then waits for the data to be sent out to bus.

param base L\+P\+U\+A\+RT peripheral base address. param data Start address of the data to write. param length Size of the data to write. 