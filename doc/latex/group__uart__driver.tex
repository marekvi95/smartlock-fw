\hypertarget{group__uart__driver}{}\section{Uart\+\_\+driver}
\label{group__uart__driver}\index{Uart\_driver@{Uart\_driver}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct__uart__config}{\+\_\+uart\+\_\+config}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT configuration structure. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__uart__transfer}{\+\_\+uart\+\_\+transfer}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT transfer structure. \end{DoxyCompactList}\item 
struct \mbox{\hyperlink{struct__uart__handle}{\+\_\+uart\+\_\+handle}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT handle structure. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__uart__driver_ga3d74bf70252b21a0dd19d61587ed320c}\label{group__uart__driver_ga3d74bf70252b21a0dd19d61587ed320c}} 
typedef enum \mbox{\hyperlink{group__uart__driver_gadf9f66755acc340eab030e1a48e35e10}{\+\_\+uart\+\_\+parity\+\_\+mode}} \mbox{\hyperlink{group__uart__driver_ga3d74bf70252b21a0dd19d61587ed320c}{uart\+\_\+parity\+\_\+mode\+\_\+t}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT parity mode. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__uart__driver_ga1df1fcb3fcd2d2db0b7ea0189fd94554}\label{group__uart__driver_ga1df1fcb3fcd2d2db0b7ea0189fd94554}} 
typedef enum \mbox{\hyperlink{group__uart__driver_ga3c656a4365cab1185398ff953272091e}{\+\_\+uart\+\_\+stop\+\_\+bit\+\_\+count}} \mbox{\hyperlink{group__uart__driver_ga1df1fcb3fcd2d2db0b7ea0189fd94554}{uart\+\_\+stop\+\_\+bit\+\_\+count\+\_\+t}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT stop bit count. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__uart__driver_ga9457d04cb0bf9c547babd63a4d20a9fa}\label{group__uart__driver_ga9457d04cb0bf9c547babd63a4d20a9fa}} 
typedef enum \mbox{\hyperlink{group__uart__driver_gae658ead369268edf18141e1903d426f1}{\+\_\+uart\+\_\+idle\+\_\+type\+\_\+select}} \mbox{\hyperlink{group__uart__driver_ga9457d04cb0bf9c547babd63a4d20a9fa}{uart\+\_\+idle\+\_\+type\+\_\+select\+\_\+t}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT idle type select. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__uart__driver_ga032da70848aac8bc9c3904a32bde5899}\label{group__uart__driver_ga032da70848aac8bc9c3904a32bde5899}} 
typedef struct \mbox{\hyperlink{struct__uart__config}{\+\_\+uart\+\_\+config}} \mbox{\hyperlink{group__uart__driver_ga032da70848aac8bc9c3904a32bde5899}{uart\+\_\+config\+\_\+t}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT configuration structure. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__uart__driver_gae245db88e02822f416e4d246d49076df}\label{group__uart__driver_gae245db88e02822f416e4d246d49076df}} 
typedef struct \mbox{\hyperlink{struct__uart__transfer}{\+\_\+uart\+\_\+transfer}} \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}}
\begin{DoxyCompactList}\small\item\em U\+A\+RT transfer structure. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{group__uart__driver_gae4cc0b0d1b32237a516424ff2f60e406}\label{group__uart__driver_gae4cc0b0d1b32237a516424ff2f60e406}} 
typedef struct \mbox{\hyperlink{struct__uart__handle}{\+\_\+uart\+\_\+handle}} {\bfseries uart\+\_\+handle\+\_\+t}
\item 
\mbox{\Hypertarget{group__uart__driver_ga2868b6ea396ab212547f2157380429c5}\label{group__uart__driver_ga2868b6ea396ab212547f2157380429c5}} 
typedef void($\ast$ \mbox{\hyperlink{group__uart__driver_ga2868b6ea396ab212547f2157380429c5}{uart\+\_\+transfer\+\_\+callback\+\_\+t}}) (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} status, void $\ast$user\+Data)
\begin{DoxyCompactList}\small\item\em U\+A\+RT transfer callback function. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{group__uart__driver_gacef40dc8e8ac174bfe40ebcbc980f84b}{\+\_\+uart\+\_\+status}} \{ \newline
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba19ddee4fe5963467600028b78fb468e7}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Busy}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 0), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba68cf23f981c4b85f82291163fbb2a5e6}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Busy}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 1), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baf36c829b1b889517bf775c0d7ce29fa6}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Idle}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 2), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Idle}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 3), 
\newline
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba765913f003819ed87b861d187bf79ab8}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Watermark\+Too\+Large}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 4), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba720cefde05389830f35f6e6df6f6ac67}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Watermark\+Too\+Large}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 5), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba5ee8e23fc9ab20cf366942751b895f54}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually}}, 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba950972a9e2ebbaa13c92e8f5a51f785d}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 7), 
\newline
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba2e5b644b1e10c426af818bc78657e992}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Ring\+Buffer\+Overrun}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 8), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bab6b1fd6c2deec25992449f5b12303a26}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 9), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae4ef4df9a5f756ccf1b4bf08292ec2fb}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Noise\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 10), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baa7aa134f85df3d5863ca962ce1ea7ee0}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Framing\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 11), 
\newline
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baea20b2588c38f259f1412aa7132c9ef8}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Parity\+Error}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 12), 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae6cdb41e1b49958f57727cd47afd69b2}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support}}, 
\mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba3e5b488f7ed418cb08399a5db193103e}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Detected}} = M\+A\+K\+E\+\_\+\+S\+T\+A\+T\+US(k\+Status\+Group\+\_\+\+U\+A\+RT, 14)
 \}
\begin{DoxyCompactList}\small\item\em Error codes for the U\+A\+RT driver. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__uart__driver_gadf9f66755acc340eab030e1a48e35e10}{\+\_\+uart\+\_\+parity\+\_\+mode}} \{ \mbox{\hyperlink{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10a97e2feae6671a6de1126ebc2edf4606b}{k\+U\+A\+R\+T\+\_\+\+Parity\+Disabled}} = 0x0U, 
\mbox{\hyperlink{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10a9e68fe3aba46e045bee5433ed098bff0}{k\+U\+A\+R\+T\+\_\+\+Parity\+Even}} = 0x2U, 
\mbox{\hyperlink{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10ae48c7fabc9babf1be626ebeb2627a54c}{k\+U\+A\+R\+T\+\_\+\+Parity\+Odd}} = 0x3U
 \}
\begin{DoxyCompactList}\small\item\em U\+A\+RT parity mode. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__uart__driver_ga3c656a4365cab1185398ff953272091e}{\+\_\+uart\+\_\+stop\+\_\+bit\+\_\+count}} \{ \mbox{\hyperlink{group__uart__driver_gga3c656a4365cab1185398ff953272091ea5a8829a108d8a46abb097a36cde051a7}{k\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit}} = 0U, 
\mbox{\hyperlink{group__uart__driver_gga3c656a4365cab1185398ff953272091ea9704b3ae3ee851acf324eb357f75ab56}{k\+U\+A\+R\+T\+\_\+\+Two\+Stop\+Bit}} = 1U
 \}
\begin{DoxyCompactList}\small\item\em U\+A\+RT stop bit count. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__uart__driver_gae658ead369268edf18141e1903d426f1}{\+\_\+uart\+\_\+idle\+\_\+type\+\_\+select}} \{ \mbox{\hyperlink{group__uart__driver_ggae658ead369268edf18141e1903d426f1a5216f34232b8d01cdd8db1ca01072901}{k\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit}} = 0U, 
\mbox{\hyperlink{group__uart__driver_ggae658ead369268edf18141e1903d426f1a05771d6cd97e160c6a47d5871d2de013}{k\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Stop\+Bit}} = 1U
 \}
\begin{DoxyCompactList}\small\item\em U\+A\+RT idle type select. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}} \{ \newline
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca71755319c216d0bdf79729c18c24cf64}{k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+B\+D\+H\+\_\+\+R\+X\+E\+D\+G\+I\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14}{k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C2\+\_\+\+T\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 8), 
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cafd337213dae85b532dfaf9a90e2e5d7b}{k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C2\+\_\+\+T\+C\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 8), 
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3}{k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C2\+\_\+\+R\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 8), 
\newline
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca078ea32d8587f92337a3dee495a1ceed}{k\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C2\+\_\+\+I\+L\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 8), 
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca3e85b14c1b64dbfef1d0b4b7bc39c19d}{k\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C3\+\_\+\+O\+R\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 16), 
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca53d0fe2bb0cd90198c632f08488af4b3}{k\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C3\+\_\+\+N\+E\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 16), 
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca00a387446d0ca7fd843968eca8af22a5}{k\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C3\+\_\+\+F\+E\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 16), 
\newline
\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cadc2475fa65313c6f1d13b36f0443b20a}{k\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Interrupt\+Enable}} = (U\+A\+R\+T\+\_\+\+C3\+\_\+\+P\+E\+I\+E\+\_\+\+M\+A\+SK $<$$<$ 16), 
{\bfseries k\+U\+A\+R\+T\+\_\+\+All\+Interrupts\+Enable}
 \}
\begin{DoxyCompactList}\small\item\em U\+A\+RT interrupt configuration structure, default settings all disabled. \end{DoxyCompactList}\item 
enum \mbox{\hyperlink{group__uart__driver_ga259a53f363288115306a45d08fc66eb8}{\+\_\+uart\+\_\+flags}} \{ \newline
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a5209c671b2f2f064dc512655387e9e1a}{k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+T\+D\+R\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a4468b60b2d78c34b93c9199df9e95d3a}{k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+T\+C\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8aa86a34b2ea609eeeb63f98fea498e540}{k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+R\+D\+R\+F\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8ab2fc4e1b1164ed3e3fe7e19a39029b2c}{k\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+I\+D\+L\+E\+\_\+\+M\+A\+SK), 
\newline
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a93d3c56466b4656dcce08d9323d7afd8}{k\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+O\+R\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8abd56419f102fb01c7bbc2c38f81ab360}{k\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+N\+F\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8aade5071fa56646adcda3562051443868}{k\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+F\+E\+\_\+\+M\+A\+SK), 
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a0c92973ab1d527115fa01934c62a053d}{k\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Flag}} = (U\+A\+R\+T\+\_\+\+S1\+\_\+\+P\+F\+\_\+\+M\+A\+SK), 
\newline
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8adcfe89feb164ff5b1720312922006a7a}{k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Flag}}, 
\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a7a4521cd44a3272a94784670d1bf5a0c}{k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag}}
 \}
\begin{DoxyCompactList}\small\item\em U\+A\+RT status flags. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \mbox{\hyperlink{group__uart__driver_gadeeb40cdc314638d4355ef906f1c408d}{U\+A\+R\+T\+\_\+\+Get\+Instance}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Get the U\+A\+RT instance from peripheral base address. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Driver version}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{group__uart__driver_ga89f9649bfe350eb7b1e53146f35d3de5}\label{group__uart__driver_ga89f9649bfe350eb7b1e53146f35d3de5}} 
\#define \mbox{\hyperlink{group__uart__driver_ga89f9649bfe350eb7b1e53146f35d3de5}{F\+S\+L\+\_\+\+U\+A\+R\+T\+\_\+\+D\+R\+I\+V\+E\+R\+\_\+\+V\+E\+R\+S\+I\+ON}}~(\mbox{\hyperlink{group__ftfx__utilities_ga812138aa3315b0c6953c1a26130bcc37}{M\+A\+K\+E\+\_\+\+V\+E\+R\+S\+I\+ON}}(2, 1, 7))
\begin{DoxyCompactList}\small\item\em U\+A\+RT driver version 2.\+1.\+7. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Initialization and deinitialization}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_gab5965a8e11f7e1d4d531141291fd5288}{U\+A\+R\+T\+\_\+\+Init}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, const \mbox{\hyperlink{group__uart__driver_ga032da70848aac8bc9c3904a32bde5899}{uart\+\_\+config\+\_\+t}} $\ast$config, uint32\+\_\+t src\+Clock\+\_\+\+Hz)
\begin{DoxyCompactList}\small\item\em Initializes a U\+A\+RT instance with a user configuration structure and peripheral clock. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_ga3ff48bc211831be33e6fe5c50eb671a0}{U\+A\+R\+T\+\_\+\+Deinit}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Deinitializes a U\+A\+RT instance. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_ga47c7c09e04a0497f4530d553e27d96c5}{U\+A\+R\+T\+\_\+\+Get\+Default\+Config}} (\mbox{\hyperlink{group__uart__driver_ga032da70848aac8bc9c3904a32bde5899}{uart\+\_\+config\+\_\+t}} $\ast$config)
\begin{DoxyCompactList}\small\item\em Gets the default configuration structure. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_gab3ba5019c11f288cc4f545dd656b6284}{U\+A\+R\+T\+\_\+\+Set\+Baud\+Rate}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t baud\+Rate\+\_\+\+Bps, uint32\+\_\+t src\+Clock\+\_\+\+Hz)
\begin{DoxyCompactList}\small\item\em Sets the U\+A\+RT instance baud rate. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Status}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t \mbox{\hyperlink{group__uart__driver_ga28bf715678c0d3c8c3902e79455ee923}{U\+A\+R\+T\+\_\+\+Get\+Status\+Flags}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Gets U\+A\+RT status flags. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_gacc4cb85534361f836edca9454a6426c6}{U\+A\+R\+T\+\_\+\+Clear\+Status\+Flags}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t mask)
\begin{DoxyCompactList}\small\item\em Clears status flags with the provided mask. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Interrupts}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__uart__driver_ga49ecd761481a22956e3f46285038719c}{U\+A\+R\+T\+\_\+\+Enable\+Interrupts}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t mask)
\begin{DoxyCompactList}\small\item\em Enables U\+A\+RT interrupts according to the provided mask. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_ga3f24b6b9b730046a9a81918f9abe7d99}{U\+A\+R\+T\+\_\+\+Disable\+Interrupts}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint32\+\_\+t mask)
\begin{DoxyCompactList}\small\item\em Disables the U\+A\+RT interrupts according to the provided mask. \end{DoxyCompactList}\item 
uint32\+\_\+t \mbox{\hyperlink{group__uart__driver_ga79bc0b880286ec0dc0543606fc772912}{U\+A\+R\+T\+\_\+\+Get\+Enabled\+Interrupts}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base)
\begin{DoxyCompactList}\small\item\em Gets the enabled U\+A\+RT interrupts. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Bus Operations}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__uart__driver_gad67794d80b7ee2d3292b41af6ff1e100}{U\+A\+R\+T\+\_\+\+Write\+Blocking}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, const uint8\+\_\+t $\ast$data, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em Writes to the TX register using a blocking method. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_ga39d59e8a94f1af451a0db81888596639}{U\+A\+R\+T\+\_\+\+Read\+Blocking}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, uint8\+\_\+t $\ast$data, size\+\_\+t length)
\begin{DoxyCompactList}\small\item\em Read RX data register using a blocking method. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Transactional}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{group__uart__driver_ga63db308c32019b7dd6c0647d618e5247}{U\+A\+R\+T\+\_\+\+Transfer\+Create\+Handle}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__uart__driver_ga2868b6ea396ab212547f2157380429c5}{uart\+\_\+transfer\+\_\+callback\+\_\+t}} callback, void $\ast$user\+Data)
\begin{DoxyCompactList}\small\item\em Initializes the U\+A\+RT handle. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_ga223fba584bfabd599629d5ce92f929ac}{U\+A\+R\+T\+\_\+\+Transfer\+Start\+Ring\+Buffer}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle, uint8\+\_\+t $\ast$ring\+Buffer, size\+\_\+t ring\+Buffer\+Size)
\begin{DoxyCompactList}\small\item\em Sets up the RX ring buffer. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_ga0c0bc73df49cb31dff0e903630314f5b}{U\+A\+R\+T\+\_\+\+Transfer\+Stop\+Ring\+Buffer}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Aborts the background transfer and uninstalls the ring buffer. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{group__uart__driver_ga3921aa660977ca77dadf95fa35f1c3a9}{U\+A\+R\+T\+\_\+\+Transfer\+Get\+Rx\+Ring\+Buffer\+Length}} (\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Get the length of received data in RX ring buffer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_gad89afd7db1656c5aef404bb285d0dc05}{U\+A\+R\+T\+\_\+\+Transfer\+Send\+Non\+Blocking}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}} $\ast$xfer)
\begin{DoxyCompactList}\small\item\em Transmits a buffer of data using the interrupt method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_gaa64f9f89d8286fd3ef0736a8c40be2c2}{U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Send}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Aborts the interrupt-\/driven data transmit. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_ga071727ba05b2937ef5ad641ca7faf9c7}{U\+A\+R\+T\+\_\+\+Transfer\+Get\+Send\+Count}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle, uint32\+\_\+t $\ast$count)
\begin{DoxyCompactList}\small\item\em Gets the number of bytes written to the U\+A\+RT TX register. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_gaf804acde5d73ce0a5bf54b06195e1218}{U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle, \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}} $\ast$xfer, size\+\_\+t $\ast$received\+Bytes)
\begin{DoxyCompactList}\small\item\em Receives a buffer of data using an interrupt method. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_gacc35671622b2401545cc55cc6ae572d4}{U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Receive}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em Aborts the interrupt-\/driven data receiving. \end{DoxyCompactList}\item 
\mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} \mbox{\hyperlink{group__uart__driver_ga05df10f570cdca4ac2dff63b069d254e}{U\+A\+R\+T\+\_\+\+Transfer\+Get\+Receive\+Count}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle, uint32\+\_\+t $\ast$count)
\begin{DoxyCompactList}\small\item\em Gets the number of bytes that have been received. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_gadb0c4f1e5b59db3aa2261df4f5ddb48d}{U\+A\+R\+T\+\_\+\+Transfer\+Handle\+I\+RQ}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em U\+A\+RT I\+RQ handle function. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__uart__driver_gafc364352e879f53138ee1107e3da0a7d}{U\+A\+R\+T\+\_\+\+Transfer\+Handle\+Error\+I\+RQ}} (\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$base, \mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$handle)
\begin{DoxyCompactList}\small\item\em U\+A\+RT Error I\+RQ handle function. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Enumeration Type Documentation}
\mbox{\Hypertarget{group__uart__driver_ga259a53f363288115306a45d08fc66eb8}\label{group__uart__driver_ga259a53f363288115306a45d08fc66eb8}} 
\index{Uart\_driver@{Uart\_driver}!\_uart\_flags@{\_uart\_flags}}
\index{\_uart\_flags@{\_uart\_flags}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{\_uart\_flags}{\_uart\_flags}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__uart__driver_ga259a53f363288115306a45d08fc66eb8}{\+\_\+uart\+\_\+flags}}}



U\+A\+RT status flags. 

This provides constants for the U\+A\+RT status flags for use in the U\+A\+RT functions. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_TxDataRegEmptyFlag@{kUART\_TxDataRegEmptyFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_TxDataRegEmptyFlag@{kUART\_TxDataRegEmptyFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a5209c671b2f2f064dc512655387e9e1a}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a5209c671b2f2f064dc512655387e9e1a}} 
k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag&TX data register empty flag. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_TransmissionCompleteFlag@{kUART\_TransmissionCompleteFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_TransmissionCompleteFlag@{kUART\_TransmissionCompleteFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a4468b60b2d78c34b93c9199df9e95d3a}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a4468b60b2d78c34b93c9199df9e95d3a}} 
k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag&Transmission complete flag. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_RxDataRegFullFlag@{kUART\_RxDataRegFullFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_RxDataRegFullFlag@{kUART\_RxDataRegFullFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8aa86a34b2ea609eeeb63f98fea498e540}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8aa86a34b2ea609eeeb63f98fea498e540}} 
k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag&RX data register full flag. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_IdleLineFlag@{kUART\_IdleLineFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_IdleLineFlag@{kUART\_IdleLineFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8ab2fc4e1b1164ed3e3fe7e19a39029b2c}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8ab2fc4e1b1164ed3e3fe7e19a39029b2c}} 
k\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Flag&Idle line detect flag. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_RxOverrunFlag@{kUART\_RxOverrunFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_RxOverrunFlag@{kUART\_RxOverrunFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a93d3c56466b4656dcce08d9323d7afd8}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a93d3c56466b4656dcce08d9323d7afd8}} 
k\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Flag&RX overrun flag. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_NoiseErrorFlag@{kUART\_NoiseErrorFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_NoiseErrorFlag@{kUART\_NoiseErrorFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8abd56419f102fb01c7bbc2c38f81ab360}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8abd56419f102fb01c7bbc2c38f81ab360}} 
k\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Flag&RX takes 3 samples of each received bit. If any of these samples differ, noise flag sets \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_FramingErrorFlag@{kUART\_FramingErrorFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_FramingErrorFlag@{kUART\_FramingErrorFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8aade5071fa56646adcda3562051443868}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8aade5071fa56646adcda3562051443868}} 
k\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Flag&Frame error flag, sets if logic 0 was detected where stop bit expected \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_ParityErrorFlag@{kUART\_ParityErrorFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_ParityErrorFlag@{kUART\_ParityErrorFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a0c92973ab1d527115fa01934c62a053d}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a0c92973ab1d527115fa01934c62a053d}} 
k\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Flag&If parity enabled, sets upon parity error detection \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_RxActiveEdgeFlag@{kUART\_RxActiveEdgeFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_RxActiveEdgeFlag@{kUART\_RxActiveEdgeFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8adcfe89feb164ff5b1720312922006a7a}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8adcfe89feb164ff5b1720312922006a7a}} 
k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Flag&RX pin active edge interrupt flag,sets when active edge detected \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_RxActiveFlag@{kUART\_RxActiveFlag}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_RxActiveFlag@{kUART\_RxActiveFlag}}}\mbox{\Hypertarget{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a7a4521cd44a3272a94784670d1bf5a0c}\label{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a7a4521cd44a3272a94784670d1bf5a0c}} 
k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag&Receiver Active Flag (R\+AF), sets at beginning of valid start bit \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__uart__driver_gae658ead369268edf18141e1903d426f1}\label{group__uart__driver_gae658ead369268edf18141e1903d426f1}} 
\index{Uart\_driver@{Uart\_driver}!\_uart\_idle\_type\_select@{\_uart\_idle\_type\_select}}
\index{\_uart\_idle\_type\_select@{\_uart\_idle\_type\_select}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{\_uart\_idle\_type\_select}{\_uart\_idle\_type\_select}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__uart__driver_gae658ead369268edf18141e1903d426f1}{\+\_\+uart\+\_\+idle\+\_\+type\+\_\+select}}}



U\+A\+RT idle type select. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_IdleTypeStartBit@{kUART\_IdleTypeStartBit}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_IdleTypeStartBit@{kUART\_IdleTypeStartBit}}}\mbox{\Hypertarget{group__uart__driver_ggae658ead369268edf18141e1903d426f1a5216f34232b8d01cdd8db1ca01072901}\label{group__uart__driver_ggae658ead369268edf18141e1903d426f1a5216f34232b8d01cdd8db1ca01072901}} 
k\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit&Start counting after a valid start bit. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_IdleTypeStopBit@{kUART\_IdleTypeStopBit}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_IdleTypeStopBit@{kUART\_IdleTypeStopBit}}}\mbox{\Hypertarget{group__uart__driver_ggae658ead369268edf18141e1903d426f1a05771d6cd97e160c6a47d5871d2de013}\label{group__uart__driver_ggae658ead369268edf18141e1903d426f1a05771d6cd97e160c6a47d5871d2de013}} 
k\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Stop\+Bit&Start counting after a stop bit. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}\label{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}} 
\index{Uart\_driver@{Uart\_driver}!\_uart\_interrupt\_enable@{\_uart\_interrupt\_enable}}
\index{\_uart\_interrupt\_enable@{\_uart\_interrupt\_enable}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{\_uart\_interrupt\_enable}{\_uart\_interrupt\_enable}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}}



U\+A\+RT interrupt configuration structure, default settings all disabled. 

This structure contains the settings for all of the U\+A\+RT interrupt configurations. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_RxActiveEdgeInterruptEnable@{kUART\_RxActiveEdgeInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_RxActiveEdgeInterruptEnable@{kUART\_RxActiveEdgeInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca71755319c216d0bdf79729c18c24cf64}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca71755319c216d0bdf79729c18c24cf64}} 
k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Edge\+Interrupt\+Enable&RX active edge interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_TxDataRegEmptyInterruptEnable@{kUART\_TxDataRegEmptyInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_TxDataRegEmptyInterruptEnable@{kUART\_TxDataRegEmptyInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14}} 
k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable&Transmit data register empty interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_TransmissionCompleteInterruptEnable@{kUART\_TransmissionCompleteInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_TransmissionCompleteInterruptEnable@{kUART\_TransmissionCompleteInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cafd337213dae85b532dfaf9a90e2e5d7b}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cafd337213dae85b532dfaf9a90e2e5d7b}} 
k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Interrupt\+Enable&Transmission complete interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_RxDataRegFullInterruptEnable@{kUART\_RxDataRegFullInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_RxDataRegFullInterruptEnable@{kUART\_RxDataRegFullInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3}} 
k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable&Receiver data register full interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_IdleLineInterruptEnable@{kUART\_IdleLineInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_IdleLineInterruptEnable@{kUART\_IdleLineInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca078ea32d8587f92337a3dee495a1ceed}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca078ea32d8587f92337a3dee495a1ceed}} 
k\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Interrupt\+Enable&Idle line interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_RxOverrunInterruptEnable@{kUART\_RxOverrunInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_RxOverrunInterruptEnable@{kUART\_RxOverrunInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca3e85b14c1b64dbfef1d0b4b7bc39c19d}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca3e85b14c1b64dbfef1d0b4b7bc39c19d}} 
k\+U\+A\+R\+T\+\_\+\+Rx\+Overrun\+Interrupt\+Enable&Receiver overrun interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_NoiseErrorInterruptEnable@{kUART\_NoiseErrorInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_NoiseErrorInterruptEnable@{kUART\_NoiseErrorInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca53d0fe2bb0cd90198c632f08488af4b3}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca53d0fe2bb0cd90198c632f08488af4b3}} 
k\+U\+A\+R\+T\+\_\+\+Noise\+Error\+Interrupt\+Enable&Noise error flag interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_FramingErrorInterruptEnable@{kUART\_FramingErrorInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_FramingErrorInterruptEnable@{kUART\_FramingErrorInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca00a387446d0ca7fd843968eca8af22a5}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca00a387446d0ca7fd843968eca8af22a5}} 
k\+U\+A\+R\+T\+\_\+\+Framing\+Error\+Interrupt\+Enable&Framing error flag interrupt. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_ParityErrorInterruptEnable@{kUART\_ParityErrorInterruptEnable}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_ParityErrorInterruptEnable@{kUART\_ParityErrorInterruptEnable}}}\mbox{\Hypertarget{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cadc2475fa65313c6f1d13b36f0443b20a}\label{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cadc2475fa65313c6f1d13b36f0443b20a}} 
k\+U\+A\+R\+T\+\_\+\+Parity\+Error\+Interrupt\+Enable&Parity error flag interrupt. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__uart__driver_gadf9f66755acc340eab030e1a48e35e10}\label{group__uart__driver_gadf9f66755acc340eab030e1a48e35e10}} 
\index{Uart\_driver@{Uart\_driver}!\_uart\_parity\_mode@{\_uart\_parity\_mode}}
\index{\_uart\_parity\_mode@{\_uart\_parity\_mode}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{\_uart\_parity\_mode}{\_uart\_parity\_mode}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__uart__driver_gadf9f66755acc340eab030e1a48e35e10}{\+\_\+uart\+\_\+parity\+\_\+mode}}}



U\+A\+RT parity mode. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_ParityDisabled@{kUART\_ParityDisabled}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_ParityDisabled@{kUART\_ParityDisabled}}}\mbox{\Hypertarget{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10a97e2feae6671a6de1126ebc2edf4606b}\label{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10a97e2feae6671a6de1126ebc2edf4606b}} 
k\+U\+A\+R\+T\+\_\+\+Parity\+Disabled&Parity disabled \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_ParityEven@{kUART\_ParityEven}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_ParityEven@{kUART\_ParityEven}}}\mbox{\Hypertarget{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10a9e68fe3aba46e045bee5433ed098bff0}\label{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10a9e68fe3aba46e045bee5433ed098bff0}} 
k\+U\+A\+R\+T\+\_\+\+Parity\+Even&Parity enabled, type even, bit setting\+: P\+E$\vert$\+PT = 10 \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_ParityOdd@{kUART\_ParityOdd}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_ParityOdd@{kUART\_ParityOdd}}}\mbox{\Hypertarget{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10ae48c7fabc9babf1be626ebeb2627a54c}\label{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10ae48c7fabc9babf1be626ebeb2627a54c}} 
k\+U\+A\+R\+T\+\_\+\+Parity\+Odd&Parity enabled, type odd, bit setting\+: P\+E$\vert$\+PT = 11 \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__uart__driver_gacef40dc8e8ac174bfe40ebcbc980f84b}\label{group__uart__driver_gacef40dc8e8ac174bfe40ebcbc980f84b}} 
\index{Uart\_driver@{Uart\_driver}!\_uart\_status@{\_uart\_status}}
\index{\_uart\_status@{\_uart\_status}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{\_uart\_status}{\_uart\_status}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__uart__driver_gacef40dc8e8ac174bfe40ebcbc980f84b}{\+\_\+uart\+\_\+status}}}



Error codes for the U\+A\+RT driver. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_TxBusy@{kStatus\_UART\_TxBusy}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_TxBusy@{kStatus\_UART\_TxBusy}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba19ddee4fe5963467600028b78fb468e7}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba19ddee4fe5963467600028b78fb468e7}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Busy&Transmitter is busy. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_RxBusy@{kStatus\_UART\_RxBusy}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_RxBusy@{kStatus\_UART\_RxBusy}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba68cf23f981c4b85f82291163fbb2a5e6}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba68cf23f981c4b85f82291163fbb2a5e6}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Busy&Receiver is busy. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_TxIdle@{kStatus\_UART\_TxIdle}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_TxIdle@{kStatus\_UART\_TxIdle}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baf36c829b1b889517bf775c0d7ce29fa6}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baf36c829b1b889517bf775c0d7ce29fa6}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Idle&U\+A\+RT transmitter is idle. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_RxIdle@{kStatus\_UART\_RxIdle}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_RxIdle@{kStatus\_UART\_RxIdle}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Idle&U\+A\+RT receiver is idle. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_TxWatermarkTooLarge@{kStatus\_UART\_TxWatermarkTooLarge}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_TxWatermarkTooLarge@{kStatus\_UART\_TxWatermarkTooLarge}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba765913f003819ed87b861d187bf79ab8}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba765913f003819ed87b861d187bf79ab8}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Watermark\+Too\+Large&TX F\+I\+FO watermark too large \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_RxWatermarkTooLarge@{kStatus\_UART\_RxWatermarkTooLarge}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_RxWatermarkTooLarge@{kStatus\_UART\_RxWatermarkTooLarge}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba720cefde05389830f35f6e6df6f6ac67}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba720cefde05389830f35f6e6df6f6ac67}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Watermark\+Too\+Large&RX F\+I\+FO watermark too large \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_FlagCannotClearManually@{kStatus\_UART\_FlagCannotClearManually}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_FlagCannotClearManually@{kStatus\_UART\_FlagCannotClearManually}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba5ee8e23fc9ab20cf366942751b895f54}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba5ee8e23fc9ab20cf366942751b895f54}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually&U\+A\+RT flag can\textquotesingle{}t be manually cleared. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_Error@{kStatus\_UART\_Error}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_Error@{kStatus\_UART\_Error}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba950972a9e2ebbaa13c92e8f5a51f785d}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba950972a9e2ebbaa13c92e8f5a51f785d}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Error&Error happens on U\+A\+RT. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_RxRingBufferOverrun@{kStatus\_UART\_RxRingBufferOverrun}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_RxRingBufferOverrun@{kStatus\_UART\_RxRingBufferOverrun}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba2e5b644b1e10c426af818bc78657e992}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba2e5b644b1e10c426af818bc78657e992}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Ring\+Buffer\+Overrun&U\+A\+RT RX software ring buffer overrun. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_RxHardwareOverrun@{kStatus\_UART\_RxHardwareOverrun}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_RxHardwareOverrun@{kStatus\_UART\_RxHardwareOverrun}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bab6b1fd6c2deec25992449f5b12303a26}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bab6b1fd6c2deec25992449f5b12303a26}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun&U\+A\+RT RX receiver overrun. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_NoiseError@{kStatus\_UART\_NoiseError}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_NoiseError@{kStatus\_UART\_NoiseError}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae4ef4df9a5f756ccf1b4bf08292ec2fb}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae4ef4df9a5f756ccf1b4bf08292ec2fb}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Noise\+Error&U\+A\+RT noise error. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_FramingError@{kStatus\_UART\_FramingError}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_FramingError@{kStatus\_UART\_FramingError}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baa7aa134f85df3d5863ca962ce1ea7ee0}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baa7aa134f85df3d5863ca962ce1ea7ee0}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Framing\+Error&U\+A\+RT framing error. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_ParityError@{kStatus\_UART\_ParityError}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_ParityError@{kStatus\_UART\_ParityError}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baea20b2588c38f259f1412aa7132c9ef8}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baea20b2588c38f259f1412aa7132c9ef8}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Parity\+Error&U\+A\+RT parity error. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_BaudrateNotSupport@{kStatus\_UART\_BaudrateNotSupport}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_BaudrateNotSupport@{kStatus\_UART\_BaudrateNotSupport}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae6cdb41e1b49958f57727cd47afd69b2}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae6cdb41e1b49958f57727cd47afd69b2}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support&Baudrate is not support in current clock source \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kStatus\_UART\_IdleLineDetected@{kStatus\_UART\_IdleLineDetected}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kStatus\_UART\_IdleLineDetected@{kStatus\_UART\_IdleLineDetected}}}\mbox{\Hypertarget{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba3e5b488f7ed418cb08399a5db193103e}\label{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84ba3e5b488f7ed418cb08399a5db193103e}} 
k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Idle\+Line\+Detected&U\+A\+RT I\+D\+LE line detected. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{group__uart__driver_ga3c656a4365cab1185398ff953272091e}\label{group__uart__driver_ga3c656a4365cab1185398ff953272091e}} 
\index{Uart\_driver@{Uart\_driver}!\_uart\_stop\_bit\_count@{\_uart\_stop\_bit\_count}}
\index{\_uart\_stop\_bit\_count@{\_uart\_stop\_bit\_count}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{\_uart\_stop\_bit\_count}{\_uart\_stop\_bit\_count}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__uart__driver_ga3c656a4365cab1185398ff953272091e}{\+\_\+uart\+\_\+stop\+\_\+bit\+\_\+count}}}



U\+A\+RT stop bit count. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_OneStopBit@{kUART\_OneStopBit}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_OneStopBit@{kUART\_OneStopBit}}}\mbox{\Hypertarget{group__uart__driver_gga3c656a4365cab1185398ff953272091ea5a8829a108d8a46abb097a36cde051a7}\label{group__uart__driver_gga3c656a4365cab1185398ff953272091ea5a8829a108d8a46abb097a36cde051a7}} 
k\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit&One stop bit \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUART\_TwoStopBit@{kUART\_TwoStopBit}!Uart\_driver@{Uart\_driver}}\index{Uart\_driver@{Uart\_driver}!kUART\_TwoStopBit@{kUART\_TwoStopBit}}}\mbox{\Hypertarget{group__uart__driver_gga3c656a4365cab1185398ff953272091ea9704b3ae3ee851acf324eb357f75ab56}\label{group__uart__driver_gga3c656a4365cab1185398ff953272091ea9704b3ae3ee851acf324eb357f75ab56}} 
k\+U\+A\+R\+T\+\_\+\+Two\+Stop\+Bit&Two stop bits \\
\hline

\end{DoxyEnumFields}


\subsection{Function Documentation}
\mbox{\Hypertarget{group__uart__driver_gacc4cb85534361f836edca9454a6426c6}\label{group__uart__driver_gacc4cb85534361f836edca9454a6426c6}} 
\index{Uart\_driver@{Uart\_driver}!UART\_ClearStatusFlags@{UART\_ClearStatusFlags}}
\index{UART\_ClearStatusFlags@{UART\_ClearStatusFlags}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_ClearStatusFlags()}{UART\_ClearStatusFlags()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Clear\+Status\+Flags (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{mask }\end{DoxyParamCaption})}



Clears status flags with the provided mask. 

This function clears U\+A\+RT status flags with a provided mask. An automatically cleared flag can\textquotesingle{}t be cleared by this function. These flags can only be cleared or set by hardware. k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag, k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag, k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag, k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag, k\+U\+A\+R\+T\+\_\+\+Noise\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+U\+A\+R\+T\+\_\+\+Parity\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+U\+A\+R\+T\+\_\+\+Tx\+Fifo\+Empty\+Flag,k\+U\+A\+R\+T\+\_\+\+Rx\+Fifo\+Empty\+Flag Note that this A\+PI should be called when the Tx/\+Rx is idle. Otherwise it has no effect.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em mask} & The status flags to be cleared; it is logical OR value of \mbox{\hyperlink{group__uart__driver_ga259a53f363288115306a45d08fc66eb8}{\+\_\+uart\+\_\+flags}}. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually} & The flag can\textquotesingle{}t be cleared by this function but it is cleared automatically by hardware. \\
\hline
{\em k\+Status\+\_\+\+Success} & Status in the mask is cleared.\\
\hline
\end{DoxyRetVals}
brief Clears status flags with the provided mask.

This function clears U\+A\+RT status flags with a provided mask. An automatically cleared flag can\textquotesingle{}t be cleared by this function. These flags can only be cleared or set by hardware. k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag, k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag, k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Flag, k\+U\+A\+R\+T\+\_\+\+Rx\+Active\+Flag, k\+U\+A\+R\+T\+\_\+\+Noise\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+U\+A\+R\+T\+\_\+\+Parity\+Error\+In\+Rx\+Data\+Reg\+Flag, k\+U\+A\+R\+T\+\_\+\+Tx\+Fifo\+Empty\+Flag,k\+U\+A\+R\+T\+\_\+\+Rx\+Fifo\+Empty\+Flag Note that this A\+PI should be called when the Tx/\+Rx is idle. Otherwise it has no effect.

param base U\+A\+RT peripheral base address. param mask The status flags to be cleared; it is logical OR value of ref \+\_\+uart\+\_\+flags. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Flag\+Cannot\+Clear\+Manually The flag can\textquotesingle{}t be cleared by this function but it is cleared automatically by hardware. retval k\+Status\+\_\+\+Success Status in the mask is cleared. \mbox{\Hypertarget{group__uart__driver_ga3ff48bc211831be33e6fe5c50eb671a0}\label{group__uart__driver_ga3ff48bc211831be33e6fe5c50eb671a0}} 
\index{Uart\_driver@{Uart\_driver}!UART\_Deinit@{UART\_Deinit}}
\index{UART\_Deinit@{UART\_Deinit}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_Deinit()}{UART\_Deinit()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Deinit (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Deinitializes a U\+A\+RT instance. 

This function waits for TX complete, disables TX and RX, and disables the U\+A\+RT clock.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address.\\
\hline
\end{DoxyParams}
brief Deinitializes a U\+A\+RT instance.

This function waits for TX complete, disables TX and RX, and disables the U\+A\+RT clock.

param base U\+A\+RT peripheral base address. \mbox{\Hypertarget{group__uart__driver_ga3f24b6b9b730046a9a81918f9abe7d99}\label{group__uart__driver_ga3f24b6b9b730046a9a81918f9abe7d99}} 
\index{Uart\_driver@{Uart\_driver}!UART\_DisableInterrupts@{UART\_DisableInterrupts}}
\index{UART\_DisableInterrupts@{UART\_DisableInterrupts}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_DisableInterrupts()}{UART\_DisableInterrupts()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Disable\+Interrupts (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{mask }\end{DoxyParamCaption})}



Disables the U\+A\+RT interrupts according to the provided mask. 

This function disables the U\+A\+RT interrupts according to the provided mask. The mask is a logical OR of enumeration members. See \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}. For example, to disable TX empty interrupt and RX full interrupt do the following. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__uart__driver_ga3f24b6b9b730046a9a81918f9abe7d99}{UART\_DisableInterrupts}}(UART1,\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14}{kUART\_TxDataRegEmptyInterruptEnable}} | \mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3}{kUART\_RxDataRegFullInterruptEnable}});}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em mask} & The interrupts to disable. Logical OR of \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}.\\
\hline
\end{DoxyParams}
brief Disables the U\+A\+RT interrupts according to the provided mask.

This function disables the U\+A\+RT interrupts according to the provided mask. The mask is a logical OR of enumeration members. See ref \+\_\+uart\+\_\+interrupt\+\_\+enable. For example, to disable TX empty interrupt and RX full interrupt do the following. code U\+A\+R\+T\+\_\+\+Disable\+Interrupts(U\+A\+R\+T1,k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable $\vert$ k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable); endcode

param base U\+A\+RT peripheral base address. param mask The interrupts to disable. Logical OR of ref \+\_\+uart\+\_\+interrupt\+\_\+enable. \mbox{\Hypertarget{group__uart__driver_ga49ecd761481a22956e3f46285038719c}\label{group__uart__driver_ga49ecd761481a22956e3f46285038719c}} 
\index{Uart\_driver@{Uart\_driver}!UART\_EnableInterrupts@{UART\_EnableInterrupts}}
\index{UART\_EnableInterrupts@{UART\_EnableInterrupts}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_EnableInterrupts()}{UART\_EnableInterrupts()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Enable\+Interrupts (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{mask }\end{DoxyParamCaption})}



Enables U\+A\+RT interrupts according to the provided mask. 

This function enables the U\+A\+RT interrupts according to the provided mask. The mask is a logical OR of enumeration members. See \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}. For example, to enable TX empty interrupt and RX full interrupt, do the following. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__uart__driver_ga49ecd761481a22956e3f46285038719c}{UART\_EnableInterrupts}}(UART1,\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14}{kUART\_TxDataRegEmptyInterruptEnable}} | \mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3}{kUART\_RxDataRegFullInterruptEnable}});}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em mask} & The interrupts to enable. Logical OR of \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}.\\
\hline
\end{DoxyParams}
brief Enables U\+A\+RT interrupts according to the provided mask.

This function enables the U\+A\+RT interrupts according to the provided mask. The mask is a logical OR of enumeration members. See ref \+\_\+uart\+\_\+interrupt\+\_\+enable. For example, to enable TX empty interrupt and RX full interrupt, do the following. code U\+A\+R\+T\+\_\+\+Enable\+Interrupts(U\+A\+R\+T1,k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable $\vert$ k\+U\+A\+R\+T\+\_\+\+Rx\+Data\+Reg\+Full\+Interrupt\+Enable); endcode

param base U\+A\+RT peripheral base address. param mask The interrupts to enable. Logical OR of ref \+\_\+uart\+\_\+interrupt\+\_\+enable. \mbox{\Hypertarget{group__uart__driver_ga47c7c09e04a0497f4530d553e27d96c5}\label{group__uart__driver_ga47c7c09e04a0497f4530d553e27d96c5}} 
\index{Uart\_driver@{Uart\_driver}!UART\_GetDefaultConfig@{UART\_GetDefaultConfig}}
\index{UART\_GetDefaultConfig@{UART\_GetDefaultConfig}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_GetDefaultConfig()}{UART\_GetDefaultConfig()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Get\+Default\+Config (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{group__uart__driver_ga032da70848aac8bc9c3904a32bde5899}{uart\+\_\+config\+\_\+t}} $\ast$}]{config }\end{DoxyParamCaption})}



Gets the default configuration structure. 

This function initializes the U\+A\+RT configuration structure to a default value. The default values are as follows. uart\+Config-\/$>$baud\+Rate\+\_\+\+Bps = 115200U; uart\+Config-\/$>$bit\+Count\+Per\+Char = k\+U\+A\+R\+T\+\_\+8\+Bits\+Per\+Char; uart\+Config-\/$>$parity\+Mode = k\+U\+A\+R\+T\+\_\+\+Parity\+Disabled; uart\+Config-\/$>$stop\+Bit\+Count = k\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit; uart\+Config-\/$>$tx\+Fifo\+Watermark = 0; uart\+Config-\/$>$rx\+Fifo\+Watermark = 1; uart\+Config-\/$>$idle\+Type = k\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit; uart\+Config-\/$>$enable\+Tx = false; uart\+Config-\/$>$enable\+Rx = false;


\begin{DoxyParams}{Parameters}
{\em config} & Pointer to configuration structure.\\
\hline
\end{DoxyParams}
brief Gets the default configuration structure.

This function initializes the U\+A\+RT configuration structure to a default value. The default values are as follows. uart\+Config-\/$>$baud\+Rate\+\_\+\+Bps = 115200U; uart\+Config-\/$>$bit\+Count\+Per\+Char = k\+U\+A\+R\+T\+\_\+8\+Bits\+Per\+Char; uart\+Config-\/$>$parity\+Mode = k\+U\+A\+R\+T\+\_\+\+Parity\+Disabled; uart\+Config-\/$>$stop\+Bit\+Count = k\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit; uart\+Config-\/$>$tx\+Fifo\+Watermark = 0; uart\+Config-\/$>$rx\+Fifo\+Watermark = 1; uart\+Config-\/$>$idle\+Type = k\+U\+A\+R\+T\+\_\+\+Idle\+Type\+Start\+Bit; uart\+Config-\/$>$enable\+Tx = false; uart\+Config-\/$>$enable\+Rx = false;

param config Pointer to configuration structure. \mbox{\Hypertarget{group__uart__driver_ga79bc0b880286ec0dc0543606fc772912}\label{group__uart__driver_ga79bc0b880286ec0dc0543606fc772912}} 
\index{Uart\_driver@{Uart\_driver}!UART\_GetEnabledInterrupts@{UART\_GetEnabledInterrupts}}
\index{UART\_GetEnabledInterrupts@{UART\_GetEnabledInterrupts}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_GetEnabledInterrupts()}{UART\_GetEnabledInterrupts()}}
{\footnotesize\ttfamily uint32\+\_\+t U\+A\+R\+T\+\_\+\+Get\+Enabled\+Interrupts (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Gets the enabled U\+A\+RT interrupts. 

This function gets the enabled U\+A\+RT interrupts. The enabled interrupts are returned as the logical OR value of the enumerators \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}. To check a specific interrupts enable status, compare the return value with enumerators in \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}. For example, to check whether TX empty interrupt is enabled, do the following. 
\begin{DoxyCode}{0}
\DoxyCodeLine{uint32\_t enabledInterrupts = \mbox{\hyperlink{group__uart__driver_ga79bc0b880286ec0dc0543606fc772912}{UART\_GetEnabledInterrupts}}(UART1);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordflow}{if} (\mbox{\hyperlink{group__uart__driver_gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14}{kUART\_TxDataRegEmptyInterruptEnable}} \& enabledInterrupts)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
U\+A\+RT interrupt flags which are logical OR of the enumerators in \mbox{\hyperlink{group__uart__driver_ga700f3cd8e3800273a1591307cab6311c}{\+\_\+uart\+\_\+interrupt\+\_\+enable}}.
\end{DoxyReturn}
brief Gets the enabled U\+A\+RT interrupts.

This function gets the enabled U\+A\+RT interrupts. The enabled interrupts are returned as the logical OR value of the enumerators ref \+\_\+uart\+\_\+interrupt\+\_\+enable. To check a specific interrupts enable status, compare the return value with enumerators in ref \+\_\+uart\+\_\+interrupt\+\_\+enable. For example, to check whether TX empty interrupt is enabled, do the following. code uint32\+\_\+t enabled\+Interrupts = U\+A\+R\+T\+\_\+\+Get\+Enabled\+Interrupts(\+U\+A\+R\+T1);

if (k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Interrupt\+Enable \& enabled\+Interrupts) \{ ... \} endcode

param base U\+A\+RT peripheral base address. return U\+A\+RT interrupt flags which are logical OR of the enumerators in ref \+\_\+uart\+\_\+interrupt\+\_\+enable. \mbox{\Hypertarget{group__uart__driver_gadeeb40cdc314638d4355ef906f1c408d}\label{group__uart__driver_gadeeb40cdc314638d4355ef906f1c408d}} 
\index{Uart\_driver@{Uart\_driver}!UART\_GetInstance@{UART\_GetInstance}}
\index{UART\_GetInstance@{UART\_GetInstance}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_GetInstance()}{UART\_GetInstance()}}
{\footnotesize\ttfamily uint32\+\_\+t U\+A\+R\+T\+\_\+\+Get\+Instance (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Get the U\+A\+RT instance from peripheral base address. 


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
U\+A\+RT instance.
\end{DoxyReturn}
brief Get the U\+A\+RT instance from peripheral base address.

param base U\+A\+RT peripheral base address. return U\+A\+RT instance. \mbox{\Hypertarget{group__uart__driver_ga28bf715678c0d3c8c3902e79455ee923}\label{group__uart__driver_ga28bf715678c0d3c8c3902e79455ee923}} 
\index{Uart\_driver@{Uart\_driver}!UART\_GetStatusFlags@{UART\_GetStatusFlags}}
\index{UART\_GetStatusFlags@{UART\_GetStatusFlags}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_GetStatusFlags()}{UART\_GetStatusFlags()}}
{\footnotesize\ttfamily uint32\+\_\+t U\+A\+R\+T\+\_\+\+Get\+Status\+Flags (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base }\end{DoxyParamCaption})}



Gets U\+A\+RT status flags. 

This function gets all U\+A\+RT status flags. The flags are returned as the logical OR value of the enumerators \mbox{\hyperlink{group__uart__driver_ga259a53f363288115306a45d08fc66eb8}{\+\_\+uart\+\_\+flags}}. To check a specific status, compare the return value with enumerators in \mbox{\hyperlink{group__uart__driver_ga259a53f363288115306a45d08fc66eb8}{\+\_\+uart\+\_\+flags}}. For example, to check whether the TX is empty, do the following. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{if} (\mbox{\hyperlink{group__uart__driver_gga259a53f363288115306a45d08fc66eb8a5209c671b2f2f064dc512655387e9e1a}{kUART\_TxDataRegEmptyFlag}} \& \mbox{\hyperlink{group__uart__driver_ga28bf715678c0d3c8c3902e79455ee923}{UART\_GetStatusFlags}}(UART1))}
\DoxyCodeLine{\{}
\DoxyCodeLine{    ...}
\DoxyCodeLine{\}}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
U\+A\+RT status flags which are O\+Red by the enumerators in the \+\_\+uart\+\_\+flags.
\end{DoxyReturn}
brief Gets U\+A\+RT status flags.

This function gets all U\+A\+RT status flags. The flags are returned as the logical OR value of the enumerators ref \+\_\+uart\+\_\+flags. To check a specific status, compare the return value with enumerators in ref \+\_\+uart\+\_\+flags. For example, to check whether the TX is empty, do the following. code if (k\+U\+A\+R\+T\+\_\+\+Tx\+Data\+Reg\+Empty\+Flag \& U\+A\+R\+T\+\_\+\+Get\+Status\+Flags(\+U\+A\+R\+T1)) \{ ... \} endcode

param base U\+A\+RT peripheral base address. return U\+A\+RT status flags which are O\+Red by the enumerators in the \+\_\+uart\+\_\+flags. \mbox{\Hypertarget{group__uart__driver_gab5965a8e11f7e1d4d531141291fd5288}\label{group__uart__driver_gab5965a8e11f7e1d4d531141291fd5288}} 
\index{Uart\_driver@{Uart\_driver}!UART\_Init@{UART\_Init}}
\index{UART\_Init@{UART\_Init}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_Init()}{UART\_Init()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Init (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{const \mbox{\hyperlink{group__uart__driver_ga032da70848aac8bc9c3904a32bde5899}{uart\+\_\+config\+\_\+t}} $\ast$}]{config,  }\item[{uint32\+\_\+t}]{src\+Clock\+\_\+\+Hz }\end{DoxyParamCaption})}



Initializes a U\+A\+RT instance with a user configuration structure and peripheral clock. 

This function configures the U\+A\+RT module with the user-\/defined settings. The user can configure the configuration structure and also get the default configuration by using the \mbox{\hyperlink{group__uart__driver_ga47c7c09e04a0497f4530d553e27d96c5}{U\+A\+R\+T\+\_\+\+Get\+Default\+Config()}} function. The example below shows how to use this A\+PI to configure U\+A\+RT. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{struct__uart__config}{uart\_config\_t}} uartConfig;}
\DoxyCodeLine{uartConfig.\mbox{\hyperlink{struct__uart__config_aa5df547b4cb95d3c959373cf6fa672b5}{baudRate\_Bps}} = 115200U;}
\DoxyCodeLine{uartConfig.\mbox{\hyperlink{struct__uart__config_a316fd94f4c5e6d15a3cda133d5dd5683}{parityMode}} = \mbox{\hyperlink{group__uart__driver_ggadf9f66755acc340eab030e1a48e35e10a97e2feae6671a6de1126ebc2edf4606b}{kUART\_ParityDisabled}};}
\DoxyCodeLine{uartConfig.stopBitCount = \mbox{\hyperlink{group__uart__driver_gga3c656a4365cab1185398ff953272091ea5a8829a108d8a46abb097a36cde051a7}{kUART\_OneStopBit}};}
\DoxyCodeLine{uartConfig.txFifoWatermark = 0;}
\DoxyCodeLine{uartConfig.rxFifoWatermark = 1;}
\DoxyCodeLine{\mbox{\hyperlink{group__uart__driver_gab5965a8e11f7e1d4d531141291fd5288}{UART\_Init}}(UART1, \&uartConfig, 20000000U);}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em config} & Pointer to the user-\/defined configuration structure. \\
\hline
{\em src\+Clock\+\_\+\+Hz} & U\+A\+RT clock source frequency in HZ. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support} & Baudrate is not support in current clock source. \\
\hline
{\em k\+Status\+\_\+\+Success} & Status U\+A\+RT initialize succeed\\
\hline
\end{DoxyRetVals}
brief Initializes a U\+A\+RT instance with a user configuration structure and peripheral clock.

This function configures the U\+A\+RT module with the user-\/defined settings. The user can configure the configuration structure and also get the default configuration by using the \mbox{\hyperlink{group__uart__driver_ga47c7c09e04a0497f4530d553e27d96c5}{U\+A\+R\+T\+\_\+\+Get\+Default\+Config()}} function. The example below shows how to use this A\+PI to configure U\+A\+RT. code uart\+\_\+config\+\_\+t uart\+Config; uart\+Config.\+baud\+Rate\+\_\+\+Bps = 115200U; uart\+Config.\+parity\+Mode = k\+U\+A\+R\+T\+\_\+\+Parity\+Disabled; uart\+Config.\+stop\+Bit\+Count = k\+U\+A\+R\+T\+\_\+\+One\+Stop\+Bit; uart\+Config.\+tx\+Fifo\+Watermark = 0; uart\+Config.\+rx\+Fifo\+Watermark = 1; U\+A\+R\+T\+\_\+\+Init(\+U\+A\+R\+T1, \&uart\+Config, 20000000\+U); endcode

param base U\+A\+RT peripheral base address. param config Pointer to the user-\/defined configuration structure. param src\+Clock\+\_\+\+Hz U\+A\+RT clock source frequency in HZ. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support Baudrate is not support in current clock source. retval k\+Status\+\_\+\+Success Status U\+A\+RT initialize succeed \mbox{\Hypertarget{group__uart__driver_ga39d59e8a94f1af451a0db81888596639}\label{group__uart__driver_ga39d59e8a94f1af451a0db81888596639}} 
\index{Uart\_driver@{Uart\_driver}!UART\_ReadBlocking@{UART\_ReadBlocking}}
\index{UART\_ReadBlocking@{UART\_ReadBlocking}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_ReadBlocking()}{UART\_ReadBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Read\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Read RX data register using a blocking method. 

This function polls the RX register, waits for the RX register to be full or for RX F\+I\+FO to have data, and reads data from the TX register.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em data} & Start address of the buffer to store the received data. \\
\hline
{\em length} & Size of the buffer. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun} & Receiver overrun occurred while receiving data. \\
\hline
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Noise\+Error} & A noise error occurred while receiving data. \\
\hline
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Framing\+Error} & A framing error occurred while receiving data. \\
\hline
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Parity\+Error} & A parity error occurred while receiving data. \\
\hline
{\em k\+Status\+\_\+\+Success} & Successfully received all data.\\
\hline
\end{DoxyRetVals}
brief Read RX data register using a blocking method.

This function polls the RX register, waits for the RX register to be full or for RX F\+I\+FO to have data, and reads data from the TX register.

param base U\+A\+RT peripheral base address. param data Start address of the buffer to store the received data. param length Size of the buffer. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Hardware\+Overrun Receiver overrun occurred while receiving data. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Noise\+Error A noise error occurred while receiving data. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Framing\+Error A framing error occurred while receiving data. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Parity\+Error A parity error occurred while receiving data. retval k\+Status\+\_\+\+Success Successfully received all data. \mbox{\Hypertarget{group__uart__driver_gab3ba5019c11f288cc4f545dd656b6284}\label{group__uart__driver_gab3ba5019c11f288cc4f545dd656b6284}} 
\index{Uart\_driver@{Uart\_driver}!UART\_SetBaudRate@{UART\_SetBaudRate}}
\index{UART\_SetBaudRate@{UART\_SetBaudRate}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_SetBaudRate()}{UART\_SetBaudRate()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Set\+Baud\+Rate (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{uint32\+\_\+t}]{baud\+Rate\+\_\+\+Bps,  }\item[{uint32\+\_\+t}]{src\+Clock\+\_\+\+Hz }\end{DoxyParamCaption})}



Sets the U\+A\+RT instance baud rate. 

This function configures the U\+A\+RT module baud rate. This function is used to update the U\+A\+RT module baud rate after the U\+A\+RT module is initialized by the U\+A\+R\+T\+\_\+\+Init. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__uart__driver_gab3ba5019c11f288cc4f545dd656b6284}{UART\_SetBaudRate}}(UART1, 115200U, 20000000U);}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em baud\+Rate\+\_\+\+Bps} & U\+A\+RT baudrate to be set. \\
\hline
{\em src\+Clock\+\_\+\+Hz} & U\+A\+RT clock source frequency in Hz. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support} & Baudrate is not support in the current clock source. \\
\hline
{\em k\+Status\+\_\+\+Success} & Set baudrate succeeded.\\
\hline
\end{DoxyRetVals}
brief Sets the U\+A\+RT instance baud rate.

This function configures the U\+A\+RT module baud rate. This function is used to update the U\+A\+RT module baud rate after the U\+A\+RT module is initialized by the U\+A\+R\+T\+\_\+\+Init. code U\+A\+R\+T\+\_\+\+Set\+Baud\+Rate(\+U\+A\+R\+T1, 115200\+U, 20000000\+U); endcode

param base U\+A\+RT peripheral base address. param baud\+Rate\+\_\+\+Bps U\+A\+RT baudrate to be set. param src\+Clock\+\_\+\+Hz U\+A\+RT clock source frequency in Hz. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Baudrate\+Not\+Support Baudrate is not support in the current clock source. retval k\+Status\+\_\+\+Success Set baudrate succeeded. \mbox{\Hypertarget{group__uart__driver_gacc35671622b2401545cc55cc6ae572d4}\label{group__uart__driver_gacc35671622b2401545cc55cc6ae572d4}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferAbortReceive@{UART\_TransferAbortReceive}}
\index{UART\_TransferAbortReceive@{UART\_TransferAbortReceive}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferAbortReceive()}{UART\_TransferAbortReceive()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Receive (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Aborts the interrupt-\/driven data receiving. 

This function aborts the interrupt-\/driven data receiving. The user can get the remain\+Bytes to know how many bytes are not received yet.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief Aborts the interrupt-\/driven data receiving.

This function aborts the interrupt-\/driven data receiving. The user can get the remain\+Bytes to know how many bytes are not received yet.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. \mbox{\Hypertarget{group__uart__driver_gaa64f9f89d8286fd3ef0736a8c40be2c2}\label{group__uart__driver_gaa64f9f89d8286fd3ef0736a8c40be2c2}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferAbortSend@{UART\_TransferAbortSend}}
\index{UART\_TransferAbortSend@{UART\_TransferAbortSend}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferAbortSend()}{UART\_TransferAbortSend()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Transfer\+Abort\+Send (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Aborts the interrupt-\/driven data transmit. 

This function aborts the interrupt-\/driven data sending. The user can get the remain\+Bytes to find out how many bytes are not sent out.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief Aborts the interrupt-\/driven data transmit.

This function aborts the interrupt-\/driven data sending. The user can get the remain\+Bytes to find out how many bytes are not sent out.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. \mbox{\Hypertarget{group__uart__driver_ga63db308c32019b7dd6c0647d618e5247}\label{group__uart__driver_ga63db308c32019b7dd6c0647d618e5247}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferCreateHandle@{UART\_TransferCreateHandle}}
\index{UART\_TransferCreateHandle@{UART\_TransferCreateHandle}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferCreateHandle()}{UART\_TransferCreateHandle()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Transfer\+Create\+Handle (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{\mbox{\hyperlink{group__uart__driver_ga2868b6ea396ab212547f2157380429c5}{uart\+\_\+transfer\+\_\+callback\+\_\+t}}}]{callback,  }\item[{void $\ast$}]{user\+Data }\end{DoxyParamCaption})}



Initializes the U\+A\+RT handle. 

This function initializes the U\+A\+RT handle which can be used for other U\+A\+RT transactional A\+P\+Is. Usually, for a specified U\+A\+RT instance, call this A\+PI once to get the initialized handle.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer. \\
\hline
{\em callback} & The callback function. \\
\hline
{\em user\+Data} & The parameter of the callback function.\\
\hline
\end{DoxyParams}
brief Initializes the U\+A\+RT handle.

This function initializes the U\+A\+RT handle which can be used for other U\+A\+RT transactional A\+P\+Is. Usually, for a specified U\+A\+RT instance, call this A\+PI once to get the initialized handle.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. param callback The callback function. param user\+Data The parameter of the callback function. \mbox{\Hypertarget{group__uart__driver_ga05df10f570cdca4ac2dff63b069d254e}\label{group__uart__driver_ga05df10f570cdca4ac2dff63b069d254e}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferGetReceiveCount@{UART\_TransferGetReceiveCount}}
\index{UART\_TransferGetReceiveCount@{UART\_TransferGetReceiveCount}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferGetReceiveCount()}{UART\_TransferGetReceiveCount()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Transfer\+Get\+Receive\+Count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{uint32\+\_\+t $\ast$}]{count }\end{DoxyParamCaption})}



Gets the number of bytes that have been received. 

This function gets the number of bytes that have been received.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer. \\
\hline
{\em count} & Receive bytes count. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+No\+Transfer\+In\+Progress} & No receive in progress. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & Parameter is invalid. \\
\hline
{\em k\+Status\+\_\+\+Success} & Get successfully through the parameter {\ttfamily count};\\
\hline
\end{DoxyRetVals}
brief Gets the number of bytes that have been received.

This function gets the number of bytes that have been received.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. param count Receive bytes count. retval k\+Status\+\_\+\+No\+Transfer\+In\+Progress No receive in progress. retval k\+Status\+\_\+\+Invalid\+Argument Parameter is invalid. retval k\+Status\+\_\+\+Success Get successfully through the parameter {\ttfamily count}; \mbox{\Hypertarget{group__uart__driver_ga3921aa660977ca77dadf95fa35f1c3a9}\label{group__uart__driver_ga3921aa660977ca77dadf95fa35f1c3a9}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferGetRxRingBufferLength@{UART\_TransferGetRxRingBufferLength}}
\index{UART\_TransferGetRxRingBufferLength@{UART\_TransferGetRxRingBufferLength}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferGetRxRingBufferLength()}{UART\_TransferGetRxRingBufferLength()}}
{\footnotesize\ttfamily size\+\_\+t U\+A\+R\+T\+\_\+\+Transfer\+Get\+Rx\+Ring\+Buffer\+Length (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Get the length of received data in RX ring buffer. 


\begin{DoxyParams}{Parameters}
{\em handle} & U\+A\+RT handle pointer. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Length of received data in RX ring buffer.
\end{DoxyReturn}
brief Get the length of received data in RX ring buffer.

param handle U\+A\+RT handle pointer. return Length of received data in RX ring buffer. \mbox{\Hypertarget{group__uart__driver_ga071727ba05b2937ef5ad641ca7faf9c7}\label{group__uart__driver_ga071727ba05b2937ef5ad641ca7faf9c7}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferGetSendCount@{UART\_TransferGetSendCount}}
\index{UART\_TransferGetSendCount@{UART\_TransferGetSendCount}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferGetSendCount()}{UART\_TransferGetSendCount()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Transfer\+Get\+Send\+Count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{uint32\+\_\+t $\ast$}]{count }\end{DoxyParamCaption})}



Gets the number of bytes written to the U\+A\+RT TX register. 

This function gets the number of bytes written to the U\+A\+RT TX register by using the interrupt method.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer. \\
\hline
{\em count} & Send bytes count. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+No\+Transfer\+In\+Progress} & No send in progress. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & The parameter is invalid. \\
\hline
{\em k\+Status\+\_\+\+Success} & Get successfully through the parameter {\ttfamily count};\\
\hline
\end{DoxyRetVals}
brief Gets the number of bytes written to the U\+A\+RT TX register.

This function gets the number of bytes written to the U\+A\+RT TX register by using the interrupt method.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. param count Send bytes count. retval k\+Status\+\_\+\+No\+Transfer\+In\+Progress No send in progress. retval k\+Status\+\_\+\+Invalid\+Argument The parameter is invalid. retval k\+Status\+\_\+\+Success Get successfully through the parameter {\ttfamily count}; \mbox{\Hypertarget{group__uart__driver_gafc364352e879f53138ee1107e3da0a7d}\label{group__uart__driver_gafc364352e879f53138ee1107e3da0a7d}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferHandleErrorIRQ@{UART\_TransferHandleErrorIRQ}}
\index{UART\_TransferHandleErrorIRQ@{UART\_TransferHandleErrorIRQ}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferHandleErrorIRQ()}{UART\_TransferHandleErrorIRQ()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Transfer\+Handle\+Error\+I\+RQ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



U\+A\+RT Error I\+RQ handle function. 

This function handles the U\+A\+RT error I\+RQ request.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief U\+A\+RT Error I\+RQ handle function.

This function handles the U\+A\+RT error I\+RQ request.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. \mbox{\Hypertarget{group__uart__driver_gadb0c4f1e5b59db3aa2261df4f5ddb48d}\label{group__uart__driver_gadb0c4f1e5b59db3aa2261df4f5ddb48d}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferHandleIRQ@{UART\_TransferHandleIRQ}}
\index{UART\_TransferHandleIRQ@{UART\_TransferHandleIRQ}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferHandleIRQ()}{UART\_TransferHandleIRQ()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Transfer\+Handle\+I\+RQ (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



U\+A\+RT I\+RQ handle function. 

This function handles the U\+A\+RT transmit and receive I\+RQ request.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief U\+A\+RT I\+RQ handle function.

This function handles the U\+A\+RT transmit and receive I\+RQ request.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. \mbox{\Hypertarget{group__uart__driver_gaf804acde5d73ce0a5bf54b06195e1218}\label{group__uart__driver_gaf804acde5d73ce0a5bf54b06195e1218}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferReceiveNonBlocking@{UART\_TransferReceiveNonBlocking}}
\index{UART\_TransferReceiveNonBlocking@{UART\_TransferReceiveNonBlocking}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferReceiveNonBlocking()}{UART\_TransferReceiveNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{\mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}} $\ast$}]{xfer,  }\item[{size\+\_\+t $\ast$}]{received\+Bytes }\end{DoxyParamCaption})}



Receives a buffer of data using an interrupt method. 

This function receives data using an interrupt method. This is a non-\/blocking function, which returns without waiting for all data to be received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter {\ttfamily received\+Bytes} shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough to read, the receive request is saved by the U\+A\+RT driver. When the new data arrives, the receive request is serviced first. When all data is received, the U\+A\+RT driver notifies the upper layer through a callback function and passes the status parameter \mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Idle}}. For example, the upper layer needs 10 bytes but there are only 5 bytes in the ring buffer. The 5 bytes are copied to the xfer-\/$>$data and this function returns with the parameter {\ttfamily received\+Bytes} set to 5. For the left 5 bytes, newly arrived data is saved from the xfer-\/$>$data\mbox{[}5\mbox{]}. When 5 bytes are received, the U\+A\+RT driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to the xfer-\/$>$data. When all data is received, the upper layer is notified.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer. \\
\hline
{\em xfer} & U\+A\+RT transfer structure, see \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}}. \\
\hline
{\em received\+Bytes} & Bytes received from the ring buffer directly. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+Success} & Successfully queue the transfer into transmit queue. \\
\hline
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Busy} & Previous receive request is not finished. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & Invalid argument.\\
\hline
\end{DoxyRetVals}
brief Receives a buffer of data using an interrupt method.

This function receives data using an interrupt method. This is a non-\/blocking function, which returns without waiting for all data to be received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter p received\+Bytes shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough to read, the receive request is saved by the U\+A\+RT driver. When the new data arrives, the receive request is serviced first. When all data is received, the U\+A\+RT driver notifies the upper layer through a callback function and passes the status parameter ref k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Idle. For example, the upper layer needs 10 bytes but there are only 5 bytes in the ring buffer. The 5 bytes are copied to the xfer-\/$>$data and this function returns with the parameter p received\+Bytes set to 5. For the left 5 bytes, newly arrived data is saved from the xfer-\/$>$data\mbox{[}5\mbox{]}. When 5 bytes are received, the U\+A\+RT driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to the xfer-\/$>$data. When all data is received, the upper layer is notified.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. param xfer U\+A\+RT transfer structure, see \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}}. param received\+Bytes Bytes received from the ring buffer directly. retval k\+Status\+\_\+\+Success Successfully queue the transfer into transmit queue. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Rx\+Busy Previous receive request is not finished. retval k\+Status\+\_\+\+Invalid\+Argument Invalid argument. \mbox{\Hypertarget{group__uart__driver_gad89afd7db1656c5aef404bb285d0dc05}\label{group__uart__driver_gad89afd7db1656c5aef404bb285d0dc05}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferSendNonBlocking@{UART\_TransferSendNonBlocking}}
\index{UART\_TransferSendNonBlocking@{UART\_TransferSendNonBlocking}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferSendNonBlocking()}{UART\_TransferSendNonBlocking()}}
{\footnotesize\ttfamily \mbox{\hyperlink{group__ksdk__common_gaaabdaf7ee58ca7269bd4bf24efcde092}{status\+\_\+t}} U\+A\+R\+T\+\_\+\+Transfer\+Send\+Non\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{\mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}} $\ast$}]{xfer }\end{DoxyParamCaption})}



Transmits a buffer of data using the interrupt method. 

This function sends data using an interrupt method. This is a non-\/blocking function, which returns directly without waiting for all data to be written to the TX register. When all data is written to the TX register in the I\+SR, the U\+A\+RT driver calls the callback function and passes the \mbox{\hyperlink{group__uart__driver_ggacef40dc8e8ac174bfe40ebcbc980f84baf36c829b1b889517bf775c0d7ce29fa6}{k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Idle}} as status parameter.

\begin{DoxyNote}{Note}
The k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Idle is passed to the upper layer when all data is written to the TX register. However, it does not ensure that all data is sent out. Before disabling the TX, check the k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag to ensure that the TX is finished.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer. \\
\hline
{\em xfer} & U\+A\+RT transfer structure. See \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}}. \\
\hline
\end{DoxyParams}

\begin{DoxyRetVals}{Return values}
{\em k\+Status\+\_\+\+Success} & Successfully start the data transmission. \\
\hline
{\em k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Busy} & Previous transmission still not finished; data not all written to TX register yet. \\
\hline
{\em k\+Status\+\_\+\+Invalid\+Argument} & Invalid argument.\\
\hline
\end{DoxyRetVals}
brief Transmits a buffer of data using the interrupt method.

This function sends data using an interrupt method. This is a non-\/blocking function, which returns directly without waiting for all data to be written to the TX register. When all data is written to the TX register in the I\+SR, the U\+A\+RT driver calls the callback function and passes the ref k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Idle as status parameter.

note The k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Idle is passed to the upper layer when all data is written to the TX register. However, it does not ensure that all data is sent out. Before disabling the TX, check the k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag to ensure that the TX is finished.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. param xfer U\+A\+RT transfer structure. See \mbox{\hyperlink{group__uart__driver_gae245db88e02822f416e4d246d49076df}{uart\+\_\+transfer\+\_\+t}}. retval k\+Status\+\_\+\+Success Successfully start the data transmission. retval k\+Status\+\_\+\+U\+A\+R\+T\+\_\+\+Tx\+Busy Previous transmission still not finished; data not all written to TX register yet. retval k\+Status\+\_\+\+Invalid\+Argument Invalid argument. \mbox{\Hypertarget{group__uart__driver_ga223fba584bfabd599629d5ce92f929ac}\label{group__uart__driver_ga223fba584bfabd599629d5ce92f929ac}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferStartRingBuffer@{UART\_TransferStartRingBuffer}}
\index{UART\_TransferStartRingBuffer@{UART\_TransferStartRingBuffer}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferStartRingBuffer()}{UART\_TransferStartRingBuffer()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Transfer\+Start\+Ring\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle,  }\item[{uint8\+\_\+t $\ast$}]{ring\+Buffer,  }\item[{size\+\_\+t}]{ring\+Buffer\+Size }\end{DoxyParamCaption})}



Sets up the RX ring buffer. 

This function sets up the RX ring buffer to a specific U\+A\+RT handle.

When the RX ring buffer is used, data received are stored into the ring buffer even when the user doesn\textquotesingle{}t call the \mbox{\hyperlink{group__uart__driver_gaf804acde5d73ce0a5bf54b06195e1218}{U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking()}} A\+PI. If data is already received in the ring buffer, the user can get the received data from the ring buffer directly.

\begin{DoxyNote}{Note}
When using the RX ring buffer, one byte is reserved for internal use. In other words, if {\ttfamily ring\+Buffer\+Size} is 32, only 31 bytes are used for saving data.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer. \\
\hline
{\em ring\+Buffer} & Start address of the ring buffer for background receiving. Pass N\+U\+LL to disable the ring buffer. \\
\hline
{\em ring\+Buffer\+Size} & Size of the ring buffer.\\
\hline
\end{DoxyParams}
brief Sets up the RX ring buffer.

This function sets up the RX ring buffer to a specific U\+A\+RT handle.

When the RX ring buffer is used, data received are stored into the ring buffer even when the user doesn\textquotesingle{}t call the \mbox{\hyperlink{group__uart__driver_gaf804acde5d73ce0a5bf54b06195e1218}{U\+A\+R\+T\+\_\+\+Transfer\+Receive\+Non\+Blocking()}} A\+PI. If data is already received in the ring buffer, the user can get the received data from the ring buffer directly.

note When using the RX ring buffer, one byte is reserved for internal use. In other words, if p ring\+Buffer\+Size is 32, only 31 bytes are used for saving data.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. param ring\+Buffer Start address of the ring buffer for background receiving. Pass N\+U\+LL to disable the ring buffer. param ring\+Buffer\+Size Size of the ring buffer. \mbox{\Hypertarget{group__uart__driver_ga0c0bc73df49cb31dff0e903630314f5b}\label{group__uart__driver_ga0c0bc73df49cb31dff0e903630314f5b}} 
\index{Uart\_driver@{Uart\_driver}!UART\_TransferStopRingBuffer@{UART\_TransferStopRingBuffer}}
\index{UART\_TransferStopRingBuffer@{UART\_TransferStopRingBuffer}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_TransferStopRingBuffer()}{UART\_TransferStopRingBuffer()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Transfer\+Stop\+Ring\+Buffer (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{\mbox{\hyperlink{struct__uart__handle}{uart\+\_\+handle\+\_\+t}} $\ast$}]{handle }\end{DoxyParamCaption})}



Aborts the background transfer and uninstalls the ring buffer. 

This function aborts the background transfer and uninstalls the ring buffer.


\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em handle} & U\+A\+RT handle pointer.\\
\hline
\end{DoxyParams}
brief Aborts the background transfer and uninstalls the ring buffer.

This function aborts the background transfer and uninstalls the ring buffer.

param base U\+A\+RT peripheral base address. param handle U\+A\+RT handle pointer. \mbox{\Hypertarget{group__uart__driver_gad67794d80b7ee2d3292b41af6ff1e100}\label{group__uart__driver_gad67794d80b7ee2d3292b41af6ff1e100}} 
\index{Uart\_driver@{Uart\_driver}!UART\_WriteBlocking@{UART\_WriteBlocking}}
\index{UART\_WriteBlocking@{UART\_WriteBlocking}!Uart\_driver@{Uart\_driver}}
\subsubsection{\texorpdfstring{UART\_WriteBlocking()}{UART\_WriteBlocking()}}
{\footnotesize\ttfamily void U\+A\+R\+T\+\_\+\+Write\+Blocking (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_u_a_r_t___type}{U\+A\+R\+T\+\_\+\+Type}} $\ast$}]{base,  }\item[{const uint8\+\_\+t $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})}



Writes to the TX register using a blocking method. 

This function polls the TX register, waits for the TX register to be empty or for the TX F\+I\+FO to have room and writes data to the TX buffer.

\begin{DoxyNote}{Note}
This function does not check whether all data is sent out to the bus. Before disabling the TX, check k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag to ensure that the TX is finished.
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em base} & U\+A\+RT peripheral base address. \\
\hline
{\em data} & Start address of the data to write. \\
\hline
{\em length} & Size of the data to write.\\
\hline
\end{DoxyParams}
brief Writes to the TX register using a blocking method.

This function polls the TX register, waits for the TX register to be empty or for the TX F\+I\+FO to have room and writes data to the TX buffer.

note This function does not check whether all data is sent out to the bus. Before disabling the TX, check k\+U\+A\+R\+T\+\_\+\+Transmission\+Complete\+Flag to ensure that the TX is finished.

param base U\+A\+RT peripheral base address. param data Start address of the data to write. param length Size of the data to write. 