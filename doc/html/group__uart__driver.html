<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smartlock: Uart_driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smartlock
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Uart_driver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__uart__config.html">_uart_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART configuration structure.  <a href="struct__uart__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__uart__transfer.html">_uart_transfer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transfer structure.  <a href="struct__uart__transfer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__uart__handle.html">_uart_handle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART handle structure.  <a href="struct__uart__handle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3d74bf70252b21a0dd19d61587ed320c"><td class="memItemLeft" align="right" valign="top"><a id="ga3d74bf70252b21a0dd19d61587ed320c"></a>
typedef enum <a class="el" href="group__uart__driver.html#gadf9f66755acc340eab030e1a48e35e10">_uart_parity_mode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga3d74bf70252b21a0dd19d61587ed320c">uart_parity_mode_t</a></td></tr>
<tr class="memdesc:ga3d74bf70252b21a0dd19d61587ed320c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity mode. <br /></td></tr>
<tr class="separator:ga3d74bf70252b21a0dd19d61587ed320c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1df1fcb3fcd2d2db0b7ea0189fd94554"><td class="memItemLeft" align="right" valign="top"><a id="ga1df1fcb3fcd2d2db0b7ea0189fd94554"></a>
typedef enum <a class="el" href="group__uart__driver.html#ga3c656a4365cab1185398ff953272091e">_uart_stop_bit_count</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga1df1fcb3fcd2d2db0b7ea0189fd94554">uart_stop_bit_count_t</a></td></tr>
<tr class="memdesc:ga1df1fcb3fcd2d2db0b7ea0189fd94554"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit count. <br /></td></tr>
<tr class="separator:ga1df1fcb3fcd2d2db0b7ea0189fd94554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9457d04cb0bf9c547babd63a4d20a9fa"><td class="memItemLeft" align="right" valign="top"><a id="ga9457d04cb0bf9c547babd63a4d20a9fa"></a>
typedef enum <a class="el" href="group__uart__driver.html#gae658ead369268edf18141e1903d426f1">_uart_idle_type_select</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga9457d04cb0bf9c547babd63a4d20a9fa">uart_idle_type_select_t</a></td></tr>
<tr class="memdesc:ga9457d04cb0bf9c547babd63a4d20a9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART idle type select. <br /></td></tr>
<tr class="separator:ga9457d04cb0bf9c547babd63a4d20a9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032da70848aac8bc9c3904a32bde5899"><td class="memItemLeft" align="right" valign="top"><a id="ga032da70848aac8bc9c3904a32bde5899"></a>
typedef struct <a class="el" href="struct__uart__config.html">_uart_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga032da70848aac8bc9c3904a32bde5899">uart_config_t</a></td></tr>
<tr class="memdesc:ga032da70848aac8bc9c3904a32bde5899"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART configuration structure. <br /></td></tr>
<tr class="separator:ga032da70848aac8bc9c3904a32bde5899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae245db88e02822f416e4d246d49076df"><td class="memItemLeft" align="right" valign="top"><a id="gae245db88e02822f416e4d246d49076df"></a>
typedef struct <a class="el" href="struct__uart__transfer.html">_uart_transfer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df">uart_transfer_t</a></td></tr>
<tr class="memdesc:gae245db88e02822f416e4d246d49076df"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transfer structure. <br /></td></tr>
<tr class="separator:gae245db88e02822f416e4d246d49076df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4cc0b0d1b32237a516424ff2f60e406"><td class="memItemLeft" align="right" valign="top"><a id="gae4cc0b0d1b32237a516424ff2f60e406"></a>
typedef struct <a class="el" href="struct__uart__handle.html">_uart_handle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>uart_handle_t</b></td></tr>
<tr class="separator:gae4cc0b0d1b32237a516424ff2f60e406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2868b6ea396ab212547f2157380429c5"><td class="memItemLeft" align="right" valign="top"><a id="ga2868b6ea396ab212547f2157380429c5"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga2868b6ea396ab212547f2157380429c5">uart_transfer_callback_t</a>) (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle, <a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> status, void *userData)</td></tr>
<tr class="memdesc:ga2868b6ea396ab212547f2157380429c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART transfer callback function. <br /></td></tr>
<tr class="separator:ga2868b6ea396ab212547f2157380429c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gacef40dc8e8ac174bfe40ebcbc980f84b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gacef40dc8e8ac174bfe40ebcbc980f84b">_uart_status</a> { <br />
&#160;&#160;<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba19ddee4fe5963467600028b78fb468e7">kStatus_UART_TxBusy</a> = MAKE_STATUS(kStatusGroup_UART, 0), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba68cf23f981c4b85f82291163fbb2a5e6">kStatus_UART_RxBusy</a> = MAKE_STATUS(kStatusGroup_UART, 1), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84baf36c829b1b889517bf775c0d7ce29fa6">kStatus_UART_TxIdle</a> = MAKE_STATUS(kStatusGroup_UART, 2), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407">kStatus_UART_RxIdle</a> = MAKE_STATUS(kStatusGroup_UART, 3), 
<br />
&#160;&#160;<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba765913f003819ed87b861d187bf79ab8">kStatus_UART_TxWatermarkTooLarge</a> = MAKE_STATUS(kStatusGroup_UART, 4), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba720cefde05389830f35f6e6df6f6ac67">kStatus_UART_RxWatermarkTooLarge</a> = MAKE_STATUS(kStatusGroup_UART, 5), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba5ee8e23fc9ab20cf366942751b895f54">kStatus_UART_FlagCannotClearManually</a>, 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba950972a9e2ebbaa13c92e8f5a51f785d">kStatus_UART_Error</a> = MAKE_STATUS(kStatusGroup_UART, 7), 
<br />
&#160;&#160;<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba2e5b644b1e10c426af818bc78657e992">kStatus_UART_RxRingBufferOverrun</a> = MAKE_STATUS(kStatusGroup_UART, 8), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84bab6b1fd6c2deec25992449f5b12303a26">kStatus_UART_RxHardwareOverrun</a> = MAKE_STATUS(kStatusGroup_UART, 9), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84bae4ef4df9a5f756ccf1b4bf08292ec2fb">kStatus_UART_NoiseError</a> = MAKE_STATUS(kStatusGroup_UART, 10), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84baa7aa134f85df3d5863ca962ce1ea7ee0">kStatus_UART_FramingError</a> = MAKE_STATUS(kStatusGroup_UART, 11), 
<br />
&#160;&#160;<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84baea20b2588c38f259f1412aa7132c9ef8">kStatus_UART_ParityError</a> = MAKE_STATUS(kStatusGroup_UART, 12), 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84bae6cdb41e1b49958f57727cd47afd69b2">kStatus_UART_BaudrateNotSupport</a>, 
<a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84ba3e5b488f7ed418cb08399a5db193103e">kStatus_UART_IdleLineDetected</a> = MAKE_STATUS(kStatusGroup_UART, 14)
<br />
 }</td></tr>
<tr class="memdesc:gacef40dc8e8ac174bfe40ebcbc980f84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes for the UART driver.  <a href="group__uart__driver.html#gacef40dc8e8ac174bfe40ebcbc980f84b">More...</a><br /></td></tr>
<tr class="separator:gacef40dc8e8ac174bfe40ebcbc980f84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf9f66755acc340eab030e1a48e35e10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gadf9f66755acc340eab030e1a48e35e10">_uart_parity_mode</a> { <a class="el" href="group__uart__driver.html#ggadf9f66755acc340eab030e1a48e35e10a97e2feae6671a6de1126ebc2edf4606b">kUART_ParityDisabled</a> = 0x0U, 
<a class="el" href="group__uart__driver.html#ggadf9f66755acc340eab030e1a48e35e10a9e68fe3aba46e045bee5433ed098bff0">kUART_ParityEven</a> = 0x2U, 
<a class="el" href="group__uart__driver.html#ggadf9f66755acc340eab030e1a48e35e10ae48c7fabc9babf1be626ebeb2627a54c">kUART_ParityOdd</a> = 0x3U
 }</td></tr>
<tr class="memdesc:gadf9f66755acc340eab030e1a48e35e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART parity mode.  <a href="group__uart__driver.html#gadf9f66755acc340eab030e1a48e35e10">More...</a><br /></td></tr>
<tr class="separator:gadf9f66755acc340eab030e1a48e35e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c656a4365cab1185398ff953272091e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga3c656a4365cab1185398ff953272091e">_uart_stop_bit_count</a> { <a class="el" href="group__uart__driver.html#gga3c656a4365cab1185398ff953272091ea5a8829a108d8a46abb097a36cde051a7">kUART_OneStopBit</a> = 0U, 
<a class="el" href="group__uart__driver.html#gga3c656a4365cab1185398ff953272091ea9704b3ae3ee851acf324eb357f75ab56">kUART_TwoStopBit</a> = 1U
 }</td></tr>
<tr class="memdesc:ga3c656a4365cab1185398ff953272091e"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART stop bit count.  <a href="group__uart__driver.html#ga3c656a4365cab1185398ff953272091e">More...</a><br /></td></tr>
<tr class="separator:ga3c656a4365cab1185398ff953272091e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae658ead369268edf18141e1903d426f1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gae658ead369268edf18141e1903d426f1">_uart_idle_type_select</a> { <a class="el" href="group__uart__driver.html#ggae658ead369268edf18141e1903d426f1a5216f34232b8d01cdd8db1ca01072901">kUART_IdleTypeStartBit</a> = 0U, 
<a class="el" href="group__uart__driver.html#ggae658ead369268edf18141e1903d426f1a05771d6cd97e160c6a47d5871d2de013">kUART_IdleTypeStopBit</a> = 1U
 }</td></tr>
<tr class="memdesc:gae658ead369268edf18141e1903d426f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART idle type select.  <a href="group__uart__driver.html#gae658ead369268edf18141e1903d426f1">More...</a><br /></td></tr>
<tr class="separator:gae658ead369268edf18141e1903d426f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga700f3cd8e3800273a1591307cab6311c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a> { <br />
&#160;&#160;<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca71755319c216d0bdf79729c18c24cf64">kUART_RxActiveEdgeInterruptEnable</a> = (UART_BDH_RXEDGIE_MASK), 
<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14">kUART_TxDataRegEmptyInterruptEnable</a> = (UART_C2_TIE_MASK &lt;&lt; 8), 
<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311cafd337213dae85b532dfaf9a90e2e5d7b">kUART_TransmissionCompleteInterruptEnable</a> = (UART_C2_TCIE_MASK &lt;&lt; 8), 
<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3">kUART_RxDataRegFullInterruptEnable</a> = (UART_C2_RIE_MASK &lt;&lt; 8), 
<br />
&#160;&#160;<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca078ea32d8587f92337a3dee495a1ceed">kUART_IdleLineInterruptEnable</a> = (UART_C2_ILIE_MASK &lt;&lt; 8), 
<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca3e85b14c1b64dbfef1d0b4b7bc39c19d">kUART_RxOverrunInterruptEnable</a> = (UART_C3_ORIE_MASK &lt;&lt; 16), 
<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca53d0fe2bb0cd90198c632f08488af4b3">kUART_NoiseErrorInterruptEnable</a> = (UART_C3_NEIE_MASK &lt;&lt; 16), 
<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca00a387446d0ca7fd843968eca8af22a5">kUART_FramingErrorInterruptEnable</a> = (UART_C3_FEIE_MASK &lt;&lt; 16), 
<br />
&#160;&#160;<a class="el" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311cadc2475fa65313c6f1d13b36f0443b20a">kUART_ParityErrorInterruptEnable</a> = (UART_C3_PEIE_MASK &lt;&lt; 16), 
<b>kUART_AllInterruptsEnable</b>
<br />
 }</td></tr>
<tr class="memdesc:ga700f3cd8e3800273a1591307cab6311c"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART interrupt configuration structure, default settings all disabled.  <a href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">More...</a><br /></td></tr>
<tr class="separator:ga700f3cd8e3800273a1591307cab6311c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga259a53f363288115306a45d08fc66eb8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga259a53f363288115306a45d08fc66eb8">_uart_flags</a> { <br />
&#160;&#160;<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8a5209c671b2f2f064dc512655387e9e1a">kUART_TxDataRegEmptyFlag</a> = (UART_S1_TDRE_MASK), 
<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8a4468b60b2d78c34b93c9199df9e95d3a">kUART_TransmissionCompleteFlag</a> = (UART_S1_TC_MASK), 
<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8aa86a34b2ea609eeeb63f98fea498e540">kUART_RxDataRegFullFlag</a> = (UART_S1_RDRF_MASK), 
<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8ab2fc4e1b1164ed3e3fe7e19a39029b2c">kUART_IdleLineFlag</a> = (UART_S1_IDLE_MASK), 
<br />
&#160;&#160;<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8a93d3c56466b4656dcce08d9323d7afd8">kUART_RxOverrunFlag</a> = (UART_S1_OR_MASK), 
<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8abd56419f102fb01c7bbc2c38f81ab360">kUART_NoiseErrorFlag</a> = (UART_S1_NF_MASK), 
<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8aade5071fa56646adcda3562051443868">kUART_FramingErrorFlag</a> = (UART_S1_FE_MASK), 
<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8a0c92973ab1d527115fa01934c62a053d">kUART_ParityErrorFlag</a> = (UART_S1_PF_MASK), 
<br />
&#160;&#160;<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8adcfe89feb164ff5b1720312922006a7a">kUART_RxActiveEdgeFlag</a>, 
<a class="el" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8a7a4521cd44a3272a94784670d1bf5a0c">kUART_RxActiveFlag</a>
<br />
 }</td></tr>
<tr class="memdesc:ga259a53f363288115306a45d08fc66eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART status flags.  <a href="group__uart__driver.html#ga259a53f363288115306a45d08fc66eb8">More...</a><br /></td></tr>
<tr class="separator:ga259a53f363288115306a45d08fc66eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadeeb40cdc314638d4355ef906f1c408d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gadeeb40cdc314638d4355ef906f1c408d">UART_GetInstance</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base)</td></tr>
<tr class="memdesc:gadeeb40cdc314638d4355ef906f1c408d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the UART instance from peripheral base address.  <a href="#gadeeb40cdc314638d4355ef906f1c408d">More...</a><br /></td></tr>
<tr class="separator:gadeeb40cdc314638d4355ef906f1c408d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Driver version</h2></td></tr>
<tr class="memitem:ga89f9649bfe350eb7b1e53146f35d3de5"><td class="memItemLeft" align="right" valign="top"><a id="ga89f9649bfe350eb7b1e53146f35d3de5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga89f9649bfe350eb7b1e53146f35d3de5">FSL_UART_DRIVER_VERSION</a>&#160;&#160;&#160;(<a class="el" href="group__ftfx__utilities.html#ga812138aa3315b0c6953c1a26130bcc37">MAKE_VERSION</a>(2, 1, 7))</td></tr>
<tr class="memdesc:ga89f9649bfe350eb7b1e53146f35d3de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART driver version 2.1.7. <br /></td></tr>
<tr class="separator:ga89f9649bfe350eb7b1e53146f35d3de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Initialization and deinitialization</h2></td></tr>
<tr class="memitem:gab5965a8e11f7e1d4d531141291fd5288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gab5965a8e11f7e1d4d531141291fd5288">UART_Init</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, const <a class="el" href="group__uart__driver.html#ga032da70848aac8bc9c3904a32bde5899">uart_config_t</a> *config, uint32_t srcClock_Hz)</td></tr>
<tr class="memdesc:gab5965a8e11f7e1d4d531141291fd5288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a UART instance with a user configuration structure and peripheral clock.  <a href="#gab5965a8e11f7e1d4d531141291fd5288">More...</a><br /></td></tr>
<tr class="separator:gab5965a8e11f7e1d4d531141291fd5288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ff48bc211831be33e6fe5c50eb671a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga3ff48bc211831be33e6fe5c50eb671a0">UART_Deinit</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base)</td></tr>
<tr class="memdesc:ga3ff48bc211831be33e6fe5c50eb671a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes a UART instance.  <a href="#ga3ff48bc211831be33e6fe5c50eb671a0">More...</a><br /></td></tr>
<tr class="separator:ga3ff48bc211831be33e6fe5c50eb671a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47c7c09e04a0497f4530d553e27d96c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga47c7c09e04a0497f4530d553e27d96c5">UART_GetDefaultConfig</a> (<a class="el" href="group__uart__driver.html#ga032da70848aac8bc9c3904a32bde5899">uart_config_t</a> *config)</td></tr>
<tr class="memdesc:ga47c7c09e04a0497f4530d553e27d96c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default configuration structure.  <a href="#ga47c7c09e04a0497f4530d553e27d96c5">More...</a><br /></td></tr>
<tr class="separator:ga47c7c09e04a0497f4530d553e27d96c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3ba5019c11f288cc4f545dd656b6284"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gab3ba5019c11f288cc4f545dd656b6284">UART_SetBaudRate</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz)</td></tr>
<tr class="memdesc:gab3ba5019c11f288cc4f545dd656b6284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the UART instance baud rate.  <a href="#gab3ba5019c11f288cc4f545dd656b6284">More...</a><br /></td></tr>
<tr class="separator:gab3ba5019c11f288cc4f545dd656b6284"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Status</h2></td></tr>
<tr class="memitem:ga28bf715678c0d3c8c3902e79455ee923"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga28bf715678c0d3c8c3902e79455ee923">UART_GetStatusFlags</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base)</td></tr>
<tr class="memdesc:ga28bf715678c0d3c8c3902e79455ee923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets UART status flags.  <a href="#ga28bf715678c0d3c8c3902e79455ee923">More...</a><br /></td></tr>
<tr class="separator:ga28bf715678c0d3c8c3902e79455ee923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc4cb85534361f836edca9454a6426c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gacc4cb85534361f836edca9454a6426c6">UART_ClearStatusFlags</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:gacc4cb85534361f836edca9454a6426c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears status flags with the provided mask.  <a href="#gacc4cb85534361f836edca9454a6426c6">More...</a><br /></td></tr>
<tr class="separator:gacc4cb85534361f836edca9454a6426c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Interrupts</h2></td></tr>
<tr class="memitem:ga49ecd761481a22956e3f46285038719c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga49ecd761481a22956e3f46285038719c">UART_EnableInterrupts</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:ga49ecd761481a22956e3f46285038719c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables UART interrupts according to the provided mask.  <a href="#ga49ecd761481a22956e3f46285038719c">More...</a><br /></td></tr>
<tr class="separator:ga49ecd761481a22956e3f46285038719c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f24b6b9b730046a9a81918f9abe7d99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga3f24b6b9b730046a9a81918f9abe7d99">UART_DisableInterrupts</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, uint32_t mask)</td></tr>
<tr class="memdesc:ga3f24b6b9b730046a9a81918f9abe7d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the UART interrupts according to the provided mask.  <a href="#ga3f24b6b9b730046a9a81918f9abe7d99">More...</a><br /></td></tr>
<tr class="separator:ga3f24b6b9b730046a9a81918f9abe7d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79bc0b880286ec0dc0543606fc772912"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga79bc0b880286ec0dc0543606fc772912">UART_GetEnabledInterrupts</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base)</td></tr>
<tr class="memdesc:ga79bc0b880286ec0dc0543606fc772912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the enabled UART interrupts.  <a href="#ga79bc0b880286ec0dc0543606fc772912">More...</a><br /></td></tr>
<tr class="separator:ga79bc0b880286ec0dc0543606fc772912"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bus Operations</h2></td></tr>
<tr class="memitem:gad67794d80b7ee2d3292b41af6ff1e100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gad67794d80b7ee2d3292b41af6ff1e100">UART_WriteBlocking</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, const uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:gad67794d80b7ee2d3292b41af6ff1e100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes to the TX register using a blocking method.  <a href="#gad67794d80b7ee2d3292b41af6ff1e100">More...</a><br /></td></tr>
<tr class="separator:gad67794d80b7ee2d3292b41af6ff1e100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39d59e8a94f1af451a0db81888596639"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga39d59e8a94f1af451a0db81888596639">UART_ReadBlocking</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, uint8_t *data, size_t length)</td></tr>
<tr class="memdesc:ga39d59e8a94f1af451a0db81888596639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read RX data register using a blocking method.  <a href="#ga39d59e8a94f1af451a0db81888596639">More...</a><br /></td></tr>
<tr class="separator:ga39d59e8a94f1af451a0db81888596639"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Transactional</h2></td></tr>
<tr class="memitem:ga63db308c32019b7dd6c0647d618e5247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga63db308c32019b7dd6c0647d618e5247">UART_TransferCreateHandle</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle, <a class="el" href="group__uart__driver.html#ga2868b6ea396ab212547f2157380429c5">uart_transfer_callback_t</a> callback, void *userData)</td></tr>
<tr class="memdesc:ga63db308c32019b7dd6c0647d618e5247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the UART handle.  <a href="#ga63db308c32019b7dd6c0647d618e5247">More...</a><br /></td></tr>
<tr class="separator:ga63db308c32019b7dd6c0647d618e5247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga223fba584bfabd599629d5ce92f929ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga223fba584bfabd599629d5ce92f929ac">UART_TransferStartRingBuffer</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle, uint8_t *ringBuffer, size_t ringBufferSize)</td></tr>
<tr class="memdesc:ga223fba584bfabd599629d5ce92f929ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the RX ring buffer.  <a href="#ga223fba584bfabd599629d5ce92f929ac">More...</a><br /></td></tr>
<tr class="separator:ga223fba584bfabd599629d5ce92f929ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c0bc73df49cb31dff0e903630314f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga0c0bc73df49cb31dff0e903630314f5b">UART_TransferStopRingBuffer</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:ga0c0bc73df49cb31dff0e903630314f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the background transfer and uninstalls the ring buffer.  <a href="#ga0c0bc73df49cb31dff0e903630314f5b">More...</a><br /></td></tr>
<tr class="separator:ga0c0bc73df49cb31dff0e903630314f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3921aa660977ca77dadf95fa35f1c3a9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga3921aa660977ca77dadf95fa35f1c3a9">UART_TransferGetRxRingBufferLength</a> (<a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:ga3921aa660977ca77dadf95fa35f1c3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of received data in RX ring buffer.  <a href="#ga3921aa660977ca77dadf95fa35f1c3a9">More...</a><br /></td></tr>
<tr class="separator:ga3921aa660977ca77dadf95fa35f1c3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89afd7db1656c5aef404bb285d0dc05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gad89afd7db1656c5aef404bb285d0dc05">UART_TransferSendNonBlocking</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle, <a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df">uart_transfer_t</a> *xfer)</td></tr>
<tr class="memdesc:gad89afd7db1656c5aef404bb285d0dc05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits a buffer of data using the interrupt method.  <a href="#gad89afd7db1656c5aef404bb285d0dc05">More...</a><br /></td></tr>
<tr class="separator:gad89afd7db1656c5aef404bb285d0dc05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64f9f89d8286fd3ef0736a8c40be2c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gaa64f9f89d8286fd3ef0736a8c40be2c2">UART_TransferAbortSend</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:gaa64f9f89d8286fd3ef0736a8c40be2c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the interrupt-driven data transmit.  <a href="#gaa64f9f89d8286fd3ef0736a8c40be2c2">More...</a><br /></td></tr>
<tr class="separator:gaa64f9f89d8286fd3ef0736a8c40be2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga071727ba05b2937ef5ad641ca7faf9c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga071727ba05b2937ef5ad641ca7faf9c7">UART_TransferGetSendCount</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle, uint32_t *count)</td></tr>
<tr class="memdesc:ga071727ba05b2937ef5ad641ca7faf9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes written to the UART TX register.  <a href="#ga071727ba05b2937ef5ad641ca7faf9c7">More...</a><br /></td></tr>
<tr class="separator:ga071727ba05b2937ef5ad641ca7faf9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf804acde5d73ce0a5bf54b06195e1218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gaf804acde5d73ce0a5bf54b06195e1218">UART_TransferReceiveNonBlocking</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle, <a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df">uart_transfer_t</a> *xfer, size_t *receivedBytes)</td></tr>
<tr class="memdesc:gaf804acde5d73ce0a5bf54b06195e1218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a buffer of data using an interrupt method.  <a href="#gaf804acde5d73ce0a5bf54b06195e1218">More...</a><br /></td></tr>
<tr class="separator:gaf804acde5d73ce0a5bf54b06195e1218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc35671622b2401545cc55cc6ae572d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gacc35671622b2401545cc55cc6ae572d4">UART_TransferAbortReceive</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:gacc35671622b2401545cc55cc6ae572d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts the interrupt-driven data receiving.  <a href="#gacc35671622b2401545cc55cc6ae572d4">More...</a><br /></td></tr>
<tr class="separator:gacc35671622b2401545cc55cc6ae572d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05df10f570cdca4ac2dff63b069d254e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#ga05df10f570cdca4ac2dff63b069d254e">UART_TransferGetReceiveCount</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle, uint32_t *count)</td></tr>
<tr class="memdesc:ga05df10f570cdca4ac2dff63b069d254e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of bytes that have been received.  <a href="#ga05df10f570cdca4ac2dff63b069d254e">More...</a><br /></td></tr>
<tr class="separator:ga05df10f570cdca4ac2dff63b069d254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb0c4f1e5b59db3aa2261df4f5ddb48d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gadb0c4f1e5b59db3aa2261df4f5ddb48d">UART_TransferHandleIRQ</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:gadb0c4f1e5b59db3aa2261df4f5ddb48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART IRQ handle function.  <a href="#gadb0c4f1e5b59db3aa2261df4f5ddb48d">More...</a><br /></td></tr>
<tr class="separator:gadb0c4f1e5b59db3aa2261df4f5ddb48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc364352e879f53138ee1107e3da0a7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__uart__driver.html#gafc364352e879f53138ee1107e3da0a7d">UART_TransferHandleErrorIRQ</a> (<a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *base, <a class="el" href="struct__uart__handle.html">uart_handle_t</a> *handle)</td></tr>
<tr class="memdesc:gafc364352e879f53138ee1107e3da0a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART Error IRQ handle function.  <a href="#gafc364352e879f53138ee1107e3da0a7d">More...</a><br /></td></tr>
<tr class="separator:gafc364352e879f53138ee1107e3da0a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga259a53f363288115306a45d08fc66eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga259a53f363288115306a45d08fc66eb8">&#9670;&nbsp;</a></span>_uart_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__uart__driver.html#ga259a53f363288115306a45d08fc66eb8">_uart_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART status flags. </p>
<p>This provides constants for the UART status flags for use in the UART functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8a5209c671b2f2f064dc512655387e9e1a"></a>kUART_TxDataRegEmptyFlag&#160;</td><td class="fielddoc"><p>TX data register empty flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8a4468b60b2d78c34b93c9199df9e95d3a"></a>kUART_TransmissionCompleteFlag&#160;</td><td class="fielddoc"><p>Transmission complete flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8aa86a34b2ea609eeeb63f98fea498e540"></a>kUART_RxDataRegFullFlag&#160;</td><td class="fielddoc"><p>RX data register full flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8ab2fc4e1b1164ed3e3fe7e19a39029b2c"></a>kUART_IdleLineFlag&#160;</td><td class="fielddoc"><p>Idle line detect flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8a93d3c56466b4656dcce08d9323d7afd8"></a>kUART_RxOverrunFlag&#160;</td><td class="fielddoc"><p>RX overrun flag. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8abd56419f102fb01c7bbc2c38f81ab360"></a>kUART_NoiseErrorFlag&#160;</td><td class="fielddoc"><p>RX takes 3 samples of each received bit. If any of these samples differ, noise flag sets </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8aade5071fa56646adcda3562051443868"></a>kUART_FramingErrorFlag&#160;</td><td class="fielddoc"><p>Frame error flag, sets if logic 0 was detected where stop bit expected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8a0c92973ab1d527115fa01934c62a053d"></a>kUART_ParityErrorFlag&#160;</td><td class="fielddoc"><p>If parity enabled, sets upon parity error detection </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8adcfe89feb164ff5b1720312922006a7a"></a>kUART_RxActiveEdgeFlag&#160;</td><td class="fielddoc"><p>RX pin active edge interrupt flag,sets when active edge detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga259a53f363288115306a45d08fc66eb8a7a4521cd44a3272a94784670d1bf5a0c"></a>kUART_RxActiveFlag&#160;</td><td class="fielddoc"><p>Receiver Active Flag (RAF), sets at beginning of valid start bit </p>
</td></tr>
</table>

</div>
</div>
<a id="gae658ead369268edf18141e1903d426f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae658ead369268edf18141e1903d426f1">&#9670;&nbsp;</a></span>_uart_idle_type_select</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__uart__driver.html#gae658ead369268edf18141e1903d426f1">_uart_idle_type_select</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART idle type select. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae658ead369268edf18141e1903d426f1a5216f34232b8d01cdd8db1ca01072901"></a>kUART_IdleTypeStartBit&#160;</td><td class="fielddoc"><p>Start counting after a valid start bit. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae658ead369268edf18141e1903d426f1a05771d6cd97e160c6a47d5871d2de013"></a>kUART_IdleTypeStopBit&#160;</td><td class="fielddoc"><p>Start counting after a stop bit. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga700f3cd8e3800273a1591307cab6311c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga700f3cd8e3800273a1591307cab6311c">&#9670;&nbsp;</a></span>_uart_interrupt_enable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART interrupt configuration structure, default settings all disabled. </p>
<p>This structure contains the settings for all of the UART interrupt configurations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311ca71755319c216d0bdf79729c18c24cf64"></a>kUART_RxActiveEdgeInterruptEnable&#160;</td><td class="fielddoc"><p>RX active edge interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14"></a>kUART_TxDataRegEmptyInterruptEnable&#160;</td><td class="fielddoc"><p>Transmit data register empty interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311cafd337213dae85b532dfaf9a90e2e5d7b"></a>kUART_TransmissionCompleteInterruptEnable&#160;</td><td class="fielddoc"><p>Transmission complete interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3"></a>kUART_RxDataRegFullInterruptEnable&#160;</td><td class="fielddoc"><p>Receiver data register full interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311ca078ea32d8587f92337a3dee495a1ceed"></a>kUART_IdleLineInterruptEnable&#160;</td><td class="fielddoc"><p>Idle line interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311ca3e85b14c1b64dbfef1d0b4b7bc39c19d"></a>kUART_RxOverrunInterruptEnable&#160;</td><td class="fielddoc"><p>Receiver overrun interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311ca53d0fe2bb0cd90198c632f08488af4b3"></a>kUART_NoiseErrorInterruptEnable&#160;</td><td class="fielddoc"><p>Noise error flag interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311ca00a387446d0ca7fd843968eca8af22a5"></a>kUART_FramingErrorInterruptEnable&#160;</td><td class="fielddoc"><p>Framing error flag interrupt. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga700f3cd8e3800273a1591307cab6311cadc2475fa65313c6f1d13b36f0443b20a"></a>kUART_ParityErrorInterruptEnable&#160;</td><td class="fielddoc"><p>Parity error flag interrupt. </p>
</td></tr>
</table>

</div>
</div>
<a id="gadf9f66755acc340eab030e1a48e35e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf9f66755acc340eab030e1a48e35e10">&#9670;&nbsp;</a></span>_uart_parity_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__uart__driver.html#gadf9f66755acc340eab030e1a48e35e10">_uart_parity_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART parity mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadf9f66755acc340eab030e1a48e35e10a97e2feae6671a6de1126ebc2edf4606b"></a>kUART_ParityDisabled&#160;</td><td class="fielddoc"><p>Parity disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadf9f66755acc340eab030e1a48e35e10a9e68fe3aba46e045bee5433ed098bff0"></a>kUART_ParityEven&#160;</td><td class="fielddoc"><p>Parity enabled, type even, bit setting: PE|PT = 10 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadf9f66755acc340eab030e1a48e35e10ae48c7fabc9babf1be626ebeb2627a54c"></a>kUART_ParityOdd&#160;</td><td class="fielddoc"><p>Parity enabled, type odd, bit setting: PE|PT = 11 </p>
</td></tr>
</table>

</div>
</div>
<a id="gacef40dc8e8ac174bfe40ebcbc980f84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacef40dc8e8ac174bfe40ebcbc980f84b">&#9670;&nbsp;</a></span>_uart_status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__uart__driver.html#gacef40dc8e8ac174bfe40ebcbc980f84b">_uart_status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes for the UART driver. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba19ddee4fe5963467600028b78fb468e7"></a>kStatus_UART_TxBusy&#160;</td><td class="fielddoc"><p>Transmitter is busy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba68cf23f981c4b85f82291163fbb2a5e6"></a>kStatus_UART_RxBusy&#160;</td><td class="fielddoc"><p>Receiver is busy. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84baf36c829b1b889517bf775c0d7ce29fa6"></a>kStatus_UART_TxIdle&#160;</td><td class="fielddoc"><p>UART transmitter is idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407"></a>kStatus_UART_RxIdle&#160;</td><td class="fielddoc"><p>UART receiver is idle. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba765913f003819ed87b861d187bf79ab8"></a>kStatus_UART_TxWatermarkTooLarge&#160;</td><td class="fielddoc"><p>TX FIFO watermark too large </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba720cefde05389830f35f6e6df6f6ac67"></a>kStatus_UART_RxWatermarkTooLarge&#160;</td><td class="fielddoc"><p>RX FIFO watermark too large </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba5ee8e23fc9ab20cf366942751b895f54"></a>kStatus_UART_FlagCannotClearManually&#160;</td><td class="fielddoc"><p>UART flag can't be manually cleared. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba950972a9e2ebbaa13c92e8f5a51f785d"></a>kStatus_UART_Error&#160;</td><td class="fielddoc"><p>Error happens on UART. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba2e5b644b1e10c426af818bc78657e992"></a>kStatus_UART_RxRingBufferOverrun&#160;</td><td class="fielddoc"><p>UART RX software ring buffer overrun. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84bab6b1fd6c2deec25992449f5b12303a26"></a>kStatus_UART_RxHardwareOverrun&#160;</td><td class="fielddoc"><p>UART RX receiver overrun. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84bae4ef4df9a5f756ccf1b4bf08292ec2fb"></a>kStatus_UART_NoiseError&#160;</td><td class="fielddoc"><p>UART noise error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84baa7aa134f85df3d5863ca962ce1ea7ee0"></a>kStatus_UART_FramingError&#160;</td><td class="fielddoc"><p>UART framing error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84baea20b2588c38f259f1412aa7132c9ef8"></a>kStatus_UART_ParityError&#160;</td><td class="fielddoc"><p>UART parity error. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84bae6cdb41e1b49958f57727cd47afd69b2"></a>kStatus_UART_BaudrateNotSupport&#160;</td><td class="fielddoc"><p>Baudrate is not support in current clock source </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacef40dc8e8ac174bfe40ebcbc980f84ba3e5b488f7ed418cb08399a5db193103e"></a>kStatus_UART_IdleLineDetected&#160;</td><td class="fielddoc"><p>UART IDLE line detected. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga3c656a4365cab1185398ff953272091e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c656a4365cab1185398ff953272091e">&#9670;&nbsp;</a></span>_uart_stop_bit_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__uart__driver.html#ga3c656a4365cab1185398ff953272091e">_uart_stop_bit_count</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART stop bit count. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3c656a4365cab1185398ff953272091ea5a8829a108d8a46abb097a36cde051a7"></a>kUART_OneStopBit&#160;</td><td class="fielddoc"><p>One stop bit </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3c656a4365cab1185398ff953272091ea9704b3ae3ee851acf324eb357f75ab56"></a>kUART_TwoStopBit&#160;</td><td class="fielddoc"><p>Two stop bits </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gacc4cb85534361f836edca9454a6426c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc4cb85534361f836edca9454a6426c6">&#9670;&nbsp;</a></span>UART_ClearStatusFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_ClearStatusFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears status flags with the provided mask. </p>
<p>This function clears UART status flags with a provided mask. An automatically cleared flag can't be cleared by this function. These flags can only be cleared or set by hardware. kUART_TxDataRegEmptyFlag, kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag, kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag,kUART_RxFifoEmptyFlag Note that this API should be called when the Tx/Rx is idle. Otherwise it has no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The status flags to be cleared; it is logical OR value of <a class="el" href="group__uart__driver.html#ga259a53f363288115306a45d08fc66eb8">_uart_flags</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_FlagCannotClearManually</td><td>The flag can't be cleared by this function but it is cleared automatically by hardware. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Status in the mask is cleared.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Clears status flags with the provided mask.</p>
<p>This function clears UART status flags with a provided mask. An automatically cleared flag can't be cleared by this function. These flags can only be cleared or set by hardware. kUART_TxDataRegEmptyFlag, kUART_TransmissionCompleteFlag, kUART_RxDataRegFullFlag, kUART_RxActiveFlag, kUART_NoiseErrorInRxDataRegFlag, kUART_ParityErrorInRxDataRegFlag, kUART_TxFifoEmptyFlag,kUART_RxFifoEmptyFlag Note that this API should be called when the Tx/Rx is idle. Otherwise it has no effect.</p>
<p>param base UART peripheral base address. param mask The status flags to be cleared; it is logical OR value of ref _uart_flags. retval kStatus_UART_FlagCannotClearManually The flag can't be cleared by this function but it is cleared automatically by hardware. retval kStatus_Success Status in the mask is cleared. </p>

</div>
</div>
<a id="ga3ff48bc211831be33e6fe5c50eb671a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ff48bc211831be33e6fe5c50eb671a0">&#9670;&nbsp;</a></span>UART_Deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_Deinit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deinitializes a UART instance. </p>
<p>This function waits for TX complete, disables TX and RX, and disables the UART clock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Deinitializes a UART instance.</p>
<p>This function waits for TX complete, disables TX and RX, and disables the UART clock.</p>
<p>param base UART peripheral base address. </p>

</div>
</div>
<a id="ga3f24b6b9b730046a9a81918f9abe7d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f24b6b9b730046a9a81918f9abe7d99">&#9670;&nbsp;</a></span>UART_DisableInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_DisableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the UART interrupts according to the provided mask. </p>
<p>This function disables the UART interrupts according to the provided mask. The mask is a logical OR of enumeration members. See <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a>. For example, to disable TX empty interrupt and RX full interrupt do the following. </p><div class="fragment"><div class="line"><a class="code" href="group__uart__driver.html#ga3f24b6b9b730046a9a81918f9abe7d99">UART_DisableInterrupts</a>(UART1,<a class="code" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14">kUART_TxDataRegEmptyInterruptEnable</a> | <a class="code" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3">kUART_RxDataRegFullInterruptEnable</a>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The interrupts to disable. Logical OR of <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Disables the UART interrupts according to the provided mask.</p>
<p>This function disables the UART interrupts according to the provided mask. The mask is a logical OR of enumeration members. See ref _uart_interrupt_enable. For example, to disable TX empty interrupt and RX full interrupt do the following. code UART_DisableInterrupts(UART1,kUART_TxDataRegEmptyInterruptEnable | kUART_RxDataRegFullInterruptEnable); endcode</p>
<p>param base UART peripheral base address. param mask The interrupts to disable. Logical OR of ref _uart_interrupt_enable. </p>

</div>
</div>
<a id="ga49ecd761481a22956e3f46285038719c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49ecd761481a22956e3f46285038719c">&#9670;&nbsp;</a></span>UART_EnableInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_EnableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables UART interrupts according to the provided mask. </p>
<p>This function enables the UART interrupts according to the provided mask. The mask is a logical OR of enumeration members. See <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a>. For example, to enable TX empty interrupt and RX full interrupt, do the following. </p><div class="fragment"><div class="line"><a class="code" href="group__uart__driver.html#ga49ecd761481a22956e3f46285038719c">UART_EnableInterrupts</a>(UART1,<a class="code" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14">kUART_TxDataRegEmptyInterruptEnable</a> | <a class="code" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311cac8a751a334e172413ab833cb0ccb01c3">kUART_RxDataRegFullInterruptEnable</a>);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">mask</td><td>The interrupts to enable. Logical OR of <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Enables UART interrupts according to the provided mask.</p>
<p>This function enables the UART interrupts according to the provided mask. The mask is a logical OR of enumeration members. See ref _uart_interrupt_enable. For example, to enable TX empty interrupt and RX full interrupt, do the following. code UART_EnableInterrupts(UART1,kUART_TxDataRegEmptyInterruptEnable | kUART_RxDataRegFullInterruptEnable); endcode</p>
<p>param base UART peripheral base address. param mask The interrupts to enable. Logical OR of ref _uart_interrupt_enable. </p>

</div>
</div>
<a id="ga47c7c09e04a0497f4530d553e27d96c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47c7c09e04a0497f4530d553e27d96c5">&#9670;&nbsp;</a></span>UART_GetDefaultConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_GetDefaultConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__uart__driver.html#ga032da70848aac8bc9c3904a32bde5899">uart_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the default configuration structure. </p>
<p>This function initializes the UART configuration structure to a default value. The default values are as follows. uartConfig-&gt;baudRate_Bps = 115200U; uartConfig-&gt;bitCountPerChar = kUART_8BitsPerChar; uartConfig-&gt;parityMode = kUART_ParityDisabled; uartConfig-&gt;stopBitCount = kUART_OneStopBit; uartConfig-&gt;txFifoWatermark = 0; uartConfig-&gt;rxFifoWatermark = 1; uartConfig-&gt;idleType = kUART_IdleTypeStartBit; uartConfig-&gt;enableTx = false; uartConfig-&gt;enableRx = false;</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the default configuration structure.</p>
<p>This function initializes the UART configuration structure to a default value. The default values are as follows. uartConfig-&gt;baudRate_Bps = 115200U; uartConfig-&gt;bitCountPerChar = kUART_8BitsPerChar; uartConfig-&gt;parityMode = kUART_ParityDisabled; uartConfig-&gt;stopBitCount = kUART_OneStopBit; uartConfig-&gt;txFifoWatermark = 0; uartConfig-&gt;rxFifoWatermark = 1; uartConfig-&gt;idleType = kUART_IdleTypeStartBit; uartConfig-&gt;enableTx = false; uartConfig-&gt;enableRx = false;</p>
<p>param config Pointer to configuration structure. </p>

</div>
</div>
<a id="ga79bc0b880286ec0dc0543606fc772912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79bc0b880286ec0dc0543606fc772912">&#9670;&nbsp;</a></span>UART_GetEnabledInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UART_GetEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the enabled UART interrupts. </p>
<p>This function gets the enabled UART interrupts. The enabled interrupts are returned as the logical OR value of the enumerators <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a>. To check a specific interrupts enable status, compare the return value with enumerators in <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a>. For example, to check whether TX empty interrupt is enabled, do the following. </p><div class="fragment"><div class="line">uint32_t enabledInterrupts = <a class="code" href="group__uart__driver.html#ga79bc0b880286ec0dc0543606fc772912">UART_GetEnabledInterrupts</a>(UART1);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__uart__driver.html#gga700f3cd8e3800273a1591307cab6311ca5a0870233f2ffa8f5ca60d80f1e3ed14">kUART_TxDataRegEmptyInterruptEnable</a> &amp; enabledInterrupts)</div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART interrupt flags which are logical OR of the enumerators in <a class="el" href="group__uart__driver.html#ga700f3cd8e3800273a1591307cab6311c">_uart_interrupt_enable</a>.</dd></dl>
<p>brief Gets the enabled UART interrupts.</p>
<p>This function gets the enabled UART interrupts. The enabled interrupts are returned as the logical OR value of the enumerators ref _uart_interrupt_enable. To check a specific interrupts enable status, compare the return value with enumerators in ref _uart_interrupt_enable. For example, to check whether TX empty interrupt is enabled, do the following. code uint32_t enabledInterrupts = UART_GetEnabledInterrupts(UART1);</p>
<p>if (kUART_TxDataRegEmptyInterruptEnable &amp; enabledInterrupts) { ... } endcode</p>
<p>param base UART peripheral base address. return UART interrupt flags which are logical OR of the enumerators in ref _uart_interrupt_enable. </p>

</div>
</div>
<a id="gadeeb40cdc314638d4355ef906f1c408d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadeeb40cdc314638d4355ef906f1c408d">&#9670;&nbsp;</a></span>UART_GetInstance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UART_GetInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the UART instance from peripheral base address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART instance.</dd></dl>
<p>brief Get the UART instance from peripheral base address.</p>
<p>param base UART peripheral base address. return UART instance. </p>

</div>
</div>
<a id="ga28bf715678c0d3c8c3902e79455ee923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28bf715678c0d3c8c3902e79455ee923">&#9670;&nbsp;</a></span>UART_GetStatusFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t UART_GetStatusFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets UART status flags. </p>
<p>This function gets all UART status flags. The flags are returned as the logical OR value of the enumerators <a class="el" href="group__uart__driver.html#ga259a53f363288115306a45d08fc66eb8">_uart_flags</a>. To check a specific status, compare the return value with enumerators in <a class="el" href="group__uart__driver.html#ga259a53f363288115306a45d08fc66eb8">_uart_flags</a>. For example, to check whether the TX is empty, do the following. </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="group__uart__driver.html#gga259a53f363288115306a45d08fc66eb8a5209c671b2f2f064dc512655387e9e1a">kUART_TxDataRegEmptyFlag</a> &amp; <a class="code" href="group__uart__driver.html#ga28bf715678c0d3c8c3902e79455ee923">UART_GetStatusFlags</a>(UART1))</div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UART status flags which are ORed by the enumerators in the _uart_flags.</dd></dl>
<p>brief Gets UART status flags.</p>
<p>This function gets all UART status flags. The flags are returned as the logical OR value of the enumerators ref _uart_flags. To check a specific status, compare the return value with enumerators in ref _uart_flags. For example, to check whether the TX is empty, do the following. code if (kUART_TxDataRegEmptyFlag &amp; UART_GetStatusFlags(UART1)) { ... } endcode</p>
<p>param base UART peripheral base address. return UART status flags which are ORed by the enumerators in the _uart_flags. </p>

</div>
</div>
<a id="gab5965a8e11f7e1d4d531141291fd5288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5965a8e11f7e1d4d531141291fd5288">&#9670;&nbsp;</a></span>UART_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__uart__driver.html#ga032da70848aac8bc9c3904a32bde5899">uart_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcClock_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a UART instance with a user configuration structure and peripheral clock. </p>
<p>This function configures the UART module with the user-defined settings. The user can configure the configuration structure and also get the default configuration by using the <a class="el" href="group__uart__driver.html#ga47c7c09e04a0497f4530d553e27d96c5" title="Gets the default configuration structure.">UART_GetDefaultConfig()</a> function. The example below shows how to use this API to configure UART. </p><div class="fragment"><div class="line"><a class="code" href="struct__uart__config.html">uart_config_t</a> uartConfig;</div><div class="line">uartConfig.<a class="code" href="struct__uart__config.html#aa5df547b4cb95d3c959373cf6fa672b5">baudRate_Bps</a> = 115200U;</div><div class="line">uartConfig.<a class="code" href="struct__uart__config.html#a316fd94f4c5e6d15a3cda133d5dd5683">parityMode</a> = <a class="code" href="group__uart__driver.html#ggadf9f66755acc340eab030e1a48e35e10a97e2feae6671a6de1126ebc2edf4606b">kUART_ParityDisabled</a>;</div><div class="line">uartConfig.stopBitCount = <a class="code" href="group__uart__driver.html#gga3c656a4365cab1185398ff953272091ea5a8829a108d8a46abb097a36cde051a7">kUART_OneStopBit</a>;</div><div class="line">uartConfig.txFifoWatermark = 0;</div><div class="line">uartConfig.rxFifoWatermark = 1;</div><div class="line"><a class="code" href="group__uart__driver.html#gab5965a8e11f7e1d4d531141291fd5288">UART_Init</a>(UART1, &amp;uartConfig, 20000000U);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">config</td><td>Pointer to the user-defined configuration structure. </td></tr>
    <tr><td class="paramname">srcClock_Hz</td><td>UART clock source frequency in HZ. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_BaudrateNotSupport</td><td>Baudrate is not support in current clock source. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Status UART initialize succeed</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes a UART instance with a user configuration structure and peripheral clock.</p>
<p>This function configures the UART module with the user-defined settings. The user can configure the configuration structure and also get the default configuration by using the <a class="el" href="group__uart__driver.html#ga47c7c09e04a0497f4530d553e27d96c5" title="Gets the default configuration structure.">UART_GetDefaultConfig()</a> function. The example below shows how to use this API to configure UART. code uart_config_t uartConfig; uartConfig.baudRate_Bps = 115200U; uartConfig.parityMode = kUART_ParityDisabled; uartConfig.stopBitCount = kUART_OneStopBit; uartConfig.txFifoWatermark = 0; uartConfig.rxFifoWatermark = 1; UART_Init(UART1, &amp;uartConfig, 20000000U); endcode</p>
<p>param base UART peripheral base address. param config Pointer to the user-defined configuration structure. param srcClock_Hz UART clock source frequency in HZ. retval kStatus_UART_BaudrateNotSupport Baudrate is not support in current clock source. retval kStatus_Success Status UART initialize succeed </p>

</div>
</div>
<a id="ga39d59e8a94f1af451a0db81888596639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39d59e8a94f1af451a0db81888596639">&#9670;&nbsp;</a></span>UART_ReadBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_ReadBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read RX data register using a blocking method. </p>
<p>This function polls the RX register, waits for the RX register to be full or for RX FIFO to have data, and reads data from the TX register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">data</td><td>Start address of the buffer to store the received data. </td></tr>
    <tr><td class="paramname">length</td><td>Size of the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_RxHardwareOverrun</td><td>Receiver overrun occurred while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_UART_NoiseError</td><td>A noise error occurred while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_UART_FramingError</td><td>A framing error occurred while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_UART_ParityError</td><td>A parity error occurred while receiving data. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Successfully received all data.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Read RX data register using a blocking method.</p>
<p>This function polls the RX register, waits for the RX register to be full or for RX FIFO to have data, and reads data from the TX register.</p>
<p>param base UART peripheral base address. param data Start address of the buffer to store the received data. param length Size of the buffer. retval kStatus_UART_RxHardwareOverrun Receiver overrun occurred while receiving data. retval kStatus_UART_NoiseError A noise error occurred while receiving data. retval kStatus_UART_FramingError A framing error occurred while receiving data. retval kStatus_UART_ParityError A parity error occurred while receiving data. retval kStatus_Success Successfully received all data. </p>

</div>
</div>
<a id="gab3ba5019c11f288cc4f545dd656b6284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3ba5019c11f288cc4f545dd656b6284">&#9670;&nbsp;</a></span>UART_SetBaudRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_SetBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudRate_Bps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>srcClock_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the UART instance baud rate. </p>
<p>This function configures the UART module baud rate. This function is used to update the UART module baud rate after the UART module is initialized by the UART_Init. </p><div class="fragment"><div class="line"><a class="code" href="group__uart__driver.html#gab3ba5019c11f288cc4f545dd656b6284">UART_SetBaudRate</a>(UART1, 115200U, 20000000U);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">baudRate_Bps</td><td>UART baudrate to be set. </td></tr>
    <tr><td class="paramname">srcClock_Hz</td><td>UART clock source frequency in Hz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_UART_BaudrateNotSupport</td><td>Baudrate is not support in the current clock source. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Set baudrate succeeded.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sets the UART instance baud rate.</p>
<p>This function configures the UART module baud rate. This function is used to update the UART module baud rate after the UART module is initialized by the UART_Init. code UART_SetBaudRate(UART1, 115200U, 20000000U); endcode</p>
<p>param base UART peripheral base address. param baudRate_Bps UART baudrate to be set. param srcClock_Hz UART clock source frequency in Hz. retval kStatus_UART_BaudrateNotSupport Baudrate is not support in the current clock source. retval kStatus_Success Set baudrate succeeded. </p>

</div>
</div>
<a id="gacc35671622b2401545cc55cc6ae572d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc35671622b2401545cc55cc6ae572d4">&#9670;&nbsp;</a></span>UART_TransferAbortReceive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_TransferAbortReceive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the interrupt-driven data receiving. </p>
<p>This function aborts the interrupt-driven data receiving. The user can get the remainBytes to know how many bytes are not received yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts the interrupt-driven data receiving.</p>
<p>This function aborts the interrupt-driven data receiving. The user can get the remainBytes to know how many bytes are not received yet.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. </p>

</div>
</div>
<a id="gaa64f9f89d8286fd3ef0736a8c40be2c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa64f9f89d8286fd3ef0736a8c40be2c2">&#9670;&nbsp;</a></span>UART_TransferAbortSend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_TransferAbortSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the interrupt-driven data transmit. </p>
<p>This function aborts the interrupt-driven data sending. The user can get the remainBytes to find out how many bytes are not sent out.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts the interrupt-driven data transmit.</p>
<p>This function aborts the interrupt-driven data sending. The user can get the remainBytes to find out how many bytes are not sent out.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. </p>

</div>
</div>
<a id="ga63db308c32019b7dd6c0647d618e5247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63db308c32019b7dd6c0647d618e5247">&#9670;&nbsp;</a></span>UART_TransferCreateHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_TransferCreateHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__driver.html#ga2868b6ea396ab212547f2157380429c5">uart_transfer_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>userData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the UART handle. </p>
<p>This function initializes the UART handle which can be used for other UART transactional APIs. Usually, for a specified UART instance, call this API once to get the initialized handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">userData</td><td>The parameter of the callback function.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Initializes the UART handle.</p>
<p>This function initializes the UART handle which can be used for other UART transactional APIs. Usually, for a specified UART instance, call this API once to get the initialized handle.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. param callback The callback function. param userData The parameter of the callback function. </p>

</div>
</div>
<a id="ga05df10f570cdca4ac2dff63b069d254e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05df10f570cdca4ac2dff63b069d254e">&#9670;&nbsp;</a></span>UART_TransferGetReceiveCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_TransferGetReceiveCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of bytes that have been received. </p>
<p>This function gets the number of bytes that have been received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer. </td></tr>
    <tr><td class="paramname">count</td><td>Receive bytes count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_NoTransferInProgress</td><td>No receive in progress. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>Parameter is invalid. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Get successfully through the parameter <code>count</code>;</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the number of bytes that have been received.</p>
<p>This function gets the number of bytes that have been received.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. param count Receive bytes count. retval kStatus_NoTransferInProgress No receive in progress. retval kStatus_InvalidArgument Parameter is invalid. retval kStatus_Success Get successfully through the parameter <code>count</code>; </p>

</div>
</div>
<a id="ga3921aa660977ca77dadf95fa35f1c3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3921aa660977ca77dadf95fa35f1c3a9">&#9670;&nbsp;</a></span>UART_TransferGetRxRingBufferLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t UART_TransferGetRxRingBufferLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of received data in RX ring buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>UART handle pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of received data in RX ring buffer.</dd></dl>
<p>brief Get the length of received data in RX ring buffer.</p>
<p>param handle UART handle pointer. return Length of received data in RX ring buffer. </p>

</div>
</div>
<a id="ga071727ba05b2937ef5ad641ca7faf9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga071727ba05b2937ef5ad641ca7faf9c7">&#9670;&nbsp;</a></span>UART_TransferGetSendCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_TransferGetSendCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of bytes written to the UART TX register. </p>
<p>This function gets the number of bytes written to the UART TX register by using the interrupt method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer. </td></tr>
    <tr><td class="paramname">count</td><td>Send bytes count. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_NoTransferInProgress</td><td>No send in progress. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>The parameter is invalid. </td></tr>
    <tr><td class="paramname">kStatus_Success</td><td>Get successfully through the parameter <code>count</code>;</td></tr>
  </table>
  </dd>
</dl>
<p>brief Gets the number of bytes written to the UART TX register.</p>
<p>This function gets the number of bytes written to the UART TX register by using the interrupt method.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. param count Send bytes count. retval kStatus_NoTransferInProgress No send in progress. retval kStatus_InvalidArgument The parameter is invalid. retval kStatus_Success Get successfully through the parameter <code>count</code>; </p>

</div>
</div>
<a id="gafc364352e879f53138ee1107e3da0a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc364352e879f53138ee1107e3da0a7d">&#9670;&nbsp;</a></span>UART_TransferHandleErrorIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_TransferHandleErrorIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART Error IRQ handle function. </p>
<p>This function handles the UART error IRQ request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief UART Error IRQ handle function.</p>
<p>This function handles the UART error IRQ request.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. </p>

</div>
</div>
<a id="gadb0c4f1e5b59db3aa2261df4f5ddb48d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb0c4f1e5b59db3aa2261df4f5ddb48d">&#9670;&nbsp;</a></span>UART_TransferHandleIRQ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_TransferHandleIRQ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART IRQ handle function. </p>
<p>This function handles the UART transmit and receive IRQ request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief UART IRQ handle function.</p>
<p>This function handles the UART transmit and receive IRQ request.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. </p>

</div>
</div>
<a id="gaf804acde5d73ce0a5bf54b06195e1218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf804acde5d73ce0a5bf54b06195e1218">&#9670;&nbsp;</a></span>UART_TransferReceiveNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_TransferReceiveNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df">uart_transfer_t</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>receivedBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a buffer of data using an interrupt method. </p>
<p>This function receives data using an interrupt method. This is a non-blocking function, which returns without waiting for all data to be received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter <code>receivedBytes</code> shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough to read, the receive request is saved by the UART driver. When the new data arrives, the receive request is serviced first. When all data is received, the UART driver notifies the upper layer through a callback function and passes the status parameter <a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84bae0877b14627ed2aa8ddb2bf5b033f407">kStatus_UART_RxIdle</a>. For example, the upper layer needs 10 bytes but there are only 5 bytes in the ring buffer. The 5 bytes are copied to the xfer-&gt;data and this function returns with the parameter <code>receivedBytes</code> set to 5. For the left 5 bytes, newly arrived data is saved from the xfer-&gt;data[5]. When 5 bytes are received, the UART driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to the xfer-&gt;data. When all data is received, the upper layer is notified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer. </td></tr>
    <tr><td class="paramname">xfer</td><td>UART transfer structure, see <a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df" title="UART transfer structure.">uart_transfer_t</a>. </td></tr>
    <tr><td class="paramname">receivedBytes</td><td>Bytes received from the ring buffer directly. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully queue the transfer into transmit queue. </td></tr>
    <tr><td class="paramname">kStatus_UART_RxBusy</td><td>Previous receive request is not finished. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>Invalid argument.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Receives a buffer of data using an interrupt method.</p>
<p>This function receives data using an interrupt method. This is a non-blocking function, which returns without waiting for all data to be received. If the RX ring buffer is used and not empty, the data in the ring buffer is copied and the parameter p receivedBytes shows how many bytes are copied from the ring buffer. After copying, if the data in the ring buffer is not enough to read, the receive request is saved by the UART driver. When the new data arrives, the receive request is serviced first. When all data is received, the UART driver notifies the upper layer through a callback function and passes the status parameter ref kStatus_UART_RxIdle. For example, the upper layer needs 10 bytes but there are only 5 bytes in the ring buffer. The 5 bytes are copied to the xfer-&gt;data and this function returns with the parameter p receivedBytes set to 5. For the left 5 bytes, newly arrived data is saved from the xfer-&gt;data[5]. When 5 bytes are received, the UART driver notifies the upper layer. If the RX ring buffer is not enabled, this function enables the RX and RX interrupt to receive data to the xfer-&gt;data. When all data is received, the upper layer is notified.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. param xfer UART transfer structure, see <a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df" title="UART transfer structure.">uart_transfer_t</a>. param receivedBytes Bytes received from the ring buffer directly. retval kStatus_Success Successfully queue the transfer into transmit queue. retval kStatus_UART_RxBusy Previous receive request is not finished. retval kStatus_InvalidArgument Invalid argument. </p>

</div>
</div>
<a id="gad89afd7db1656c5aef404bb285d0dc05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89afd7db1656c5aef404bb285d0dc05">&#9670;&nbsp;</a></span>UART_TransferSendNonBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ksdk__common.html#gaaabdaf7ee58ca7269bd4bf24efcde092">status_t</a> UART_TransferSendNonBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df">uart_transfer_t</a> *&#160;</td>
          <td class="paramname"><em>xfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transmits a buffer of data using the interrupt method. </p>
<p>This function sends data using an interrupt method. This is a non-blocking function, which returns directly without waiting for all data to be written to the TX register. When all data is written to the TX register in the ISR, the UART driver calls the callback function and passes the <a class="el" href="group__uart__driver.html#ggacef40dc8e8ac174bfe40ebcbc980f84baf36c829b1b889517bf775c0d7ce29fa6">kStatus_UART_TxIdle</a> as status parameter.</p>
<dl class="section note"><dt>Note</dt><dd>The kStatus_UART_TxIdle is passed to the upper layer when all data is written to the TX register. However, it does not ensure that all data is sent out. Before disabling the TX, check the kUART_TransmissionCompleteFlag to ensure that the TX is finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer. </td></tr>
    <tr><td class="paramname">xfer</td><td>UART transfer structure. See <a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df" title="UART transfer structure.">uart_transfer_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">kStatus_Success</td><td>Successfully start the data transmission. </td></tr>
    <tr><td class="paramname">kStatus_UART_TxBusy</td><td>Previous transmission still not finished; data not all written to TX register yet. </td></tr>
    <tr><td class="paramname">kStatus_InvalidArgument</td><td>Invalid argument.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Transmits a buffer of data using the interrupt method.</p>
<p>This function sends data using an interrupt method. This is a non-blocking function, which returns directly without waiting for all data to be written to the TX register. When all data is written to the TX register in the ISR, the UART driver calls the callback function and passes the ref kStatus_UART_TxIdle as status parameter.</p>
<p>note The kStatus_UART_TxIdle is passed to the upper layer when all data is written to the TX register. However, it does not ensure that all data is sent out. Before disabling the TX, check the kUART_TransmissionCompleteFlag to ensure that the TX is finished.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. param xfer UART transfer structure. See <a class="el" href="group__uart__driver.html#gae245db88e02822f416e4d246d49076df" title="UART transfer structure.">uart_transfer_t</a>. retval kStatus_Success Successfully start the data transmission. retval kStatus_UART_TxBusy Previous transmission still not finished; data not all written to TX register yet. retval kStatus_InvalidArgument Invalid argument. </p>

</div>
</div>
<a id="ga223fba584bfabd599629d5ce92f929ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga223fba584bfabd599629d5ce92f929ac">&#9670;&nbsp;</a></span>UART_TransferStartRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_TransferStartRingBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>ringBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ringBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the RX ring buffer. </p>
<p>This function sets up the RX ring buffer to a specific UART handle.</p>
<p>When the RX ring buffer is used, data received are stored into the ring buffer even when the user doesn't call the <a class="el" href="group__uart__driver.html#gaf804acde5d73ce0a5bf54b06195e1218" title="Receives a buffer of data using an interrupt method.">UART_TransferReceiveNonBlocking()</a> API. If data is already received in the ring buffer, the user can get the received data from the ring buffer directly.</p>
<dl class="section note"><dt>Note</dt><dd>When using the RX ring buffer, one byte is reserved for internal use. In other words, if <code>ringBufferSize</code> is 32, only 31 bytes are used for saving data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer. </td></tr>
    <tr><td class="paramname">ringBuffer</td><td>Start address of the ring buffer for background receiving. Pass NULL to disable the ring buffer. </td></tr>
    <tr><td class="paramname">ringBufferSize</td><td>Size of the ring buffer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Sets up the RX ring buffer.</p>
<p>This function sets up the RX ring buffer to a specific UART handle.</p>
<p>When the RX ring buffer is used, data received are stored into the ring buffer even when the user doesn't call the <a class="el" href="group__uart__driver.html#gaf804acde5d73ce0a5bf54b06195e1218" title="Receives a buffer of data using an interrupt method.">UART_TransferReceiveNonBlocking()</a> API. If data is already received in the ring buffer, the user can get the received data from the ring buffer directly.</p>
<p>note When using the RX ring buffer, one byte is reserved for internal use. In other words, if p ringBufferSize is 32, only 31 bytes are used for saving data.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. param ringBuffer Start address of the ring buffer for background receiving. Pass NULL to disable the ring buffer. param ringBufferSize Size of the ring buffer. </p>

</div>
</div>
<a id="ga0c0bc73df49cb31dff0e903630314f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c0bc73df49cb31dff0e903630314f5b">&#9670;&nbsp;</a></span>UART_TransferStopRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_TransferStopRingBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__uart__handle.html">uart_handle_t</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts the background transfer and uninstalls the ring buffer. </p>
<p>This function aborts the background transfer and uninstalls the ring buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">handle</td><td>UART handle pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Aborts the background transfer and uninstalls the ring buffer.</p>
<p>This function aborts the background transfer and uninstalls the ring buffer.</p>
<p>param base UART peripheral base address. param handle UART handle pointer. </p>

</div>
</div>
<a id="gad67794d80b7ee2d3292b41af6ff1e100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67794d80b7ee2d3292b41af6ff1e100">&#9670;&nbsp;</a></span>UART_WriteBlocking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void UART_WriteBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_u_a_r_t___type.html">UART_Type</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes to the TX register using a blocking method. </p>
<p>This function polls the TX register, waits for the TX register to be empty or for the TX FIFO to have room and writes data to the TX buffer.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not check whether all data is sent out to the bus. Before disabling the TX, check kUART_TransmissionCompleteFlag to ensure that the TX is finished.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>UART peripheral base address. </td></tr>
    <tr><td class="paramname">data</td><td>Start address of the data to write. </td></tr>
    <tr><td class="paramname">length</td><td>Size of the data to write.</td></tr>
  </table>
  </dd>
</dl>
<p>brief Writes to the TX register using a blocking method.</p>
<p>This function polls the TX register, waits for the TX register to be empty or for the TX FIFO to have room and writes data to the TX buffer.</p>
<p>note This function does not check whether all data is sent out to the bus. Before disabling the TX, check kUART_TransmissionCompleteFlag to ensure that the TX is finished.</p>
<p>param base UART peripheral base address. param data Start address of the data to write. param length Size of the data to write. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
